"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/utils/storageUtils.ts":
/*!***********************************!*\
  !*** ./src/utils/storageUtils.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupOldBackups: () => (/* binding */ cleanupOldBackups),\n/* harmony export */   cleanupStorage: () => (/* binding */ cleanupStorage),\n/* harmony export */   createBackup: () => (/* binding */ createBackup),\n/* harmony export */   downloadExportedData: () => (/* binding */ downloadExportedData),\n/* harmony export */   exportData: () => (/* binding */ exportData),\n/* harmony export */   getStorageStats: () => (/* binding */ getStorageStats),\n/* harmony export */   getStorageUsage: () => (/* binding */ getStorageUsage),\n/* harmony export */   importData: () => (/* binding */ importData),\n/* harmony export */   importDataFromFile: () => (/* binding */ importDataFromFile),\n/* harmony export */   importDataWithStrategy: () => (/* binding */ importDataWithStrategy),\n/* harmony export */   isStorageAvailable: () => (/* binding */ isStorageAvailable),\n/* harmony export */   isStorageNearlyFull: () => (/* binding */ isStorageNearlyFull),\n/* harmony export */   loadDogProfiles: () => (/* binding */ loadDogProfiles),\n/* harmony export */   loadFromStorage: () => (/* binding */ loadFromStorage),\n/* harmony export */   loadRecommendations: () => (/* binding */ loadRecommendations),\n/* harmony export */   restoreFromBackup: () => (/* binding */ restoreFromBackup),\n/* harmony export */   saveDogProfiles: () => (/* binding */ saveDogProfiles),\n/* harmony export */   saveRecommendations: () => (/* binding */ saveRecommendations),\n/* harmony export */   saveToStorage: () => (/* binding */ saveToStorage)\n/* harmony export */ });\n/* harmony import */ var _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/storageSchema */ \"(app-pages-browser)/./src/types/storageSchema.ts\");\n/* harmony import */ var _errorHandling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errorHandling */ \"(app-pages-browser)/./src/utils/errorHandling.ts\");\n\n\n/**\n * Check if local storage is available\n * @returns true if available, false otherwise\n */ function isStorageAvailable() {\n    try {\n        const testKey = '__storage_test__';\n        localStorage.setItem(testKey, 'test');\n        const result = localStorage.getItem(testKey) === 'test';\n        localStorage.removeItem(testKey);\n        return result;\n    } catch (e) {\n        return false;\n    }\n}\n/**\n * Get the estimated local storage space usage in bytes\n * @returns Object containing used space and available space (if possible to determine)\n */ function getStorageUsage() {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        let totalSize = 0;\n        // Estimate space used by iterating through all keys\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if (key) {\n                const value = localStorage.getItem(key) || '';\n                totalSize += key.length + value.length;\n            }\n        }\n        // Convert to bytes (approximate as 2 bytes per character in UTF-16)\n        const usedBytes = totalSize * 2;\n        // Local storage limit is typically 5MB, but this varies by browser\n        const estimatedLimit = 5 * 1024 * 1024;\n        return {\n            used: usedBytes,\n            available: estimatedLimit - usedBytes,\n            percentUsed: usedBytes / estimatedLimit * 100\n        };\n    }, 'getStorageUsage');\n    if (error) {\n        return {\n            used: 0\n        };\n    }\n    return result || {\n        used: 0\n    };\n}\n/**\n * Check if storage is nearly full (over specified threshold)\n * @param thresholdPercent Percentage threshold (default: 80%)\n * @returns true if storage usage is over threshold\n */ function isStorageNearlyFull() {\n    let thresholdPercent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 80;\n    const usage = getStorageUsage();\n    return !!usage.percentUsed && usage.percentUsed > thresholdPercent;\n}\n/**\n * Save data to local storage with versioning\n * @param key Storage key\n * @param data Data to save\n * @throws StorageError if storage is not available or saving fails\n */ function saveToStorage(key, data) {\n    if (!isStorageAvailable()) {\n        throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Local storage is not available', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.STORAGE_UNAVAILABLE);\n    }\n    // Check if storage is nearly full\n    if (isStorageNearlyFull()) {\n        console.warn('Local storage is nearly full. Consider cleaning up old data.');\n    }\n    try {\n        // Create versioned data container\n        const storageData = {\n            version: _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.SCHEMA_VERSION,\n            updatedAt: Date.now(),\n            data\n        };\n        // Serialize and save\n        localStorage.setItem(key, JSON.stringify(storageData));\n    } catch (error) {\n        // Determine if this is a quota error\n        if (error instanceof Error && error.name === 'QuotaExceededError') {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Storage quota exceeded', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.STORAGE_QUOTA_EXCEEDED, {\n                originalError: error\n            });\n        }\n        throw (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.handleStorageError)(error, \"saveToStorage(\".concat(key, \")\"), _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.WRITE_ERROR);\n    }\n}\n/**\n * Load data from local storage with version checking\n * @param key Storage key\n * @param defaultValue Default value if not found or invalid\n * @returns The stored data or default value\n */ function loadFromStorage(key, defaultValue) {\n    if (!isStorageAvailable()) {\n        console.warn('Local storage is not available');\n        return defaultValue;\n    }\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        // Get serialized data\n        const serialized = localStorage.getItem(key);\n        if (!serialized) {\n            return defaultValue;\n        }\n        // Parse serialized data\n        const parsedData = JSON.parse(serialized);\n        // Version check\n        if (parsedData.version !== _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.SCHEMA_VERSION) {\n            console.warn(\"Storage schema version mismatch for \".concat(key, \". Expected \").concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.SCHEMA_VERSION, \", got \").concat(parsedData.version));\n            // Here we would add migration logic for different versions\n            // For now just return default\n            return defaultValue;\n        }\n        return parsedData;\n    }, \"loadFromStorage(\".concat(key, \")\"));\n    if (error) {\n        // Attempt to recover from backup on error\n        const backupResult = tryRestoreItemFromBackup(key);\n        if (backupResult.success && backupResult.data) {\n            try {\n                const parsedBackup = JSON.parse(backupResult.data);\n                return parsedBackup;\n            } catch (e) {\n                // If backup parsing fails, return default\n                return defaultValue;\n            }\n        }\n        return defaultValue;\n    }\n    return result || defaultValue;\n}\n/**\n * Try to restore a single item from its backup\n * @param key The key of the item to restore\n * @returns Success status and data if successful\n */ function tryRestoreItemFromBackup(key) {\n    try {\n        // Find backups for this specific key\n        const backupKey = \"\".concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX).concat(key);\n        const backupData = localStorage.getItem(backupKey);\n        if (backupData) {\n            // Restore from backup\n            localStorage.setItem(key, backupData);\n            return {\n                success: true,\n                data: backupData\n            };\n        }\n        return {\n            success: false,\n            data: null\n        };\n    } catch (e) {\n        return {\n            success: false,\n            data: null\n        };\n    }\n}\n/**\n * Create a backup of all application data\n * @returns true if backup successful, false otherwise\n */ function createBackup() {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        if (!isStorageAvailable()) {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Local storage is not available, cannot create backup', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.STORAGE_UNAVAILABLE);\n        }\n        const timestamp = Date.now();\n        const backupKey = \"\".concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX).concat(timestamp);\n        // Create a backup object with all app data\n        const backup = {\n            timestamp,\n            version: _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.SCHEMA_VERSION,\n            dogProfiles: localStorage.getItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES),\n            savedRecommendations: localStorage.getItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS),\n            userPreferences: localStorage.getItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES)\n        };\n        localStorage.setItem(backupKey, JSON.stringify(backup));\n        // Also create individual backups of each key\n        if (backup.dogProfiles) {\n            localStorage.setItem(\"\".concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX).concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES), backup.dogProfiles);\n        }\n        if (backup.savedRecommendations) {\n            localStorage.setItem(\"\".concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX).concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS), backup.savedRecommendations);\n        }\n        if (backup.userPreferences) {\n            localStorage.setItem(\"\".concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX).concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES), backup.userPreferences);\n        }\n        return true;\n    }, 'createBackup', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.BACKUP_ERROR);\n    return result === true;\n}\n/**\n * Restore data from the most recent backup\n * @returns true if restore successful, false otherwise\n */ function restoreFromBackup() {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        if (!isStorageAvailable()) {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Local storage is not available, cannot restore backup', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.STORAGE_UNAVAILABLE);\n        }\n        // Find the latest backup\n        let latestBackupKey = null;\n        let latestTimestamp = 0;\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if (key && key.startsWith(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES)) {\n                try {\n                    const timestamp = parseInt(key.replace(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX, ''), 10);\n                    if (!isNaN(timestamp) && timestamp > latestTimestamp) {\n                        latestTimestamp = timestamp;\n                        latestBackupKey = key;\n                    }\n                } catch (e) {\n                    continue;\n                }\n            }\n        }\n        if (!latestBackupKey) {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('No backup found', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.RESTORE_ERROR);\n        }\n        // Restore from backup\n        const serializedBackup = localStorage.getItem(latestBackupKey);\n        if (!serializedBackup) {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Backup is empty or corrupted', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.RESTORE_ERROR);\n        }\n        const backup = JSON.parse(serializedBackup);\n        if (backup.dogProfiles) {\n            localStorage.setItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, backup.dogProfiles);\n        }\n        if (backup.savedRecommendations) {\n            localStorage.setItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, backup.savedRecommendations);\n        }\n        if (backup.userPreferences) {\n            localStorage.setItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, backup.userPreferences);\n        }\n        return true;\n    }, 'restoreFromBackup', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.RESTORE_ERROR);\n    return result === true;\n}\n/**\n * Remove old backups, keeping only the most recent ones\n * @param keepCount Number of recent backups to keep (default: 3)\n * @returns number of backups removed\n */ function cleanupOldBackups() {\n    let keepCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        if (!isStorageAvailable()) {\n            return 0;\n        }\n        // Find all backups and their timestamps\n        const backups = [];\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if (key && key.startsWith(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES)) {\n                try {\n                    const timestamp = parseInt(key.replace(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX, ''), 10);\n                    if (!isNaN(timestamp)) {\n                        backups.push({\n                            key,\n                            timestamp\n                        });\n                    }\n                } catch (e) {\n                    continue;\n                }\n            }\n        }\n        // Sort by timestamp (newest first)\n        backups.sort((a, b)=>b.timestamp - a.timestamp);\n        // Remove old backups keeping the most recent ones\n        let removedCount = 0;\n        if (backups.length > keepCount) {\n            const toRemove = backups.slice(keepCount);\n            toRemove.forEach((backup)=>{\n                localStorage.removeItem(backup.key);\n                removedCount++;\n            });\n        }\n        return removedCount;\n    }, 'cleanupOldBackups');\n    return result || 0;\n}\n/**\n * Save dog profiles to storage\n * @param profiles Map of dog profiles by ID\n * @param activeProfileId ID of the active profile (optional)\n */ function saveDogProfiles(profiles, activeProfileId) {\n    const data = {\n        profiles,\n        activeProfileId\n    };\n    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, data);\n}\n/**\n * Load dog profiles from storage\n * @returns The stored dog profiles or default empty data\n */ function loadDogProfiles() {\n    return loadFromStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_DOG_PROFILES_STORAGE);\n}\n/**\n * Save saved recommendations to storage\n * @param recommendations Map of saved recommendations by product ID\n */ function saveRecommendations(recommendations) {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        const savedDates = {};\n        // Update timestamps for any new recommendations\n        Object.keys(recommendations).forEach((id)=>{\n            // Use existing timestamp if available, otherwise use current time\n            savedDates[id] = Date.now();\n        });\n        const data = {\n            recommendations,\n            savedDates\n        };\n        saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, data);\n    }, 'saveRecommendations');\n    if (error) {\n        throw error;\n    }\n}\n/**\n * Load saved recommendations from storage\n * @returns The stored recommendations or default empty data\n */ function loadRecommendations() {\n    return loadFromStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SAVED_RECOMMENDATIONS_STORAGE);\n}\n/**\n * Export all user data to a downloadable JSON file\n * @returns JSON string of all user data\n */ function exportData() {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        const dogProfiles = loadDogProfiles();\n        const savedRecommendations = loadRecommendations();\n        const userPreferences = loadFromStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_USER_PREFERENCES_STORAGE);\n        const exportData = {\n            schemaVersion: _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.SCHEMA_VERSION,\n            exportDate: new Date().toISOString(),\n            dogProfiles,\n            savedRecommendations,\n            userPreferences\n        };\n        return JSON.stringify(exportData, null, 2);\n    }, 'exportData', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.EXPORT_ERROR);\n    if (error) {\n        throw error;\n    }\n    return result || '{}';\n}\n/**\n * Import user data from a JSON string\n * @param jsonData JSON string with user data\n * @returns true if import successful, false otherwise\n */ function importData(jsonData) {\n    return importDataWithStrategy(jsonData, 'replace');\n}\n/**\n * Cleanup old or unused data from storage based on age threshold\n * @param olderThanDays Number of days after which data is considered old (default: 90)\n * @returns Object with counts of items cleaned up by category\n */ function cleanupStorage() {\n    let olderThanDays = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 90;\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        var _savedRecommendations_data, _savedRecommendations_data1;\n        if (!isStorageAvailable()) {\n            return {\n                recommendations: 0,\n                oldBackups: 0,\n                total: 0\n            };\n        }\n        const now = Date.now();\n        const ageThreshold = now - olderThanDays * 24 * 60 * 60 * 1000; // Convert days to milliseconds\n        let removedRecommendations = 0;\n        // Clean up old saved recommendations\n        const savedRecommendations = loadRecommendations();\n        if ((savedRecommendations === null || savedRecommendations === void 0 ? void 0 : (_savedRecommendations_data = savedRecommendations.data) === null || _savedRecommendations_data === void 0 ? void 0 : _savedRecommendations_data.recommendations) && (savedRecommendations === null || savedRecommendations === void 0 ? void 0 : (_savedRecommendations_data1 = savedRecommendations.data) === null || _savedRecommendations_data1 === void 0 ? void 0 : _savedRecommendations_data1.savedDates)) {\n            const { recommendations, savedDates } = savedRecommendations.data;\n            const updatedRecommendations = {};\n            const updatedSavedDates = {};\n            Object.entries(recommendations).forEach((param)=>{\n                let [id, recommendation] = param;\n                const savedDate = savedDates[id] || 0;\n                // Keep recommendations newer than the threshold\n                if (savedDate > ageThreshold) {\n                    updatedRecommendations[id] = recommendation;\n                    updatedSavedDates[id] = savedDate;\n                } else {\n                    removedRecommendations++;\n                }\n            });\n            // Only save if we removed any recommendations\n            if (removedRecommendations > 0) {\n                saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, {\n                    recommendations: updatedRecommendations,\n                    savedDates: updatedSavedDates\n                });\n            }\n        }\n        // Clean up old backups\n        const oldBackups = cleanupOldBackups(3); // Keep 3 most recent backups\n        const totalRemoved = removedRecommendations + oldBackups;\n        return {\n            recommendations: removedRecommendations,\n            oldBackups,\n            total: totalRemoved\n        };\n    }, 'cleanupStorage', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.CLEANUP_ERROR);\n    return result || {\n        recommendations: 0,\n        oldBackups: 0,\n        total: 0\n    };\n}\n/**\n * Download exported data as a JSON file\n * @param filename Custom filename (default: 'petfood-data-export.json')\n * @returns true if download initiated successfully, false otherwise\n */ function downloadExportedData() {\n    let filename = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'petfood-data-export.json';\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        const exportString = exportData();\n        // Create a Blob with the data\n        const blob = new Blob([\n            exportString\n        ], {\n            type: 'application/json'\n        });\n        const url = URL.createObjectURL(blob);\n        // Create a temporary link and trigger download\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = filename;\n        document.body.appendChild(link);\n        link.click();\n        // Clean up\n        setTimeout(()=>{\n            URL.revokeObjectURL(url);\n            document.body.removeChild(link);\n        }, 100);\n        return true;\n    }, 'downloadExportedData', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.EXPORT_ERROR);\n    return result === true;\n}\n/**\n * Import data from an uploaded file\n * @param file The uploaded File object\n * @param mergeStrategy How to handle existing data ('replace', 'merge', 'keep-newer')\n * @returns Promise resolving to true if import successful, false otherwise\n */ async function importDataFromFile(file) {\n    let mergeStrategy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'replace';\n    return new Promise((resolve)=>{\n        const reader = new FileReader();\n        reader.onload = (event)=>{\n            try {\n                var _event_target;\n                const jsonData = (_event_target = event.target) === null || _event_target === void 0 ? void 0 : _event_target.result;\n                const success = importDataWithStrategy(jsonData, mergeStrategy);\n                resolve(success);\n            } catch (error) {\n                console.error('Error importing data from file:', error);\n                resolve(false);\n            }\n        };\n        reader.onerror = ()=>{\n            console.error('Error reading file');\n            resolve(false);\n        };\n        reader.readAsText(file);\n    });\n}\n/**\n * Import data with the specified merge strategy\n * @param jsonData JSON string with user data\n * @param mergeStrategy How to handle existing data ('replace', 'merge', 'keep-newer')\n * @returns true if import successful, false otherwise\n */ function importDataWithStrategy(jsonData) {\n    let mergeStrategy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'replace';\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        var _importedData_dogProfiles_data, _importedData_dogProfiles, _importedData_savedRecommendations_data, _importedData_savedRecommendations, _importedData_userPreferences;\n        const importedData = JSON.parse(jsonData);\n        // Validate imported data\n        if (!importedData.schemaVersion || !importedData.exportDate) {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Invalid export data format', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.IMPORT_ERROR);\n        }\n        // Create backup before making any changes\n        createBackup();\n        // Handle dog profiles based on merge strategy\n        if ((_importedData_dogProfiles = importedData.dogProfiles) === null || _importedData_dogProfiles === void 0 ? void 0 : (_importedData_dogProfiles_data = _importedData_dogProfiles.data) === null || _importedData_dogProfiles_data === void 0 ? void 0 : _importedData_dogProfiles_data.profiles) {\n            if (mergeStrategy === 'replace') {\n                // Simply replace existing data\n                saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, importedData.dogProfiles.data);\n            } else {\n                var _existingProfiles_data;\n                // Merge or keep-newer strategies\n                const existingProfiles = loadDogProfiles();\n                if (existingProfiles === null || existingProfiles === void 0 ? void 0 : (_existingProfiles_data = existingProfiles.data) === null || _existingProfiles_data === void 0 ? void 0 : _existingProfiles_data.profiles) {\n                    const mergedProfiles = {\n                        ...existingProfiles.data\n                    };\n                    // Process each imported profile\n                    Object.entries(importedData.dogProfiles.data.profiles).forEach((param)=>{\n                        let [id, profile] = param;\n                        const existingProfile = mergedProfiles.profiles[id];\n                        if (!existingProfile) {\n                            // Profile doesn't exist in current data, add it\n                            mergedProfiles.profiles[id] = profile;\n                        } else if (mergeStrategy === 'keep-newer') {\n                            // Compare update timestamps and keep newer\n                            const importedTimestamp = importedData.dogProfiles.updatedAt || 0;\n                            const existingTimestamp = existingProfiles.updatedAt || 0;\n                            if (importedTimestamp > existingTimestamp) {\n                                mergedProfiles.profiles[id] = profile;\n                            }\n                        } else {\n                            // For 'merge' strategy, always update\n                            mergedProfiles.profiles[id] = profile;\n                        }\n                    });\n                    // Save merged profiles\n                    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, mergedProfiles);\n                } else {\n                    // No existing profiles, just import\n                    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, importedData.dogProfiles.data);\n                }\n            }\n        }\n        // Handle recommendations with similar merge strategy\n        if ((_importedData_savedRecommendations = importedData.savedRecommendations) === null || _importedData_savedRecommendations === void 0 ? void 0 : (_importedData_savedRecommendations_data = _importedData_savedRecommendations.data) === null || _importedData_savedRecommendations_data === void 0 ? void 0 : _importedData_savedRecommendations_data.recommendations) {\n            if (mergeStrategy === 'replace') {\n                saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, importedData.savedRecommendations.data);\n            } else {\n                var _existingRecommendations_data;\n                const existingRecommendations = loadRecommendations();\n                if (existingRecommendations === null || existingRecommendations === void 0 ? void 0 : (_existingRecommendations_data = existingRecommendations.data) === null || _existingRecommendations_data === void 0 ? void 0 : _existingRecommendations_data.recommendations) {\n                    const mergedRecommendations = {\n                        recommendations: {\n                            ...existingRecommendations.data.recommendations\n                        },\n                        savedDates: {\n                            ...existingRecommendations.data.savedDates\n                        }\n                    };\n                    // Process each imported recommendation\n                    Object.entries(importedData.savedRecommendations.data.recommendations).forEach((param)=>{\n                        let [id, recommendation] = param;\n                        var _importedData_savedRecommendations_data_savedDates;\n                        const existingRecommendation = mergedRecommendations.recommendations[id];\n                        const importedSavedDate = ((_importedData_savedRecommendations_data_savedDates = importedData.savedRecommendations.data.savedDates) === null || _importedData_savedRecommendations_data_savedDates === void 0 ? void 0 : _importedData_savedRecommendations_data_savedDates[id]) || 0;\n                        const existingSavedDate = mergedRecommendations.savedDates[id] || 0;\n                        if (!existingRecommendation) {\n                            // Recommendation doesn't exist, add it\n                            mergedRecommendations.recommendations[id] = recommendation;\n                            mergedRecommendations.savedDates[id] = importedSavedDate;\n                        } else if (mergeStrategy === 'keep-newer' && importedSavedDate > existingSavedDate) {\n                            // 'keep-newer' strategy - update if imported is newer\n                            mergedRecommendations.recommendations[id] = recommendation;\n                            mergedRecommendations.savedDates[id] = importedSavedDate;\n                        } else if (mergeStrategy === 'merge') {\n                            // 'merge' strategy - always update\n                            mergedRecommendations.recommendations[id] = recommendation;\n                            mergedRecommendations.savedDates[id] = importedSavedDate;\n                        }\n                    });\n                    // Save merged recommendations\n                    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, mergedRecommendations);\n                } else {\n                    // No existing recommendations, just import\n                    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, importedData.savedRecommendations.data);\n                }\n            }\n        }\n        // Handle user preferences\n        if ((_importedData_userPreferences = importedData.userPreferences) === null || _importedData_userPreferences === void 0 ? void 0 : _importedData_userPreferences.data) {\n            if (mergeStrategy === 'replace') {\n                saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, importedData.userPreferences.data);\n            } else {\n                const existingPreferences = loadFromStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_USER_PREFERENCES_STORAGE);\n                if (existingPreferences === null || existingPreferences === void 0 ? void 0 : existingPreferences.data) {\n                    if (mergeStrategy === 'keep-newer') {\n                        const importedTimestamp = importedData.userPreferences.updatedAt || 0;\n                        const existingTimestamp = existingPreferences.updatedAt || 0;\n                        if (importedTimestamp > existingTimestamp) {\n                            saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, importedData.userPreferences.data);\n                        }\n                    } else {\n                        // For 'merge' strategy, merge objects\n                        const mergedPreferences = {\n                            ...existingPreferences.data,\n                            ...importedData.userPreferences.data\n                        };\n                        saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, mergedPreferences);\n                    }\n                } else {\n                    // No existing preferences, just import\n                    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, importedData.userPreferences.data);\n                }\n            }\n        }\n        return true;\n    }, 'importDataWithStrategy', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.IMPORT_ERROR);\n    return result === true;\n}\n/**\n * Get statistics about storage usage and item counts\n * @returns Object with storage usage statistics\n */ function getStorageStats() {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        var _dogProfiles_data, _savedRecommendations_data;\n        // Get storage usage\n        const usage = getStorageUsage();\n        // Count items\n        const dogProfiles = loadDogProfiles();\n        const savedRecommendations = loadRecommendations();\n        // Count backups\n        let backupCount = 0;\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if (key && key.startsWith(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES)) {\n                backupCount++;\n            }\n        }\n        // Get profile and recommendation counts\n        const profileCount = (dogProfiles === null || dogProfiles === void 0 ? void 0 : (_dogProfiles_data = dogProfiles.data) === null || _dogProfiles_data === void 0 ? void 0 : _dogProfiles_data.profiles) ? Object.keys(dogProfiles.data.profiles).length : 0;\n        const recommendationCount = (savedRecommendations === null || savedRecommendations === void 0 ? void 0 : (_savedRecommendations_data = savedRecommendations.data) === null || _savedRecommendations_data === void 0 ? void 0 : _savedRecommendations_data.recommendations) ? Object.keys(savedRecommendations.data.recommendations).length : 0;\n        return {\n            usage,\n            counts: {\n                dogProfiles: profileCount,\n                savedRecommendations: recommendationCount,\n                backups: backupCount\n            },\n            lastUpdated: {\n                dogProfiles: dogProfiles === null || dogProfiles === void 0 ? void 0 : dogProfiles.updatedAt,\n                savedRecommendations: savedRecommendations === null || savedRecommendations === void 0 ? void 0 : savedRecommendations.updatedAt,\n                backups: getLatestBackupTimestamp()\n            }\n        };\n    }, 'getStorageStats');\n    return result || {\n        usage: {\n            used: 0\n        },\n        counts: {\n            dogProfiles: 0,\n            savedRecommendations: 0,\n            backups: 0\n        },\n        lastUpdated: {}\n    };\n}\n/**\n * Get the timestamp of the most recent backup\n * @returns Timestamp of the most recent backup, or undefined if none exists\n */ function getLatestBackupTimestamp() {\n    const { result } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        let latestTimestamp;\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if (key && key.startsWith(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES)) {\n                try {\n                    const timestamp = parseInt(key.replace(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX, ''), 10);\n                    if (!isNaN(timestamp) && (!latestTimestamp || timestamp > latestTimestamp)) {\n                        latestTimestamp = timestamp;\n                    }\n                } catch (e) {\n                    continue;\n                }\n            }\n        }\n        return latestTimestamp;\n    }, 'getLatestBackupTimestamp');\n    return result;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9zdG9yYWdlVXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBVWdDO0FBR3NFO0FBRXRHOzs7Q0FHQyxHQUNNLFNBQVNTO0lBQ2QsSUFBSTtRQUNGLE1BQU1DLFVBQVU7UUFDaEJDLGFBQWFDLE9BQU8sQ0FBQ0YsU0FBUztRQUM5QixNQUFNRyxTQUFTRixhQUFhRyxPQUFPLENBQUNKLGFBQWE7UUFDakRDLGFBQWFJLFVBQVUsQ0FBQ0w7UUFDeEIsT0FBT0c7SUFDVCxFQUFFLE9BQU9HLEdBQUc7UUFDVixPQUFPO0lBQ1Q7QUFDRjtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNDO0lBQ2QsTUFBTSxFQUFFSixNQUFNLEVBQUVLLEtBQUssRUFBRSxHQUFHViwrREFBZUEsQ0FBQztRQUN4QyxJQUFJVyxZQUFZO1FBRWhCLG9EQUFvRDtRQUNwRCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVQsYUFBYVUsTUFBTSxFQUFFRCxJQUFLO1lBQzVDLE1BQU1FLE1BQU1YLGFBQWFXLEdBQUcsQ0FBQ0Y7WUFDN0IsSUFBSUUsS0FBSztnQkFDUCxNQUFNQyxRQUFRWixhQUFhRyxPQUFPLENBQUNRLFFBQVE7Z0JBQzNDSCxhQUFhRyxJQUFJRCxNQUFNLEdBQUdFLE1BQU1GLE1BQU07WUFDeEM7UUFDRjtRQUVBLG9FQUFvRTtRQUNwRSxNQUFNRyxZQUFZTCxZQUFZO1FBRTlCLG1FQUFtRTtRQUNuRSxNQUFNTSxpQkFBaUIsSUFBSSxPQUFPO1FBRWxDLE9BQU87WUFDTEMsTUFBTUY7WUFDTkcsV0FBV0YsaUJBQWlCRDtZQUM1QkksYUFBYSxZQUFhSCxpQkFBa0I7UUFDOUM7SUFDRixHQUFHO0lBRUgsSUFBSVAsT0FBTztRQUNULE9BQU87WUFBRVEsTUFBTTtRQUFFO0lBQ25CO0lBRUEsT0FBT2IsVUFBVTtRQUFFYSxNQUFNO0lBQUU7QUFDN0I7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0c7UUFBb0JD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RDRDLFNBQVM4RjtZQUNYO1FBQ0Y7SUFDRixHQUFHO0lBRUgsT0FBT3BLLFVBQVU7UUFDZmtCLE9BQU87WUFBRUwsTUFBTTtRQUFFO1FBQ2pCcUosUUFBUTtZQUFFL0csYUFBYTtZQUFHRSxzQkFBc0I7WUFBR2lCLFNBQVM7UUFBRTtRQUM5RDZGLGFBQWEsQ0FBQztJQUNoQjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0M7SUFDUCxNQUFNLEVBQUVwSyxNQUFNLEVBQUUsR0FBR0wsK0RBQWVBLENBQUM7UUFDakMsSUFBSWlFO1FBRUosSUFBSyxJQUFJckQsSUFBSSxHQUFHQSxJQUFJVCxhQUFhVSxNQUFNLEVBQUVELElBQUs7WUFDNUMsTUFBTUUsTUFBTVgsYUFBYVcsR0FBRyxDQUFDRjtZQUM3QixJQUFJRSxPQUFPQSxJQUFJb0QsVUFBVSxDQUFDekUsNERBQVVBLENBQUMwRCxhQUFhLEtBQUssQ0FBQ3JDLElBQUlxRCxRQUFRLENBQUMxRSw0REFBVUEsQ0FBQ2dFLFlBQVksS0FDeEYsQ0FBQzNDLElBQUlxRCxRQUFRLENBQUMxRSw0REFBVUEsQ0FBQ2tFLHFCQUFxQixLQUFLLENBQUM3QyxJQUFJcUQsUUFBUSxDQUFDMUUsNERBQVVBLENBQUNvRSxnQkFBZ0IsR0FBRztnQkFDakcsSUFBSTtvQkFDRixNQUFNUCxZQUFZYyxTQUFTdEQsSUFBSXVELE9BQU8sQ0FBQzVFLDREQUFVQSxDQUFDMEQsYUFBYSxFQUFFLEtBQUs7b0JBQ3RFLElBQUksQ0FBQ21CLE1BQU1oQixjQUFlLEVBQUNXLG1CQUFtQlgsWUFBWVcsZUFBYyxHQUFJO3dCQUMxRUEsa0JBQWtCWDtvQkFDcEI7Z0JBQ0YsRUFBRSxPQUFPOUMsR0FBRztvQkFDVjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxPQUFPeUQ7SUFDVCxHQUFHO0lBRUgsT0FBTzVEO0FBQ1QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb25hdGhhbm1haHJ0Z3V5b3UvRGVza3RvcC9Kb01hR3V5IFByb2plY3RzL1BldEZvb2Qvc3JjL3V0aWxzL3N0b3JhZ2VVdGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBcbiAgQmFzZVN0b3JhZ2VTY2hlbWEsIFxuICBTQ0hFTUFfVkVSU0lPTiwgXG4gIFN0b3JhZ2VLZXksXG4gIERFRkFVTFRfRE9HX1BST0ZJTEVTX1NUT1JBR0UsXG4gIERFRkFVTFRfU0FWRURfUkVDT01NRU5EQVRJT05TX1NUT1JBR0UsXG4gIERFRkFVTFRfVVNFUl9QUkVGRVJFTkNFU19TVE9SQUdFLFxuICBEb2dQcm9maWxlc1N0b3JhZ2VTY2hlbWEsXG4gIFNhdmVkUmVjb21tZW5kYXRpb25zU3RvcmFnZVNjaGVtYSxcbiAgVXNlclByZWZlcmVuY2VzU3RvcmFnZVNjaGVtYVxufSBmcm9tICcuLi90eXBlcy9zdG9yYWdlU2NoZW1hJztcbmltcG9ydCB7IERvZ1Byb2ZpbGUgfSBmcm9tICcuLi90eXBlcy9kb2dQcm9maWxlJztcbmltcG9ydCB7IEZvb2RSZWNvbW1lbmRhdGlvbiB9IGZyb20gJy4vcmVjb21tZW5kYXRpb25BbGdvcml0aG0nO1xuaW1wb3J0IHsgU3RvcmFnZUVycm9yLCBTdG9yYWdlRXJyb3JUeXBlLCBoYW5kbGVTdG9yYWdlRXJyb3IsIHRyeUNhdGNoU3RvcmFnZSB9IGZyb20gJy4vZXJyb3JIYW5kbGluZyc7XG5cbi8qKlxuICogQ2hlY2sgaWYgbG9jYWwgc3RvcmFnZSBpcyBhdmFpbGFibGVcbiAqIEByZXR1cm5zIHRydWUgaWYgYXZhaWxhYmxlLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RvcmFnZUF2YWlsYWJsZSgpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0ZXN0S2V5ID0gJ19fc3RvcmFnZV90ZXN0X18nO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRlc3RLZXksICd0ZXN0Jyk7XG4gICAgY29uc3QgcmVzdWx0ID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0odGVzdEtleSkgPT09ICd0ZXN0JztcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0ZXN0S2V5KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBlc3RpbWF0ZWQgbG9jYWwgc3RvcmFnZSBzcGFjZSB1c2FnZSBpbiBieXRlc1xuICogQHJldHVybnMgT2JqZWN0IGNvbnRhaW5pbmcgdXNlZCBzcGFjZSBhbmQgYXZhaWxhYmxlIHNwYWNlIChpZiBwb3NzaWJsZSB0byBkZXRlcm1pbmUpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdG9yYWdlVXNhZ2UoKTogeyB1c2VkOiBudW1iZXI7IGF2YWlsYWJsZT86IG51bWJlcjsgcGVyY2VudFVzZWQ/OiBudW1iZXIgfSB7XG4gIGNvbnN0IHsgcmVzdWx0LCBlcnJvciB9ID0gdHJ5Q2F0Y2hTdG9yYWdlKCgpID0+IHtcbiAgICBsZXQgdG90YWxTaXplID0gMDtcbiAgICBcbiAgICAvLyBFc3RpbWF0ZSBzcGFjZSB1c2VkIGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGFsbCBrZXlzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSB8fCAnJztcbiAgICAgICAgdG90YWxTaXplICs9IGtleS5sZW5ndGggKyB2YWx1ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnZlcnQgdG8gYnl0ZXMgKGFwcHJveGltYXRlIGFzIDIgYnl0ZXMgcGVyIGNoYXJhY3RlciBpbiBVVEYtMTYpXG4gICAgY29uc3QgdXNlZEJ5dGVzID0gdG90YWxTaXplICogMjtcbiAgICBcbiAgICAvLyBMb2NhbCBzdG9yYWdlIGxpbWl0IGlzIHR5cGljYWxseSA1TUIsIGJ1dCB0aGlzIHZhcmllcyBieSBicm93c2VyXG4gICAgY29uc3QgZXN0aW1hdGVkTGltaXQgPSA1ICogMTAyNCAqIDEwMjQ7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHVzZWQ6IHVzZWRCeXRlcyxcbiAgICAgIGF2YWlsYWJsZTogZXN0aW1hdGVkTGltaXQgLSB1c2VkQnl0ZXMsXG4gICAgICBwZXJjZW50VXNlZDogKHVzZWRCeXRlcyAvIGVzdGltYXRlZExpbWl0KSAqIDEwMFxuICAgIH07XG4gIH0sICdnZXRTdG9yYWdlVXNhZ2UnKTtcbiAgXG4gIGlmIChlcnJvcikge1xuICAgIHJldHVybiB7IHVzZWQ6IDAgfTtcbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdCB8fCB7IHVzZWQ6IDAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBzdG9yYWdlIGlzIG5lYXJseSBmdWxsIChvdmVyIHNwZWNpZmllZCB0aHJlc2hvbGQpXG4gKiBAcGFyYW0gdGhyZXNob2xkUGVyY2VudCBQZXJjZW50YWdlIHRocmVzaG9sZCAoZGVmYXVsdDogODAlKVxuICogQHJldHVybnMgdHJ1ZSBpZiBzdG9yYWdlIHVzYWdlIGlzIG92ZXIgdGhyZXNob2xkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1N0b3JhZ2VOZWFybHlGdWxsKHRocmVzaG9sZFBlcmNlbnQ6IG51bWJlciA9IDgwKTogYm9vbGVhbiB7XG4gIGNvbnN0IHVzYWdlID0gZ2V0U3RvcmFnZVVzYWdlKCk7XG4gIHJldHVybiAhIXVzYWdlLnBlcmNlbnRVc2VkICYmIHVzYWdlLnBlcmNlbnRVc2VkID4gdGhyZXNob2xkUGVyY2VudDtcbn1cblxuLyoqXG4gKiBTYXZlIGRhdGEgdG8gbG9jYWwgc3RvcmFnZSB3aXRoIHZlcnNpb25pbmdcbiAqIEBwYXJhbSBrZXkgU3RvcmFnZSBrZXlcbiAqIEBwYXJhbSBkYXRhIERhdGEgdG8gc2F2ZVxuICogQHRocm93cyBTdG9yYWdlRXJyb3IgaWYgc3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIG9yIHNhdmluZyBmYWlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVRvU3RvcmFnZTxUPihrZXk6IHN0cmluZywgZGF0YTogVCk6IHZvaWQge1xuICBpZiAoIWlzU3RvcmFnZUF2YWlsYWJsZSgpKSB7XG4gICAgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcihcbiAgICAgICdMb2NhbCBzdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUnLFxuICAgICAgU3RvcmFnZUVycm9yVHlwZS5TVE9SQUdFX1VOQVZBSUxBQkxFXG4gICAgKTtcbiAgfVxuICBcbiAgLy8gQ2hlY2sgaWYgc3RvcmFnZSBpcyBuZWFybHkgZnVsbFxuICBpZiAoaXNTdG9yYWdlTmVhcmx5RnVsbCgpKSB7XG4gICAgY29uc29sZS53YXJuKCdMb2NhbCBzdG9yYWdlIGlzIG5lYXJseSBmdWxsLiBDb25zaWRlciBjbGVhbmluZyB1cCBvbGQgZGF0YS4nKTtcbiAgfVxuICBcbiAgdHJ5IHtcbiAgICAvLyBDcmVhdGUgdmVyc2lvbmVkIGRhdGEgY29udGFpbmVyXG4gICAgY29uc3Qgc3RvcmFnZURhdGE6IEJhc2VTdG9yYWdlU2NoZW1hPFQ+ID0ge1xuICAgICAgdmVyc2lvbjogU0NIRU1BX1ZFUlNJT04sXG4gICAgICB1cGRhdGVkQXQ6IERhdGUubm93KCksXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICBcbiAgICAvLyBTZXJpYWxpemUgYW5kIHNhdmVcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHN0b3JhZ2VEYXRhKSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoaXMgaXMgYSBxdW90YSBlcnJvclxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09ICdRdW90YUV4Y2VlZGVkRXJyb3InKSB7XG4gICAgICB0aHJvdyBuZXcgU3RvcmFnZUVycm9yKFxuICAgICAgICAnU3RvcmFnZSBxdW90YSBleGNlZWRlZCcsXG4gICAgICAgIFN0b3JhZ2VFcnJvclR5cGUuU1RPUkFHRV9RVU9UQV9FWENFRURFRCxcbiAgICAgICAgeyBvcmlnaW5hbEVycm9yOiBlcnJvciB9XG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICB0aHJvdyBoYW5kbGVTdG9yYWdlRXJyb3IoXG4gICAgICBlcnJvciwgXG4gICAgICBgc2F2ZVRvU3RvcmFnZSgke2tleX0pYCwgXG4gICAgICBTdG9yYWdlRXJyb3JUeXBlLldSSVRFX0VSUk9SXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIExvYWQgZGF0YSBmcm9tIGxvY2FsIHN0b3JhZ2Ugd2l0aCB2ZXJzaW9uIGNoZWNraW5nXG4gKiBAcGFyYW0ga2V5IFN0b3JhZ2Uga2V5XG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIERlZmF1bHQgdmFsdWUgaWYgbm90IGZvdW5kIG9yIGludmFsaWRcbiAqIEByZXR1cm5zIFRoZSBzdG9yZWQgZGF0YSBvciBkZWZhdWx0IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkRnJvbVN0b3JhZ2U8VD4oa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZTogQmFzZVN0b3JhZ2VTY2hlbWE8VD4pOiBCYXNlU3RvcmFnZVNjaGVtYTxUPiB7XG4gIGlmICghaXNTdG9yYWdlQXZhaWxhYmxlKCkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0xvY2FsIHN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZScpO1xuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gIH1cbiAgXG4gIGNvbnN0IHsgcmVzdWx0LCBlcnJvciB9ID0gdHJ5Q2F0Y2hTdG9yYWdlKCgpID0+IHtcbiAgICAvLyBHZXQgc2VyaWFsaXplZCBkYXRhXG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgXG4gICAgaWYgKCFzZXJpYWxpemVkKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBQYXJzZSBzZXJpYWxpemVkIGRhdGFcbiAgICBjb25zdCBwYXJzZWREYXRhID0gSlNPTi5wYXJzZShzZXJpYWxpemVkKSBhcyBCYXNlU3RvcmFnZVNjaGVtYTxUPjtcbiAgICBcbiAgICAvLyBWZXJzaW9uIGNoZWNrXG4gICAgaWYgKHBhcnNlZERhdGEudmVyc2lvbiAhPT0gU0NIRU1BX1ZFUlNJT04pIHtcbiAgICAgIGNvbnNvbGUud2FybihgU3RvcmFnZSBzY2hlbWEgdmVyc2lvbiBtaXNtYXRjaCBmb3IgJHtrZXl9LiBFeHBlY3RlZCAke1NDSEVNQV9WRVJTSU9OfSwgZ290ICR7cGFyc2VkRGF0YS52ZXJzaW9ufWApO1xuICAgICAgLy8gSGVyZSB3ZSB3b3VsZCBhZGQgbWlncmF0aW9uIGxvZ2ljIGZvciBkaWZmZXJlbnQgdmVyc2lvbnNcbiAgICAgIC8vIEZvciBub3cganVzdCByZXR1cm4gZGVmYXVsdFxuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHBhcnNlZERhdGE7XG4gIH0sIGBsb2FkRnJvbVN0b3JhZ2UoJHtrZXl9KWApO1xuICBcbiAgaWYgKGVycm9yKSB7XG4gICAgLy8gQXR0ZW1wdCB0byByZWNvdmVyIGZyb20gYmFja3VwIG9uIGVycm9yXG4gICAgY29uc3QgYmFja3VwUmVzdWx0ID0gdHJ5UmVzdG9yZUl0ZW1Gcm9tQmFja3VwKGtleSk7XG4gICAgaWYgKGJhY2t1cFJlc3VsdC5zdWNjZXNzICYmIGJhY2t1cFJlc3VsdC5kYXRhKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWRCYWNrdXAgPSBKU09OLnBhcnNlKGJhY2t1cFJlc3VsdC5kYXRhKSBhcyBCYXNlU3RvcmFnZVNjaGVtYTxUPjtcbiAgICAgICAgcmV0dXJuIHBhcnNlZEJhY2t1cDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWYgYmFja3VwIHBhcnNpbmcgZmFpbHMsIHJldHVybiBkZWZhdWx0XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gIH1cbiAgXG4gIHJldHVybiByZXN1bHQgfHwgZGVmYXVsdFZhbHVlO1xufVxuXG4vKipcbiAqIFRyeSB0byByZXN0b3JlIGEgc2luZ2xlIGl0ZW0gZnJvbSBpdHMgYmFja3VwXG4gKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGl0ZW0gdG8gcmVzdG9yZVxuICogQHJldHVybnMgU3VjY2VzcyBzdGF0dXMgYW5kIGRhdGEgaWYgc3VjY2Vzc2Z1bFxuICovXG5mdW5jdGlvbiB0cnlSZXN0b3JlSXRlbUZyb21CYWNrdXAoa2V5OiBzdHJpbmcpOiB7IHN1Y2Nlc3M6IGJvb2xlYW47IGRhdGE6IHN0cmluZyB8IG51bGwgfSB7XG4gIHRyeSB7XG4gICAgLy8gRmluZCBiYWNrdXBzIGZvciB0aGlzIHNwZWNpZmljIGtleVxuICAgIGNvbnN0IGJhY2t1cEtleSA9IGAke1N0b3JhZ2VLZXkuQkFDS1VQX1BSRUZJWH0ke2tleX1gO1xuICAgIGNvbnN0IGJhY2t1cERhdGEgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShiYWNrdXBLZXkpO1xuICAgIFxuICAgIGlmIChiYWNrdXBEYXRhKSB7XG4gICAgICAvLyBSZXN0b3JlIGZyb20gYmFja3VwXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIGJhY2t1cERhdGEpO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogYmFja3VwRGF0YSB9O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZGF0YTogbnVsbCB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGRhdGE6IG51bGwgfTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGJhY2t1cCBvZiBhbGwgYXBwbGljYXRpb24gZGF0YVxuICogQHJldHVybnMgdHJ1ZSBpZiBiYWNrdXAgc3VjY2Vzc2Z1bCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCYWNrdXAoKTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgcmVzdWx0LCBlcnJvciB9ID0gdHJ5Q2F0Y2hTdG9yYWdlKCgpID0+IHtcbiAgICBpZiAoIWlzU3RvcmFnZUF2YWlsYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgU3RvcmFnZUVycm9yKFxuICAgICAgICAnTG9jYWwgc3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlLCBjYW5ub3QgY3JlYXRlIGJhY2t1cCcsXG4gICAgICAgIFN0b3JhZ2VFcnJvclR5cGUuU1RPUkFHRV9VTkFWQUlMQUJMRVxuICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBiYWNrdXBLZXkgPSBgJHtTdG9yYWdlS2V5LkJBQ0tVUF9QUkVGSVh9JHt0aW1lc3RhbXB9YDtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBiYWNrdXAgb2JqZWN0IHdpdGggYWxsIGFwcCBkYXRhXG4gICAgY29uc3QgYmFja3VwID0ge1xuICAgICAgdGltZXN0YW1wLFxuICAgICAgdmVyc2lvbjogU0NIRU1BX1ZFUlNJT04sXG4gICAgICBkb2dQcm9maWxlczogbG9jYWxTdG9yYWdlLmdldEl0ZW0oU3RvcmFnZUtleS5ET0dfUFJPRklMRVMpLFxuICAgICAgc2F2ZWRSZWNvbW1lbmRhdGlvbnM6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFN0b3JhZ2VLZXkuU0FWRURfUkVDT01NRU5EQVRJT05TKSxcbiAgICAgIHVzZXJQcmVmZXJlbmNlczogbG9jYWxTdG9yYWdlLmdldEl0ZW0oU3RvcmFnZUtleS5VU0VSX1BSRUZFUkVOQ0VTKVxuICAgIH07XG4gICAgXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYmFja3VwS2V5LCBKU09OLnN0cmluZ2lmeShiYWNrdXApKTtcbiAgICBcbiAgICAvLyBBbHNvIGNyZWF0ZSBpbmRpdmlkdWFsIGJhY2t1cHMgb2YgZWFjaCBrZXlcbiAgICBpZiAoYmFja3VwLmRvZ1Byb2ZpbGVzKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgJHtTdG9yYWdlS2V5LkJBQ0tVUF9QUkVGSVh9JHtTdG9yYWdlS2V5LkRPR19QUk9GSUxFU31gLCBiYWNrdXAuZG9nUHJvZmlsZXMpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYmFja3VwLnNhdmVkUmVjb21tZW5kYXRpb25zKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgJHtTdG9yYWdlS2V5LkJBQ0tVUF9QUkVGSVh9JHtTdG9yYWdlS2V5LlNBVkVEX1JFQ09NTUVOREFUSU9OU31gLCBiYWNrdXAuc2F2ZWRSZWNvbW1lbmRhdGlvbnMpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYmFja3VwLnVzZXJQcmVmZXJlbmNlcykge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYCR7U3RvcmFnZUtleS5CQUNLVVBfUFJFRklYfSR7U3RvcmFnZUtleS5VU0VSX1BSRUZFUkVOQ0VTfWAsIGJhY2t1cC51c2VyUHJlZmVyZW5jZXMpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgJ2NyZWF0ZUJhY2t1cCcsIFN0b3JhZ2VFcnJvclR5cGUuQkFDS1VQX0VSUk9SKTtcbiAgXG4gIHJldHVybiByZXN1bHQgPT09IHRydWU7XG59XG5cbi8qKlxuICogUmVzdG9yZSBkYXRhIGZyb20gdGhlIG1vc3QgcmVjZW50IGJhY2t1cFxuICogQHJldHVybnMgdHJ1ZSBpZiByZXN0b3JlIHN1Y2Nlc3NmdWwsIGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZUZyb21CYWNrdXAoKTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgcmVzdWx0LCBlcnJvciB9ID0gdHJ5Q2F0Y2hTdG9yYWdlKCgpID0+IHtcbiAgICBpZiAoIWlzU3RvcmFnZUF2YWlsYWJsZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgU3RvcmFnZUVycm9yKFxuICAgICAgICAnTG9jYWwgc3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlLCBjYW5ub3QgcmVzdG9yZSBiYWNrdXAnLFxuICAgICAgICBTdG9yYWdlRXJyb3JUeXBlLlNUT1JBR0VfVU5BVkFJTEFCTEVcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZpbmQgdGhlIGxhdGVzdCBiYWNrdXBcbiAgICBsZXQgbGF0ZXN0QmFja3VwS2V5OiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgbGF0ZXN0VGltZXN0YW1wID0gMDtcbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgIGlmIChrZXkgJiYga2V5LnN0YXJ0c1dpdGgoU3RvcmFnZUtleS5CQUNLVVBfUFJFRklYKSAmJiAha2V5LmluY2x1ZGVzKFN0b3JhZ2VLZXkuRE9HX1BST0ZJTEVTKSAmJiBcbiAgICAgICAgICAha2V5LmluY2x1ZGVzKFN0b3JhZ2VLZXkuU0FWRURfUkVDT01NRU5EQVRJT05TKSAmJiAha2V5LmluY2x1ZGVzKFN0b3JhZ2VLZXkuVVNFUl9QUkVGRVJFTkNFUykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBwYXJzZUludChrZXkucmVwbGFjZShTdG9yYWdlS2V5LkJBQ0tVUF9QUkVGSVgsICcnKSwgMTApO1xuICAgICAgICAgIGlmICghaXNOYU4odGltZXN0YW1wKSAmJiB0aW1lc3RhbXAgPiBsYXRlc3RUaW1lc3RhbXApIHtcbiAgICAgICAgICAgIGxhdGVzdFRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIGxhdGVzdEJhY2t1cEtleSA9IGtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBTa2lwIGtleXMgdGhhdCBkb24ndCBoYXZlIHZhbGlkIHRpbWVzdGFtcHNcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoIWxhdGVzdEJhY2t1cEtleSkge1xuICAgICAgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcihcbiAgICAgICAgJ05vIGJhY2t1cCBmb3VuZCcsXG4gICAgICAgIFN0b3JhZ2VFcnJvclR5cGUuUkVTVE9SRV9FUlJPUlxuICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUmVzdG9yZSBmcm9tIGJhY2t1cFxuICAgIGNvbnN0IHNlcmlhbGl6ZWRCYWNrdXAgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShsYXRlc3RCYWNrdXBLZXkpO1xuICAgIGlmICghc2VyaWFsaXplZEJhY2t1cCkge1xuICAgICAgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcihcbiAgICAgICAgJ0JhY2t1cCBpcyBlbXB0eSBvciBjb3JydXB0ZWQnLFxuICAgICAgICBTdG9yYWdlRXJyb3JUeXBlLlJFU1RPUkVfRVJST1JcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGJhY2t1cCA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZEJhY2t1cCk7XG4gICAgXG4gICAgaWYgKGJhY2t1cC5kb2dQcm9maWxlcykge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU3RvcmFnZUtleS5ET0dfUFJPRklMRVMsIGJhY2t1cC5kb2dQcm9maWxlcyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChiYWNrdXAuc2F2ZWRSZWNvbW1lbmRhdGlvbnMpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFN0b3JhZ2VLZXkuU0FWRURfUkVDT01NRU5EQVRJT05TLCBiYWNrdXAuc2F2ZWRSZWNvbW1lbmRhdGlvbnMpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYmFja3VwLnVzZXJQcmVmZXJlbmNlcykge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU3RvcmFnZUtleS5VU0VSX1BSRUZFUkVOQ0VTLCBiYWNrdXAudXNlclByZWZlcmVuY2VzKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sICdyZXN0b3JlRnJvbUJhY2t1cCcsIFN0b3JhZ2VFcnJvclR5cGUuUkVTVE9SRV9FUlJPUik7XG4gIFxuICByZXR1cm4gcmVzdWx0ID09PSB0cnVlO1xufVxuXG4vKipcbiAqIFJlbW92ZSBvbGQgYmFja3Vwcywga2VlcGluZyBvbmx5IHRoZSBtb3N0IHJlY2VudCBvbmVzXG4gKiBAcGFyYW0ga2VlcENvdW50IE51bWJlciBvZiByZWNlbnQgYmFja3VwcyB0byBrZWVwIChkZWZhdWx0OiAzKVxuICogQHJldHVybnMgbnVtYmVyIG9mIGJhY2t1cHMgcmVtb3ZlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYW51cE9sZEJhY2t1cHMoa2VlcENvdW50OiBudW1iZXIgPSAzKTogbnVtYmVyIHtcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB0cnlDYXRjaFN0b3JhZ2UoKCkgPT4ge1xuICAgIGlmICghaXNTdG9yYWdlQXZhaWxhYmxlKCkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBcbiAgICAvLyBGaW5kIGFsbCBiYWNrdXBzIGFuZCB0aGVpciB0aW1lc3RhbXBzXG4gICAgY29uc3QgYmFja3VwczogeyBrZXk6IHN0cmluZzsgdGltZXN0YW1wOiBudW1iZXIgfVtdID0gW107XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG4gICAgICBpZiAoa2V5ICYmIGtleS5zdGFydHNXaXRoKFN0b3JhZ2VLZXkuQkFDS1VQX1BSRUZJWCkgJiYgIWtleS5pbmNsdWRlcyhTdG9yYWdlS2V5LkRPR19QUk9GSUxFUykgJiYgXG4gICAgICAgICAgIWtleS5pbmNsdWRlcyhTdG9yYWdlS2V5LlNBVkVEX1JFQ09NTUVOREFUSU9OUykgJiYgIWtleS5pbmNsdWRlcyhTdG9yYWdlS2V5LlVTRVJfUFJFRkVSRU5DRVMpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gcGFyc2VJbnQoa2V5LnJlcGxhY2UoU3RvcmFnZUtleS5CQUNLVVBfUFJFRklYLCAnJyksIDEwKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKHRpbWVzdGFtcCkpIHtcbiAgICAgICAgICAgIGJhY2t1cHMucHVzaCh7IGtleSwgdGltZXN0YW1wIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIFNraXAga2V5cyB0aGF0IGRvbid0IGhhdmUgdmFsaWQgdGltZXN0YW1wc1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFNvcnQgYnkgdGltZXN0YW1wIChuZXdlc3QgZmlyc3QpXG4gICAgYmFja3Vwcy5zb3J0KChhLCBiKSA9PiBiLnRpbWVzdGFtcCAtIGEudGltZXN0YW1wKTtcbiAgICBcbiAgICAvLyBSZW1vdmUgb2xkIGJhY2t1cHMga2VlcGluZyB0aGUgbW9zdCByZWNlbnQgb25lc1xuICAgIGxldCByZW1vdmVkQ291bnQgPSAwO1xuICAgIGlmIChiYWNrdXBzLmxlbmd0aCA+IGtlZXBDb3VudCkge1xuICAgICAgY29uc3QgdG9SZW1vdmUgPSBiYWNrdXBzLnNsaWNlKGtlZXBDb3VudCk7XG4gICAgICB0b1JlbW92ZS5mb3JFYWNoKGJhY2t1cCA9PiB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGJhY2t1cC5rZXkpO1xuICAgICAgICByZW1vdmVkQ291bnQrKztcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVtb3ZlZENvdW50O1xuICB9LCAnY2xlYW51cE9sZEJhY2t1cHMnKTtcbiAgXG4gIHJldHVybiByZXN1bHQgfHwgMDtcbn1cblxuLyoqXG4gKiBTYXZlIGRvZyBwcm9maWxlcyB0byBzdG9yYWdlXG4gKiBAcGFyYW0gcHJvZmlsZXMgTWFwIG9mIGRvZyBwcm9maWxlcyBieSBJRFxuICogQHBhcmFtIGFjdGl2ZVByb2ZpbGVJZCBJRCBvZiB0aGUgYWN0aXZlIHByb2ZpbGUgKG9wdGlvbmFsKVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2F2ZURvZ1Byb2ZpbGVzKFxuICBwcm9maWxlczogUmVjb3JkPHN0cmluZywgRG9nUHJvZmlsZT4sIFxuICBhY3RpdmVQcm9maWxlSWQ/OiBzdHJpbmdcbik6IHZvaWQge1xuICBjb25zdCBkYXRhOiBEb2dQcm9maWxlc1N0b3JhZ2VTY2hlbWFbJ2RhdGEnXSA9IHtcbiAgICBwcm9maWxlcyxcbiAgICBhY3RpdmVQcm9maWxlSWRcbiAgfTtcbiAgXG4gIHNhdmVUb1N0b3JhZ2U8RG9nUHJvZmlsZXNTdG9yYWdlU2NoZW1hWydkYXRhJ10+KFN0b3JhZ2VLZXkuRE9HX1BST0ZJTEVTLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBMb2FkIGRvZyBwcm9maWxlcyBmcm9tIHN0b3JhZ2VcbiAqIEByZXR1cm5zIFRoZSBzdG9yZWQgZG9nIHByb2ZpbGVzIG9yIGRlZmF1bHQgZW1wdHkgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9hZERvZ1Byb2ZpbGVzKCk6IERvZ1Byb2ZpbGVzU3RvcmFnZVNjaGVtYSB7XG4gIHJldHVybiBsb2FkRnJvbVN0b3JhZ2U8RG9nUHJvZmlsZXNTdG9yYWdlU2NoZW1hWydkYXRhJ10+KFxuICAgIFN0b3JhZ2VLZXkuRE9HX1BST0ZJTEVTLCBcbiAgICBERUZBVUxUX0RPR19QUk9GSUxFU19TVE9SQUdFXG4gICk7XG59XG5cbi8qKlxuICogU2F2ZSBzYXZlZCByZWNvbW1lbmRhdGlvbnMgdG8gc3RvcmFnZVxuICogQHBhcmFtIHJlY29tbWVuZGF0aW9ucyBNYXAgb2Ygc2F2ZWQgcmVjb21tZW5kYXRpb25zIGJ5IHByb2R1Y3QgSURcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhdmVSZWNvbW1lbmRhdGlvbnMocmVjb21tZW5kYXRpb25zOiBSZWNvcmQ8c3RyaW5nLCBGb29kUmVjb21tZW5kYXRpb24+KTogdm9pZCB7XG4gIGNvbnN0IHsgcmVzdWx0LCBlcnJvciB9ID0gdHJ5Q2F0Y2hTdG9yYWdlKCgpID0+IHtcbiAgICBjb25zdCBzYXZlZERhdGVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gICAgXG4gICAgLy8gVXBkYXRlIHRpbWVzdGFtcHMgZm9yIGFueSBuZXcgcmVjb21tZW5kYXRpb25zXG4gICAgT2JqZWN0LmtleXMocmVjb21tZW5kYXRpb25zKS5mb3JFYWNoKGlkID0+IHtcbiAgICAgIC8vIFVzZSBleGlzdGluZyB0aW1lc3RhbXAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgdXNlIGN1cnJlbnQgdGltZVxuICAgICAgc2F2ZWREYXRlc1tpZF0gPSBEYXRlLm5vdygpO1xuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IGRhdGE6IFNhdmVkUmVjb21tZW5kYXRpb25zU3RvcmFnZVNjaGVtYVsnZGF0YSddID0ge1xuICAgICAgcmVjb21tZW5kYXRpb25zLFxuICAgICAgc2F2ZWREYXRlc1xuICAgIH07XG4gICAgXG4gICAgc2F2ZVRvU3RvcmFnZTxTYXZlZFJlY29tbWVuZGF0aW9uc1N0b3JhZ2VTY2hlbWFbJ2RhdGEnXT4oU3RvcmFnZUtleS5TQVZFRF9SRUNPTU1FTkRBVElPTlMsIGRhdGEpO1xuICB9LCAnc2F2ZVJlY29tbWVuZGF0aW9ucycpO1xuICBcbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBMb2FkIHNhdmVkIHJlY29tbWVuZGF0aW9ucyBmcm9tIHN0b3JhZ2VcbiAqIEByZXR1cm5zIFRoZSBzdG9yZWQgcmVjb21tZW5kYXRpb25zIG9yIGRlZmF1bHQgZW1wdHkgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9hZFJlY29tbWVuZGF0aW9ucygpOiBTYXZlZFJlY29tbWVuZGF0aW9uc1N0b3JhZ2VTY2hlbWEge1xuICByZXR1cm4gbG9hZEZyb21TdG9yYWdlPFNhdmVkUmVjb21tZW5kYXRpb25zU3RvcmFnZVNjaGVtYVsnZGF0YSddPihcbiAgICBTdG9yYWdlS2V5LlNBVkVEX1JFQ09NTUVOREFUSU9OUywgXG4gICAgREVGQVVMVF9TQVZFRF9SRUNPTU1FTkRBVElPTlNfU1RPUkFHRVxuICApO1xufVxuXG4vKipcbiAqIEV4cG9ydCBhbGwgdXNlciBkYXRhIHRvIGEgZG93bmxvYWRhYmxlIEpTT04gZmlsZVxuICogQHJldHVybnMgSlNPTiBzdHJpbmcgb2YgYWxsIHVzZXIgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwb3J0RGF0YSgpOiBzdHJpbmcge1xuICBjb25zdCB7IHJlc3VsdCwgZXJyb3IgfSA9IHRyeUNhdGNoU3RvcmFnZSgoKSA9PiB7XG4gICAgY29uc3QgZG9nUHJvZmlsZXMgPSBsb2FkRG9nUHJvZmlsZXMoKTtcbiAgICBjb25zdCBzYXZlZFJlY29tbWVuZGF0aW9ucyA9IGxvYWRSZWNvbW1lbmRhdGlvbnMoKTtcbiAgICBjb25zdCB1c2VyUHJlZmVyZW5jZXMgPSBsb2FkRnJvbVN0b3JhZ2U8VXNlclByZWZlcmVuY2VzU3RvcmFnZVNjaGVtYVsnZGF0YSddPihcbiAgICAgIFN0b3JhZ2VLZXkuVVNFUl9QUkVGRVJFTkNFUyxcbiAgICAgIERFRkFVTFRfVVNFUl9QUkVGRVJFTkNFU19TVE9SQUdFXG4gICAgKTtcbiAgICBcbiAgICBjb25zdCBleHBvcnREYXRhID0ge1xuICAgICAgc2NoZW1hVmVyc2lvbjogU0NIRU1BX1ZFUlNJT04sXG4gICAgICBleHBvcnREYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBkb2dQcm9maWxlcyxcbiAgICAgIHNhdmVkUmVjb21tZW5kYXRpb25zLFxuICAgICAgdXNlclByZWZlcmVuY2VzXG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXhwb3J0RGF0YSwgbnVsbCwgMik7XG4gIH0sICdleHBvcnREYXRhJywgU3RvcmFnZUVycm9yVHlwZS5FWFBPUlRfRVJST1IpO1xuICBcbiAgaWYgKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbiAgXG4gIHJldHVybiByZXN1bHQgfHwgJ3t9Jztcbn1cblxuLyoqXG4gKiBJbXBvcnQgdXNlciBkYXRhIGZyb20gYSBKU09OIHN0cmluZ1xuICogQHBhcmFtIGpzb25EYXRhIEpTT04gc3RyaW5nIHdpdGggdXNlciBkYXRhXG4gKiBAcmV0dXJucyB0cnVlIGlmIGltcG9ydCBzdWNjZXNzZnVsLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGltcG9ydERhdGEoanNvbkRhdGE6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gaW1wb3J0RGF0YVdpdGhTdHJhdGVneShqc29uRGF0YSwgJ3JlcGxhY2UnKTtcbn1cblxuLyoqXG4gKiBDbGVhbnVwIG9sZCBvciB1bnVzZWQgZGF0YSBmcm9tIHN0b3JhZ2UgYmFzZWQgb24gYWdlIHRocmVzaG9sZFxuICogQHBhcmFtIG9sZGVyVGhhbkRheXMgTnVtYmVyIG9mIGRheXMgYWZ0ZXIgd2hpY2ggZGF0YSBpcyBjb25zaWRlcmVkIG9sZCAoZGVmYXVsdDogOTApXG4gKiBAcmV0dXJucyBPYmplY3Qgd2l0aCBjb3VudHMgb2YgaXRlbXMgY2xlYW5lZCB1cCBieSBjYXRlZ29yeVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYW51cFN0b3JhZ2Uob2xkZXJUaGFuRGF5czogbnVtYmVyID0gOTApOiB7IFxuICByZWNvbW1lbmRhdGlvbnM6IG51bWJlcjsgXG4gIG9sZEJhY2t1cHM6IG51bWJlcjtcbiAgdG90YWw6IG51bWJlcjtcbn0ge1xuICBjb25zdCB7IHJlc3VsdCwgZXJyb3IgfSA9IHRyeUNhdGNoU3RvcmFnZSgoKSA9PiB7XG4gICAgaWYgKCFpc1N0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgICAgcmV0dXJuIHsgcmVjb21tZW5kYXRpb25zOiAwLCBvbGRCYWNrdXBzOiAwLCB0b3RhbDogMCB9O1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGFnZVRocmVzaG9sZCA9IG5vdyAtIChvbGRlclRoYW5EYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCk7IC8vIENvbnZlcnQgZGF5cyB0byBtaWxsaXNlY29uZHNcbiAgICBsZXQgcmVtb3ZlZFJlY29tbWVuZGF0aW9ucyA9IDA7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgb2xkIHNhdmVkIHJlY29tbWVuZGF0aW9uc1xuICAgIGNvbnN0IHNhdmVkUmVjb21tZW5kYXRpb25zID0gbG9hZFJlY29tbWVuZGF0aW9ucygpO1xuICAgIGlmIChzYXZlZFJlY29tbWVuZGF0aW9ucz8uZGF0YT8ucmVjb21tZW5kYXRpb25zICYmIHNhdmVkUmVjb21tZW5kYXRpb25zPy5kYXRhPy5zYXZlZERhdGVzKSB7XG4gICAgICBjb25zdCB7IHJlY29tbWVuZGF0aW9ucywgc2F2ZWREYXRlcyB9ID0gc2F2ZWRSZWNvbW1lbmRhdGlvbnMuZGF0YTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRSZWNvbW1lbmRhdGlvbnM6IFJlY29yZDxzdHJpbmcsIEZvb2RSZWNvbW1lbmRhdGlvbj4gPSB7fTtcbiAgICAgIGNvbnN0IHVwZGF0ZWRTYXZlZERhdGVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+ID0ge307XG4gICAgICBcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJlY29tbWVuZGF0aW9ucykuZm9yRWFjaCgoW2lkLCByZWNvbW1lbmRhdGlvbl0pID0+IHtcbiAgICAgICAgY29uc3Qgc2F2ZWREYXRlID0gc2F2ZWREYXRlc1tpZF0gfHwgMDtcbiAgICAgICAgXG4gICAgICAgIC8vIEtlZXAgcmVjb21tZW5kYXRpb25zIG5ld2VyIHRoYW4gdGhlIHRocmVzaG9sZFxuICAgICAgICBpZiAoc2F2ZWREYXRlID4gYWdlVGhyZXNob2xkKSB7XG4gICAgICAgICAgdXBkYXRlZFJlY29tbWVuZGF0aW9uc1tpZF0gPSByZWNvbW1lbmRhdGlvbjtcbiAgICAgICAgICB1cGRhdGVkU2F2ZWREYXRlc1tpZF0gPSBzYXZlZERhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlZFJlY29tbWVuZGF0aW9ucysrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gT25seSBzYXZlIGlmIHdlIHJlbW92ZWQgYW55IHJlY29tbWVuZGF0aW9uc1xuICAgICAgaWYgKHJlbW92ZWRSZWNvbW1lbmRhdGlvbnMgPiAwKSB7XG4gICAgICAgIHNhdmVUb1N0b3JhZ2UoU3RvcmFnZUtleS5TQVZFRF9SRUNPTU1FTkRBVElPTlMsIHtcbiAgICAgICAgICByZWNvbW1lbmRhdGlvbnM6IHVwZGF0ZWRSZWNvbW1lbmRhdGlvbnMsXG4gICAgICAgICAgc2F2ZWREYXRlczogdXBkYXRlZFNhdmVkRGF0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFuIHVwIG9sZCBiYWNrdXBzXG4gICAgY29uc3Qgb2xkQmFja3VwcyA9IGNsZWFudXBPbGRCYWNrdXBzKDMpOyAvLyBLZWVwIDMgbW9zdCByZWNlbnQgYmFja3Vwc1xuICAgIFxuICAgIGNvbnN0IHRvdGFsUmVtb3ZlZCA9IHJlbW92ZWRSZWNvbW1lbmRhdGlvbnMgKyBvbGRCYWNrdXBzO1xuICAgIFxuICAgIHJldHVybiB7IFxuICAgICAgcmVjb21tZW5kYXRpb25zOiByZW1vdmVkUmVjb21tZW5kYXRpb25zLCBcbiAgICAgIG9sZEJhY2t1cHMsIFxuICAgICAgdG90YWw6IHRvdGFsUmVtb3ZlZCBcbiAgICB9O1xuICB9LCAnY2xlYW51cFN0b3JhZ2UnLCBTdG9yYWdlRXJyb3JUeXBlLkNMRUFOVVBfRVJST1IpO1xuICBcbiAgcmV0dXJuIHJlc3VsdCB8fCB7IHJlY29tbWVuZGF0aW9uczogMCwgb2xkQmFja3VwczogMCwgdG90YWw6IDAgfTtcbn1cblxuLyoqXG4gKiBEb3dubG9hZCBleHBvcnRlZCBkYXRhIGFzIGEgSlNPTiBmaWxlXG4gKiBAcGFyYW0gZmlsZW5hbWUgQ3VzdG9tIGZpbGVuYW1lIChkZWZhdWx0OiAncGV0Zm9vZC1kYXRhLWV4cG9ydC5qc29uJylcbiAqIEByZXR1cm5zIHRydWUgaWYgZG93bmxvYWQgaW5pdGlhdGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3dubG9hZEV4cG9ydGVkRGF0YShmaWxlbmFtZTogc3RyaW5nID0gJ3BldGZvb2QtZGF0YS1leHBvcnQuanNvbicpOiBib29sZWFuIHtcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB0cnlDYXRjaFN0b3JhZ2UoKCkgPT4ge1xuICAgIGNvbnN0IGV4cG9ydFN0cmluZyA9IGV4cG9ydERhdGEoKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBCbG9iIHdpdGggdGhlIGRhdGFcbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2V4cG9ydFN0cmluZ10sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nIH0pO1xuICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGxpbmsgYW5kIHRyaWdnZXIgZG93bmxvYWRcbiAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGxpbmsuaHJlZiA9IHVybDtcbiAgICBsaW5rLmRvd25sb2FkID0gZmlsZW5hbWU7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICBsaW5rLmNsaWNrKCk7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXBcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgfSwgMTAwKTtcbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgJ2Rvd25sb2FkRXhwb3J0ZWREYXRhJywgU3RvcmFnZUVycm9yVHlwZS5FWFBPUlRfRVJST1IpO1xuICBcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBJbXBvcnQgZGF0YSBmcm9tIGFuIHVwbG9hZGVkIGZpbGVcbiAqIEBwYXJhbSBmaWxlIFRoZSB1cGxvYWRlZCBGaWxlIG9iamVjdFxuICogQHBhcmFtIG1lcmdlU3RyYXRlZ3kgSG93IHRvIGhhbmRsZSBleGlzdGluZyBkYXRhICgncmVwbGFjZScsICdtZXJnZScsICdrZWVwLW5ld2VyJylcbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRydWUgaWYgaW1wb3J0IHN1Y2Nlc3NmdWwsIGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW1wb3J0RGF0YUZyb21GaWxlKFxuICBmaWxlOiBGaWxlLCBcbiAgbWVyZ2VTdHJhdGVneTogJ3JlcGxhY2UnIHwgJ21lcmdlJyB8ICdrZWVwLW5ld2VyJyA9ICdyZXBsYWNlJ1xuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgXG4gICAgcmVhZGVyLm9ubG9hZCA9IChldmVudCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QganNvbkRhdGEgPSBldmVudC50YXJnZXQ/LnJlc3VsdCBhcyBzdHJpbmc7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBpbXBvcnREYXRhV2l0aFN0cmF0ZWd5KGpzb25EYXRhLCBtZXJnZVN0cmF0ZWd5KTtcbiAgICAgICAgcmVzb2x2ZShzdWNjZXNzKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGltcG9ydGluZyBkYXRhIGZyb20gZmlsZTonLCBlcnJvcik7XG4gICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgcmVhZGVyLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWFkaW5nIGZpbGUnKTtcbiAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgIH07XG4gICAgXG4gICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEltcG9ydCBkYXRhIHdpdGggdGhlIHNwZWNpZmllZCBtZXJnZSBzdHJhdGVneVxuICogQHBhcmFtIGpzb25EYXRhIEpTT04gc3RyaW5nIHdpdGggdXNlciBkYXRhXG4gKiBAcGFyYW0gbWVyZ2VTdHJhdGVneSBIb3cgdG8gaGFuZGxlIGV4aXN0aW5nIGRhdGEgKCdyZXBsYWNlJywgJ21lcmdlJywgJ2tlZXAtbmV3ZXInKVxuICogQHJldHVybnMgdHJ1ZSBpZiBpbXBvcnQgc3VjY2Vzc2Z1bCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbXBvcnREYXRhV2l0aFN0cmF0ZWd5KFxuICBqc29uRGF0YTogc3RyaW5nLCBcbiAgbWVyZ2VTdHJhdGVneTogJ3JlcGxhY2UnIHwgJ21lcmdlJyB8ICdrZWVwLW5ld2VyJyA9ICdyZXBsYWNlJ1xuKTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgcmVzdWx0LCBlcnJvciB9ID0gdHJ5Q2F0Y2hTdG9yYWdlKCgpID0+IHtcbiAgICBjb25zdCBpbXBvcnRlZERhdGEgPSBKU09OLnBhcnNlKGpzb25EYXRhKTtcbiAgICBcbiAgICAvLyBWYWxpZGF0ZSBpbXBvcnRlZCBkYXRhXG4gICAgaWYgKCFpbXBvcnRlZERhdGEuc2NoZW1hVmVyc2lvbiB8fCAhaW1wb3J0ZWREYXRhLmV4cG9ydERhdGUpIHtcbiAgICAgIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIGV4cG9ydCBkYXRhIGZvcm1hdCcsXG4gICAgICAgIFN0b3JhZ2VFcnJvclR5cGUuSU1QT1JUX0VSUk9SXG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhdGUgYmFja3VwIGJlZm9yZSBtYWtpbmcgYW55IGNoYW5nZXNcbiAgICBjcmVhdGVCYWNrdXAoKTtcbiAgICBcbiAgICAvLyBIYW5kbGUgZG9nIHByb2ZpbGVzIGJhc2VkIG9uIG1lcmdlIHN0cmF0ZWd5XG4gICAgaWYgKGltcG9ydGVkRGF0YS5kb2dQcm9maWxlcz8uZGF0YT8ucHJvZmlsZXMpIHtcbiAgICAgIGlmIChtZXJnZVN0cmF0ZWd5ID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgLy8gU2ltcGx5IHJlcGxhY2UgZXhpc3RpbmcgZGF0YVxuICAgICAgICBzYXZlVG9TdG9yYWdlKFN0b3JhZ2VLZXkuRE9HX1BST0ZJTEVTLCBpbXBvcnRlZERhdGEuZG9nUHJvZmlsZXMuZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNZXJnZSBvciBrZWVwLW5ld2VyIHN0cmF0ZWdpZXNcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQcm9maWxlcyA9IGxvYWREb2dQcm9maWxlcygpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGV4aXN0aW5nUHJvZmlsZXM/LmRhdGE/LnByb2ZpbGVzKSB7XG4gICAgICAgICAgY29uc3QgbWVyZ2VkUHJvZmlsZXMgPSB7IC4uLmV4aXN0aW5nUHJvZmlsZXMuZGF0YSB9O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFByb2Nlc3MgZWFjaCBpbXBvcnRlZCBwcm9maWxlXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoaW1wb3J0ZWREYXRhLmRvZ1Byb2ZpbGVzLmRhdGEucHJvZmlsZXMpLmZvckVhY2goKFtpZCwgcHJvZmlsZV0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUHJvZmlsZSA9IG1lcmdlZFByb2ZpbGVzLnByb2ZpbGVzW2lkXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFleGlzdGluZ1Byb2ZpbGUpIHtcbiAgICAgICAgICAgICAgLy8gUHJvZmlsZSBkb2Vzbid0IGV4aXN0IGluIGN1cnJlbnQgZGF0YSwgYWRkIGl0XG4gICAgICAgICAgICAgIG1lcmdlZFByb2ZpbGVzLnByb2ZpbGVzW2lkXSA9IHByb2ZpbGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmdlU3RyYXRlZ3kgPT09ICdrZWVwLW5ld2VyJykge1xuICAgICAgICAgICAgICAvLyBDb21wYXJlIHVwZGF0ZSB0aW1lc3RhbXBzIGFuZCBrZWVwIG5ld2VyXG4gICAgICAgICAgICAgIGNvbnN0IGltcG9ydGVkVGltZXN0YW1wID0gaW1wb3J0ZWREYXRhLmRvZ1Byb2ZpbGVzLnVwZGF0ZWRBdCB8fCAwO1xuICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1RpbWVzdGFtcCA9IGV4aXN0aW5nUHJvZmlsZXMudXBkYXRlZEF0IHx8IDA7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoaW1wb3J0ZWRUaW1lc3RhbXAgPiBleGlzdGluZ1RpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIG1lcmdlZFByb2ZpbGVzLnByb2ZpbGVzW2lkXSA9IHByb2ZpbGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEZvciAnbWVyZ2UnIHN0cmF0ZWd5LCBhbHdheXMgdXBkYXRlXG4gICAgICAgICAgICAgIG1lcmdlZFByb2ZpbGVzLnByb2ZpbGVzW2lkXSA9IHByb2ZpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2F2ZSBtZXJnZWQgcHJvZmlsZXNcbiAgICAgICAgICBzYXZlVG9TdG9yYWdlKFN0b3JhZ2VLZXkuRE9HX1BST0ZJTEVTLCBtZXJnZWRQcm9maWxlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gZXhpc3RpbmcgcHJvZmlsZXMsIGp1c3QgaW1wb3J0XG4gICAgICAgICAgc2F2ZVRvU3RvcmFnZShTdG9yYWdlS2V5LkRPR19QUk9GSUxFUywgaW1wb3J0ZWREYXRhLmRvZ1Byb2ZpbGVzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSByZWNvbW1lbmRhdGlvbnMgd2l0aCBzaW1pbGFyIG1lcmdlIHN0cmF0ZWd5XG4gICAgaWYgKGltcG9ydGVkRGF0YS5zYXZlZFJlY29tbWVuZGF0aW9ucz8uZGF0YT8ucmVjb21tZW5kYXRpb25zKSB7XG4gICAgICBpZiAobWVyZ2VTdHJhdGVneSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgIHNhdmVUb1N0b3JhZ2UoU3RvcmFnZUtleS5TQVZFRF9SRUNPTU1FTkRBVElPTlMsIGltcG9ydGVkRGF0YS5zYXZlZFJlY29tbWVuZGF0aW9ucy5kYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUmVjb21tZW5kYXRpb25zID0gbG9hZFJlY29tbWVuZGF0aW9ucygpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGV4aXN0aW5nUmVjb21tZW5kYXRpb25zPy5kYXRhPy5yZWNvbW1lbmRhdGlvbnMpIHtcbiAgICAgICAgICBjb25zdCBtZXJnZWRSZWNvbW1lbmRhdGlvbnMgPSB7IFxuICAgICAgICAgICAgcmVjb21tZW5kYXRpb25zOiB7IC4uLmV4aXN0aW5nUmVjb21tZW5kYXRpb25zLmRhdGEucmVjb21tZW5kYXRpb25zIH0sXG4gICAgICAgICAgICBzYXZlZERhdGVzOiB7IC4uLmV4aXN0aW5nUmVjb21tZW5kYXRpb25zLmRhdGEuc2F2ZWREYXRlcyB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBQcm9jZXNzIGVhY2ggaW1wb3J0ZWQgcmVjb21tZW5kYXRpb25cbiAgICAgICAgICBPYmplY3QuZW50cmllcyhpbXBvcnRlZERhdGEuc2F2ZWRSZWNvbW1lbmRhdGlvbnMuZGF0YS5yZWNvbW1lbmRhdGlvbnMpLmZvckVhY2goKFtpZCwgcmVjb21tZW5kYXRpb25dKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1JlY29tbWVuZGF0aW9uID0gbWVyZ2VkUmVjb21tZW5kYXRpb25zLnJlY29tbWVuZGF0aW9uc1tpZF07XG4gICAgICAgICAgICBjb25zdCBpbXBvcnRlZFNhdmVkRGF0ZSA9IGltcG9ydGVkRGF0YS5zYXZlZFJlY29tbWVuZGF0aW9ucy5kYXRhLnNhdmVkRGF0ZXM/LltpZF0gfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU2F2ZWREYXRlID0gbWVyZ2VkUmVjb21tZW5kYXRpb25zLnNhdmVkRGF0ZXNbaWRdIHx8IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdSZWNvbW1lbmRhdGlvbikge1xuICAgICAgICAgICAgICAvLyBSZWNvbW1lbmRhdGlvbiBkb2Vzbid0IGV4aXN0LCBhZGQgaXRcbiAgICAgICAgICAgICAgbWVyZ2VkUmVjb21tZW5kYXRpb25zLnJlY29tbWVuZGF0aW9uc1tpZF0gPSByZWNvbW1lbmRhdGlvbjtcbiAgICAgICAgICAgICAgbWVyZ2VkUmVjb21tZW5kYXRpb25zLnNhdmVkRGF0ZXNbaWRdID0gaW1wb3J0ZWRTYXZlZERhdGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmdlU3RyYXRlZ3kgPT09ICdrZWVwLW5ld2VyJyAmJiBpbXBvcnRlZFNhdmVkRGF0ZSA+IGV4aXN0aW5nU2F2ZWREYXRlKSB7XG4gICAgICAgICAgICAgIC8vICdrZWVwLW5ld2VyJyBzdHJhdGVneSAtIHVwZGF0ZSBpZiBpbXBvcnRlZCBpcyBuZXdlclxuICAgICAgICAgICAgICBtZXJnZWRSZWNvbW1lbmRhdGlvbnMucmVjb21tZW5kYXRpb25zW2lkXSA9IHJlY29tbWVuZGF0aW9uO1xuICAgICAgICAgICAgICBtZXJnZWRSZWNvbW1lbmRhdGlvbnMuc2F2ZWREYXRlc1tpZF0gPSBpbXBvcnRlZFNhdmVkRGF0ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyZ2VTdHJhdGVneSA9PT0gJ21lcmdlJykge1xuICAgICAgICAgICAgICAvLyAnbWVyZ2UnIHN0cmF0ZWd5IC0gYWx3YXlzIHVwZGF0ZVxuICAgICAgICAgICAgICBtZXJnZWRSZWNvbW1lbmRhdGlvbnMucmVjb21tZW5kYXRpb25zW2lkXSA9IHJlY29tbWVuZGF0aW9uO1xuICAgICAgICAgICAgICBtZXJnZWRSZWNvbW1lbmRhdGlvbnMuc2F2ZWREYXRlc1tpZF0gPSBpbXBvcnRlZFNhdmVkRGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTYXZlIG1lcmdlZCByZWNvbW1lbmRhdGlvbnNcbiAgICAgICAgICBzYXZlVG9TdG9yYWdlKFN0b3JhZ2VLZXkuU0FWRURfUkVDT01NRU5EQVRJT05TLCBtZXJnZWRSZWNvbW1lbmRhdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGV4aXN0aW5nIHJlY29tbWVuZGF0aW9ucywganVzdCBpbXBvcnRcbiAgICAgICAgICBzYXZlVG9TdG9yYWdlKFN0b3JhZ2VLZXkuU0FWRURfUkVDT01NRU5EQVRJT05TLCBpbXBvcnRlZERhdGEuc2F2ZWRSZWNvbW1lbmRhdGlvbnMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIHVzZXIgcHJlZmVyZW5jZXNcbiAgICBpZiAoaW1wb3J0ZWREYXRhLnVzZXJQcmVmZXJlbmNlcz8uZGF0YSkge1xuICAgICAgaWYgKG1lcmdlU3RyYXRlZ3kgPT09ICdyZXBsYWNlJykge1xuICAgICAgICBzYXZlVG9TdG9yYWdlKFN0b3JhZ2VLZXkuVVNFUl9QUkVGRVJFTkNFUywgaW1wb3J0ZWREYXRhLnVzZXJQcmVmZXJlbmNlcy5kYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUHJlZmVyZW5jZXMgPSBsb2FkRnJvbVN0b3JhZ2U8VXNlclByZWZlcmVuY2VzU3RvcmFnZVNjaGVtYVsnZGF0YSddPihcbiAgICAgICAgICBTdG9yYWdlS2V5LlVTRVJfUFJFRkVSRU5DRVMsXG4gICAgICAgICAgREVGQVVMVF9VU0VSX1BSRUZFUkVOQ0VTX1NUT1JBR0VcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChleGlzdGluZ1ByZWZlcmVuY2VzPy5kYXRhKSB7XG4gICAgICAgICAgaWYgKG1lcmdlU3RyYXRlZ3kgPT09ICdrZWVwLW5ld2VyJykge1xuICAgICAgICAgICAgY29uc3QgaW1wb3J0ZWRUaW1lc3RhbXAgPSBpbXBvcnRlZERhdGEudXNlclByZWZlcmVuY2VzLnVwZGF0ZWRBdCB8fCAwO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUaW1lc3RhbXAgPSBleGlzdGluZ1ByZWZlcmVuY2VzLnVwZGF0ZWRBdCB8fCAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaW1wb3J0ZWRUaW1lc3RhbXAgPiBleGlzdGluZ1RpbWVzdGFtcCkge1xuICAgICAgICAgICAgICBzYXZlVG9TdG9yYWdlKFN0b3JhZ2VLZXkuVVNFUl9QUkVGRVJFTkNFUywgaW1wb3J0ZWREYXRhLnVzZXJQcmVmZXJlbmNlcy5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yICdtZXJnZScgc3RyYXRlZ3ksIG1lcmdlIG9iamVjdHNcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZFByZWZlcmVuY2VzID0ge1xuICAgICAgICAgICAgICAuLi5leGlzdGluZ1ByZWZlcmVuY2VzLmRhdGEsXG4gICAgICAgICAgICAgIC4uLmltcG9ydGVkRGF0YS51c2VyUHJlZmVyZW5jZXMuZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNhdmVUb1N0b3JhZ2UoU3RvcmFnZUtleS5VU0VSX1BSRUZFUkVOQ0VTLCBtZXJnZWRQcmVmZXJlbmNlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGV4aXN0aW5nIHByZWZlcmVuY2VzLCBqdXN0IGltcG9ydFxuICAgICAgICAgIHNhdmVUb1N0b3JhZ2UoU3RvcmFnZUtleS5VU0VSX1BSRUZFUkVOQ0VTLCBpbXBvcnRlZERhdGEudXNlclByZWZlcmVuY2VzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9LCAnaW1wb3J0RGF0YVdpdGhTdHJhdGVneScsIFN0b3JhZ2VFcnJvclR5cGUuSU1QT1JUX0VSUk9SKTtcbiAgXG4gIHJldHVybiByZXN1bHQgPT09IHRydWU7XG59XG5cbi8qKlxuICogR2V0IHN0YXRpc3RpY3MgYWJvdXQgc3RvcmFnZSB1c2FnZSBhbmQgaXRlbSBjb3VudHNcbiAqIEByZXR1cm5zIE9iamVjdCB3aXRoIHN0b3JhZ2UgdXNhZ2Ugc3RhdGlzdGljc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcmFnZVN0YXRzKCk6IHtcbiAgdXNhZ2U6IHsgdXNlZDogbnVtYmVyOyBhdmFpbGFibGU/OiBudW1iZXI7IHBlcmNlbnRVc2VkPzogbnVtYmVyIH07XG4gIGNvdW50czogeyBkb2dQcm9maWxlczogbnVtYmVyOyBzYXZlZFJlY29tbWVuZGF0aW9uczogbnVtYmVyOyBiYWNrdXBzOiBudW1iZXIgfTtcbiAgbGFzdFVwZGF0ZWQ6IHsgZG9nUHJvZmlsZXM/OiBudW1iZXI7IHNhdmVkUmVjb21tZW5kYXRpb25zPzogbnVtYmVyOyBiYWNrdXBzPzogbnVtYmVyIH07XG59IHtcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB0cnlDYXRjaFN0b3JhZ2UoKCkgPT4ge1xuICAgIC8vIEdldCBzdG9yYWdlIHVzYWdlXG4gICAgY29uc3QgdXNhZ2UgPSBnZXRTdG9yYWdlVXNhZ2UoKTtcbiAgICBcbiAgICAvLyBDb3VudCBpdGVtc1xuICAgIGNvbnN0IGRvZ1Byb2ZpbGVzID0gbG9hZERvZ1Byb2ZpbGVzKCk7XG4gICAgY29uc3Qgc2F2ZWRSZWNvbW1lbmRhdGlvbnMgPSBsb2FkUmVjb21tZW5kYXRpb25zKCk7XG4gICAgXG4gICAgLy8gQ291bnQgYmFja3Vwc1xuICAgIGxldCBiYWNrdXBDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG4gICAgICBpZiAoa2V5ICYmIGtleS5zdGFydHNXaXRoKFN0b3JhZ2VLZXkuQkFDS1VQX1BSRUZJWCkgJiYgIWtleS5pbmNsdWRlcyhTdG9yYWdlS2V5LkRPR19QUk9GSUxFUykgJiYgXG4gICAgICAgICAgIWtleS5pbmNsdWRlcyhTdG9yYWdlS2V5LlNBVkVEX1JFQ09NTUVOREFUSU9OUykgJiYgIWtleS5pbmNsdWRlcyhTdG9yYWdlS2V5LlVTRVJfUFJFRkVSRU5DRVMpKSB7XG4gICAgICAgIGJhY2t1cENvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEdldCBwcm9maWxlIGFuZCByZWNvbW1lbmRhdGlvbiBjb3VudHNcbiAgICBjb25zdCBwcm9maWxlQ291bnQgPSBkb2dQcm9maWxlcz8uZGF0YT8ucHJvZmlsZXMgPyBPYmplY3Qua2V5cyhkb2dQcm9maWxlcy5kYXRhLnByb2ZpbGVzKS5sZW5ndGggOiAwO1xuICAgIGNvbnN0IHJlY29tbWVuZGF0aW9uQ291bnQgPSBzYXZlZFJlY29tbWVuZGF0aW9ucz8uZGF0YT8ucmVjb21tZW5kYXRpb25zIFxuICAgICAgPyBPYmplY3Qua2V5cyhzYXZlZFJlY29tbWVuZGF0aW9ucy5kYXRhLnJlY29tbWVuZGF0aW9ucykubGVuZ3RoIFxuICAgICAgOiAwO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB1c2FnZSxcbiAgICAgIGNvdW50czoge1xuICAgICAgICBkb2dQcm9maWxlczogcHJvZmlsZUNvdW50LFxuICAgICAgICBzYXZlZFJlY29tbWVuZGF0aW9uczogcmVjb21tZW5kYXRpb25Db3VudCxcbiAgICAgICAgYmFja3VwczogYmFja3VwQ291bnRcbiAgICAgIH0sXG4gICAgICBsYXN0VXBkYXRlZDoge1xuICAgICAgICBkb2dQcm9maWxlczogZG9nUHJvZmlsZXM/LnVwZGF0ZWRBdCxcbiAgICAgICAgc2F2ZWRSZWNvbW1lbmRhdGlvbnM6IHNhdmVkUmVjb21tZW5kYXRpb25zPy51cGRhdGVkQXQsXG4gICAgICAgIGJhY2t1cHM6IGdldExhdGVzdEJhY2t1cFRpbWVzdGFtcCgpXG4gICAgICB9XG4gICAgfTtcbiAgfSwgJ2dldFN0b3JhZ2VTdGF0cycpO1xuICBcbiAgcmV0dXJuIHJlc3VsdCB8fCB7XG4gICAgdXNhZ2U6IHsgdXNlZDogMCB9LFxuICAgIGNvdW50czogeyBkb2dQcm9maWxlczogMCwgc2F2ZWRSZWNvbW1lbmRhdGlvbnM6IDAsIGJhY2t1cHM6IDAgfSxcbiAgICBsYXN0VXBkYXRlZDoge31cbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbW9zdCByZWNlbnQgYmFja3VwXG4gKiBAcmV0dXJucyBUaW1lc3RhbXAgb2YgdGhlIG1vc3QgcmVjZW50IGJhY2t1cCwgb3IgdW5kZWZpbmVkIGlmIG5vbmUgZXhpc3RzXG4gKi9cbmZ1bmN0aW9uIGdldExhdGVzdEJhY2t1cFRpbWVzdGFtcCgpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBjb25zdCB7IHJlc3VsdCB9ID0gdHJ5Q2F0Y2hTdG9yYWdlKCgpID0+IHtcbiAgICBsZXQgbGF0ZXN0VGltZXN0YW1wOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG4gICAgICBpZiAoa2V5ICYmIGtleS5zdGFydHNXaXRoKFN0b3JhZ2VLZXkuQkFDS1VQX1BSRUZJWCkgJiYgIWtleS5pbmNsdWRlcyhTdG9yYWdlS2V5LkRPR19QUk9GSUxFUykgJiYgXG4gICAgICAgICAgIWtleS5pbmNsdWRlcyhTdG9yYWdlS2V5LlNBVkVEX1JFQ09NTUVOREFUSU9OUykgJiYgIWtleS5pbmNsdWRlcyhTdG9yYWdlS2V5LlVTRVJfUFJFRkVSRU5DRVMpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gcGFyc2VJbnQoa2V5LnJlcGxhY2UoU3RvcmFnZUtleS5CQUNLVVBfUFJFRklYLCAnJyksIDEwKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKHRpbWVzdGFtcCkgJiYgKCFsYXRlc3RUaW1lc3RhbXAgfHwgdGltZXN0YW1wID4gbGF0ZXN0VGltZXN0YW1wKSkge1xuICAgICAgICAgICAgbGF0ZXN0VGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBsYXRlc3RUaW1lc3RhbXA7XG4gIH0sICdnZXRMYXRlc3RCYWNrdXBUaW1lc3RhbXAnKTtcbiAgXG4gIHJldHVybiByZXN1bHQ7XG59ICJdLCJuYW1lcyI6WyJTQ0hFTUFfVkVSU0lPTiIsIlN0b3JhZ2VLZXkiLCJERUZBVUxUX0RPR19QUk9GSUxFU19TVE9SQUdFIiwiREVGQVVMVF9TQVZFRF9SRUNPTU1FTkRBVElPTlNfU1RPUkFHRSIsIkRFRkFVTFRfVVNFUl9QUkVGRVJFTkNFU19TVE9SQUdFIiwiU3RvcmFnZUVycm9yIiwiU3RvcmFnZUVycm9yVHlwZSIsImhhbmRsZVN0b3JhZ2VFcnJvciIsInRyeUNhdGNoU3RvcmFnZSIsImlzU3RvcmFnZUF2YWlsYWJsZSIsInRlc3RLZXkiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwicmVzdWx0IiwiZ2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJlIiwiZ2V0U3RvcmFnZVVzYWdlIiwiZXJyb3IiLCJ0b3RhbFNpemUiLCJpIiwibGVuZ3RoIiwia2V5IiwidmFsdWUiLCJ1c2VkQnl0ZXMiLCJlc3RpbWF0ZWRMaW1pdCIsInVzZWQiLCJhdmFpbGFibGUiLCJwZXJjZW50VXNlZCIsImlzU3RvcmFnZU5lYXJseUZ1bGwiLCJ0aHJlc2hvbGRQZXJjZW50IiwidXNhZ2UiLCJzYXZlVG9TdG9yYWdlIiwiZGF0YSIsIlNUT1JBR0VfVU5BVkFJTEFCTEUiLCJjb25zb2xlIiwid2FybiIsInN0b3JhZ2VEYXRhIiwidmVyc2lvbiIsInVwZGF0ZWRBdCIsIkRhdGUiLCJub3ciLCJKU09OIiwic3RyaW5naWZ5IiwiRXJyb3IiLCJuYW1lIiwiU1RPUkFHRV9RVU9UQV9FWENFRURFRCIsIm9yaWdpbmFsRXJyb3IiLCJXUklURV9FUlJPUiIsImxvYWRGcm9tU3RvcmFnZSIsImRlZmF1bHRWYWx1ZSIsInNlcmlhbGl6ZWQiLCJwYXJzZWREYXRhIiwicGFyc2UiLCJiYWNrdXBSZXN1bHQiLCJ0cnlSZXN0b3JlSXRlbUZyb21CYWNrdXAiLCJzdWNjZXNzIiwicGFyc2VkQmFja3VwIiwiYmFja3VwS2V5IiwiQkFDS1VQX1BSRUZJWCIsImJhY2t1cERhdGEiLCJjcmVhdGVCYWNrdXAiLCJ0aW1lc3RhbXAiLCJiYWNrdXAiLCJkb2dQcm9maWxlcyIsIkRPR19QUk9GSUxFUyIsInNhdmVkUmVjb21tZW5kYXRpb25zIiwiU0FWRURfUkVDT01NRU5EQVRJT05TIiwidXNlclByZWZlcmVuY2VzIiwiVVNFUl9QUkVGRVJFTkNFUyIsIkJBQ0tVUF9FUlJPUiIsInJlc3RvcmVGcm9tQmFja3VwIiwibGF0ZXN0QmFja3VwS2V5IiwibGF0ZXN0VGltZXN0YW1wIiwic3RhcnRzV2l0aCIsImluY2x1ZGVzIiwicGFyc2VJbnQiLCJyZXBsYWNlIiwiaXNOYU4iLCJSRVNUT1JFX0VSUk9SIiwic2VyaWFsaXplZEJhY2t1cCIsImNsZWFudXBPbGRCYWNrdXBzIiwia2VlcENvdW50IiwiYmFja3VwcyIsInB1c2giLCJzb3J0IiwiYSIsImIiLCJyZW1vdmVkQ291bnQiLCJ0b1JlbW92ZSIsInNsaWNlIiwiZm9yRWFjaCIsInNhdmVEb2dQcm9maWxlcyIsInByb2ZpbGVzIiwiYWN0aXZlUHJvZmlsZUlkIiwibG9hZERvZ1Byb2ZpbGVzIiwic2F2ZVJlY29tbWVuZGF0aW9ucyIsInJlY29tbWVuZGF0aW9ucyIsInNhdmVkRGF0ZXMiLCJPYmplY3QiLCJrZXlzIiwiaWQiLCJsb2FkUmVjb21tZW5kYXRpb25zIiwiZXhwb3J0RGF0YSIsInNjaGVtYVZlcnNpb24iLCJleHBvcnREYXRlIiwidG9JU09TdHJpbmciLCJFWFBPUlRfRVJST1IiLCJpbXBvcnREYXRhIiwianNvbkRhdGEiLCJpbXBvcnREYXRhV2l0aFN0cmF0ZWd5IiwiY2xlYW51cFN0b3JhZ2UiLCJvbGRlclRoYW5EYXlzIiwib2xkQmFja3VwcyIsInRvdGFsIiwiYWdlVGhyZXNob2xkIiwicmVtb3ZlZFJlY29tbWVuZGF0aW9ucyIsInVwZGF0ZWRSZWNvbW1lbmRhdGlvbnMiLCJ1cGRhdGVkU2F2ZWREYXRlcyIsImVudHJpZXMiLCJyZWNvbW1lbmRhdGlvbiIsInNhdmVkRGF0ZSIsInRvdGFsUmVtb3ZlZCIsIkNMRUFOVVBfRVJST1IiLCJkb3dubG9hZEV4cG9ydGVkRGF0YSIsImZpbGVuYW1lIiwiZXhwb3J0U3RyaW5nIiwiYmxvYiIsIkJsb2IiLCJ0eXBlIiwidXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwibGluayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImhyZWYiLCJkb3dubG9hZCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNsaWNrIiwic2V0VGltZW91dCIsInJldm9rZU9iamVjdFVSTCIsInJlbW92ZUNoaWxkIiwiaW1wb3J0RGF0YUZyb21GaWxlIiwiZmlsZSIsIm1lcmdlU3RyYXRlZ3kiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJldmVudCIsInRhcmdldCIsIm9uZXJyb3IiLCJyZWFkQXNUZXh0IiwiaW1wb3J0ZWREYXRhIiwiSU1QT1JUX0VSUk9SIiwiZXhpc3RpbmdQcm9maWxlcyIsIm1lcmdlZFByb2ZpbGVzIiwicHJvZmlsZSIsImV4aXN0aW5nUHJvZmlsZSIsImltcG9ydGVkVGltZXN0YW1wIiwiZXhpc3RpbmdUaW1lc3RhbXAiLCJleGlzdGluZ1JlY29tbWVuZGF0aW9ucyIsIm1lcmdlZFJlY29tbWVuZGF0aW9ucyIsImV4aXN0aW5nUmVjb21tZW5kYXRpb24iLCJpbXBvcnRlZFNhdmVkRGF0ZSIsImV4aXN0aW5nU2F2ZWREYXRlIiwiZXhpc3RpbmdQcmVmZXJlbmNlcyIsIm1lcmdlZFByZWZlcmVuY2VzIiwiZ2V0U3RvcmFnZVN0YXRzIiwiYmFja3VwQ291bnQiLCJwcm9maWxlQ291bnQiLCJyZWNvbW1lbmRhdGlvbkNvdW50IiwiY291bnRzIiwibGFzdFVwZGF0ZWQiLCJnZXRMYXRlc3RCYWNrdXBUaW1lc3RhbXAiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/storageUtils.ts\n"));

/***/ })

});