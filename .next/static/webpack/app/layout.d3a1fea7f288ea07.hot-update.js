"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/utils/storageUtils.ts":
/*!***********************************!*\
  !*** ./src/utils/storageUtils.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupOldBackups: () => (/* binding */ cleanupOldBackups),\n/* harmony export */   cleanupStorage: () => (/* binding */ cleanupStorage),\n/* harmony export */   createBackup: () => (/* binding */ createBackup),\n/* harmony export */   downloadExportedData: () => (/* binding */ downloadExportedData),\n/* harmony export */   exportData: () => (/* binding */ exportData),\n/* harmony export */   getStorageStats: () => (/* binding */ getStorageStats),\n/* harmony export */   getStorageUsage: () => (/* binding */ getStorageUsage),\n/* harmony export */   importData: () => (/* binding */ importData),\n/* harmony export */   importDataFromFile: () => (/* binding */ importDataFromFile),\n/* harmony export */   importDataWithStrategy: () => (/* binding */ importDataWithStrategy),\n/* harmony export */   isStorageAvailable: () => (/* binding */ isStorageAvailable),\n/* harmony export */   isStorageNearlyFull: () => (/* binding */ isStorageNearlyFull),\n/* harmony export */   loadDogProfiles: () => (/* binding */ loadDogProfiles),\n/* harmony export */   loadFromStorage: () => (/* binding */ loadFromStorage),\n/* harmony export */   loadRecommendations: () => (/* binding */ loadRecommendations),\n/* harmony export */   restoreFromBackup: () => (/* binding */ restoreFromBackup),\n/* harmony export */   saveDogProfiles: () => (/* binding */ saveDogProfiles),\n/* harmony export */   saveRecommendations: () => (/* binding */ saveRecommendations),\n/* harmony export */   saveToStorage: () => (/* binding */ saveToStorage)\n/* harmony export */ });\n/* harmony import */ var _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/storageSchema */ \"(app-pages-browser)/./src/types/storageSchema.ts\");\n/* harmony import */ var _errorHandling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errorHandling */ \"(app-pages-browser)/./src/utils/errorHandling.ts\");\n\n\n/**\n * Check if local storage is available\n * @returns true if available, false otherwise\n */ function isStorageAvailable() {\n    try {\n        const testKey = '__storage_test__';\n        localStorage.setItem(testKey, 'test');\n        const result = localStorage.getItem(testKey) === 'test';\n        localStorage.removeItem(testKey);\n        return result;\n    } catch (e) {\n        return false;\n    }\n}\n/**\n * Get the estimated local storage space usage in bytes\n * @returns Object containing used space and available space (if possible to determine)\n */ function getStorageUsage() {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        let totalSize = 0;\n        // Estimate space used by iterating through all keys\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if (key) {\n                const value = localStorage.getItem(key) || '';\n                totalSize += key.length + value.length;\n            }\n        }\n        // Convert to bytes (approximate as 2 bytes per character in UTF-16)\n        const usedBytes = totalSize * 2;\n        // Local storage limit is typically 5MB, but this varies by browser\n        const estimatedLimit = 5 * 1024 * 1024;\n        return {\n            used: usedBytes,\n            available: estimatedLimit - usedBytes,\n            percentUsed: usedBytes / estimatedLimit * 100\n        };\n    }, 'getStorageUsage');\n    if (error) {\n        return {\n            used: 0\n        };\n    }\n    return result || {\n        used: 0\n    };\n}\n/**\n * Check if storage is nearly full (over specified threshold)\n * @param thresholdPercent Percentage threshold (default: 80%)\n * @returns true if storage usage is over threshold\n */ function isStorageNearlyFull() {\n    let thresholdPercent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 80;\n    const usage = getStorageUsage();\n    return !!usage.percentUsed && usage.percentUsed > thresholdPercent;\n}\n/**\n * Save data to local storage with versioning\n * @param key Storage key\n * @param data Data to save\n * @throws StorageError if storage is not available or saving fails\n */ function saveToStorage(key, data) {\n    if (!isStorageAvailable()) {\n        throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Local storage is not available', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.STORAGE_UNAVAILABLE);\n    }\n    // Check if storage is nearly full\n    if (isStorageNearlyFull()) {\n        console.warn('Local storage is nearly full. Consider cleaning up old data.');\n    }\n    try {\n        // Create versioned data container\n        const storageData = {\n            version: _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.SCHEMA_VERSION,\n            updatedAt: Date.now(),\n            data\n        };\n        // Serialize and save\n        localStorage.setItem(key, JSON.stringify(storageData));\n    } catch (error) {\n        // Determine if this is a quota error\n        if (error instanceof Error && error.name === 'QuotaExceededError') {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Storage quota exceeded', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.STORAGE_QUOTA_EXCEEDED, {\n                originalError: error\n            });\n        }\n        throw (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.handleStorageError)(error, \"saveToStorage(\".concat(key, \")\"), _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.WRITE_ERROR);\n    }\n}\n/**\n * Load data from local storage with version checking\n * @param key Storage key\n * @param defaultValue Default value if not found or invalid\n * @returns The stored data or default value\n */ function loadFromStorage(key, defaultValue) {\n    if (!isStorageAvailable()) {\n        console.warn('Local storage is not available');\n        return defaultValue;\n    }\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        // Get serialized data\n        const serialized = localStorage.getItem(key);\n        if (!serialized) {\n            return defaultValue;\n        }\n        // Parse serialized data\n        const parsedData = JSON.parse(serialized);\n        // Version check\n        if (parsedData.version !== _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.SCHEMA_VERSION) {\n            console.warn(\"Storage schema version mismatch for \".concat(key, \". Expected \").concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.SCHEMA_VERSION, \", got \").concat(parsedData.version));\n            // Here we would add migration logic for different versions\n            // For now just return default\n            return defaultValue;\n        }\n        return parsedData;\n    }, \"loadFromStorage(\".concat(key, \")\"));\n    if (error) {\n        // Attempt to recover from backup on error\n        const backupResult = tryRestoreItemFromBackup(key);\n        if (backupResult.success && backupResult.data) {\n            try {\n                const parsedBackup = JSON.parse(backupResult.data);\n                return parsedBackup;\n            } catch (e) {\n                // If backup parsing fails, return default\n                return defaultValue;\n            }\n        }\n        return defaultValue;\n    }\n    return result || defaultValue;\n}\n/**\n * Try to restore a single item from its backup\n * @param key The key of the item to restore\n * @returns Success status and data if successful\n */ function tryRestoreItemFromBackup(key) {\n    try {\n        // Find backups for this specific key\n        const backupKey = \"\".concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX).concat(key);\n        const backupData = localStorage.getItem(backupKey);\n        if (backupData) {\n            // Restore from backup\n            localStorage.setItem(key, backupData);\n            return {\n                success: true,\n                data: backupData\n            };\n        }\n        return {\n            success: false,\n            data: null\n        };\n    } catch (e) {\n        return {\n            success: false,\n            data: null\n        };\n    }\n}\n/**\n * Create a backup of all application data\n * @returns true if backup successful, false otherwise\n */ function createBackup() {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        if (!isStorageAvailable()) {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Local storage is not available, cannot create backup', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.STORAGE_UNAVAILABLE);\n        }\n        const timestamp = Date.now();\n        const backupKey = \"\".concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX).concat(timestamp);\n        // Create a backup object with all app data\n        const backup = {\n            timestamp,\n            version: _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.SCHEMA_VERSION,\n            dogProfiles: localStorage.getItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES),\n            savedRecommendations: localStorage.getItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS),\n            userPreferences: localStorage.getItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES)\n        };\n        localStorage.setItem(backupKey, JSON.stringify(backup));\n        // Also create individual backups of each key\n        if (backup.dogProfiles) {\n            localStorage.setItem(\"\".concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX).concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES), backup.dogProfiles);\n        }\n        if (backup.savedRecommendations) {\n            localStorage.setItem(\"\".concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX).concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS), backup.savedRecommendations);\n        }\n        if (backup.userPreferences) {\n            localStorage.setItem(\"\".concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX).concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES), backup.userPreferences);\n        }\n        return true;\n    }, 'createBackup', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.BACKUP_ERROR);\n    return result === true;\n}\n/**\n * Restore data from the most recent backup\n * @returns true if restore successful, false otherwise\n */ function restoreFromBackup() {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        if (!isStorageAvailable()) {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Local storage is not available, cannot restore backup', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.STORAGE_UNAVAILABLE);\n        }\n        // Find the latest backup\n        let latestBackupKey = null;\n        let latestTimestamp = 0;\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if (key && key.startsWith(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES)) {\n                try {\n                    const timestamp = parseInt(key.replace(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX, ''), 10);\n                    if (!isNaN(timestamp) && timestamp > latestTimestamp) {\n                        latestTimestamp = timestamp;\n                        latestBackupKey = key;\n                    }\n                } catch (e) {\n                    continue;\n                }\n            }\n        }\n        if (!latestBackupKey) {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('No backup found', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.RESTORE_ERROR);\n        }\n        // Restore from backup\n        const serializedBackup = localStorage.getItem(latestBackupKey);\n        if (!serializedBackup) {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Backup is empty or corrupted', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.RESTORE_ERROR);\n        }\n        const backup = JSON.parse(serializedBackup);\n        if (backup.dogProfiles) {\n            localStorage.setItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, backup.dogProfiles);\n        }\n        if (backup.savedRecommendations) {\n            localStorage.setItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, backup.savedRecommendations);\n        }\n        if (backup.userPreferences) {\n            localStorage.setItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, backup.userPreferences);\n        }\n        return true;\n    }, 'restoreFromBackup', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.RESTORE_ERROR);\n    return result === true;\n}\n/**\n * Remove old backups, keeping only the most recent ones\n * @param keepCount Number of recent backups to keep (default: 3)\n * @returns number of backups removed\n */ function cleanupOldBackups() {\n    let keepCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        if (!isStorageAvailable()) {\n            return 0;\n        }\n        // Find all backups and their timestamps\n        const backups = [];\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if (key && key.startsWith(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES)) {\n                try {\n                    const timestamp = parseInt(key.replace(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX, ''), 10);\n                    if (!isNaN(timestamp)) {\n                        backups.push({\n                            key,\n                            timestamp\n                        });\n                    }\n                } catch (e) {\n                    continue;\n                }\n            }\n        }\n        // Sort by timestamp (newest first)\n        backups.sort((a, b)=>b.timestamp - a.timestamp);\n        // Remove old backups keeping the most recent ones\n        let removedCount = 0;\n        if (backups.length > keepCount) {\n            const toRemove = backups.slice(keepCount);\n            toRemove.forEach((backup)=>{\n                localStorage.removeItem(backup.key);\n                removedCount++;\n            });\n        }\n        return removedCount;\n    }, 'cleanupOldBackups');\n    return result || 0;\n}\n/**\n * Save dog profiles to storage\n * @param profiles Map of dog profiles by ID\n * @param activeProfileId ID of the active profile (optional)\n */ function saveDogProfiles(profiles, activeProfileId) {\n    const data = {\n        profiles,\n        activeProfileId\n    };\n    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, data);\n}\n/**\n * Load dog profiles from storage\n * @returns The stored dog profiles or default empty data\n */ function loadDogProfiles() {\n    return loadFromStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_DOG_PROFILES_STORAGE);\n}\n/**\n * Save saved recommendations to storage\n * @param recommendations Map of saved recommendations by product ID\n */ function saveRecommendations(recommendations) {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        const savedDates = {};\n        // Update timestamps for any new recommendations\n        Object.keys(recommendations).forEach((id)=>{\n            // Use existing timestamp if available, otherwise use current time\n            savedDates[id] = Date.now();\n        });\n        const data = {\n            recommendations,\n            savedDates\n        };\n        saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, data);\n    }, 'saveRecommendations');\n    if (error) {\n        throw error;\n    }\n}\n/**\n * Load saved recommendations from storage\n * @returns The stored recommendations or default empty data\n */ function loadRecommendations() {\n    return loadFromStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SAVED_RECOMMENDATIONS_STORAGE);\n}\n/**\n * Export all user data to a downloadable JSON file\n * @returns JSON string of all user data\n */ function exportData() {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        const dogProfiles = loadDogProfiles();\n        const savedRecommendations = loadRecommendations();\n        const userPreferences = loadFromStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_USER_PREFERENCES_STORAGE);\n        const exportData = {\n            schemaVersion: _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.SCHEMA_VERSION,\n            exportDate: new Date().toISOString(),\n            dogProfiles,\n            savedRecommendations,\n            userPreferences\n        };\n        return JSON.stringify(exportData, null, 2);\n    }, 'exportData', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.EXPORT_ERROR);\n    if (error) {\n        throw error;\n    }\n    return result || '{}';\n}\n/**\n * Import user data from a JSON string\n * @param jsonData JSON string with user data\n * @returns true if import successful, false otherwise\n */ function importData(jsonData) {\n    return importDataWithStrategy(jsonData, 'replace');\n}\n/**\n * Cleanup old or unused data from storage based on age threshold\n * @param olderThanDays Number of days after which data is considered old (default: 90)\n * @returns Object with counts of items cleaned up by category\n */ function cleanupStorage() {\n    let olderThanDays = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 90;\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        var _savedRecommendations_data, _savedRecommendations_data1;\n        if (!isStorageAvailable()) {\n            return {\n                recommendations: 0,\n                oldBackups: 0,\n                total: 0\n            };\n        }\n        const now = Date.now();\n        const ageThreshold = now - olderThanDays * 24 * 60 * 60 * 1000; // Convert days to milliseconds\n        let removedRecommendations = 0;\n        // Clean up old saved recommendations\n        const savedRecommendations = loadRecommendations();\n        if ((savedRecommendations === null || savedRecommendations === void 0 ? void 0 : (_savedRecommendations_data = savedRecommendations.data) === null || _savedRecommendations_data === void 0 ? void 0 : _savedRecommendations_data.recommendations) && (savedRecommendations === null || savedRecommendations === void 0 ? void 0 : (_savedRecommendations_data1 = savedRecommendations.data) === null || _savedRecommendations_data1 === void 0 ? void 0 : _savedRecommendations_data1.savedDates)) {\n            const { recommendations, savedDates } = savedRecommendations.data;\n            const updatedRecommendations = {};\n            const updatedSavedDates = {};\n            Object.entries(recommendations).forEach((param)=>{\n                let [id, recommendation] = param;\n                const savedDate = savedDates[id] || 0;\n                // Keep recommendations newer than the threshold\n                if (savedDate > ageThreshold) {\n                    updatedRecommendations[id] = recommendation;\n                    updatedSavedDates[id] = savedDate;\n                } else {\n                    removedRecommendations++;\n                }\n            });\n            // Only save if we removed any recommendations\n            if (removedRecommendations > 0) {\n                saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, {\n                    recommendations: updatedRecommendations,\n                    savedDates: updatedSavedDates\n                });\n            }\n        }\n        // Clean up old backups\n        const oldBackups = cleanupOldBackups(3); // Keep 3 most recent backups\n        const totalRemoved = removedRecommendations + oldBackups;\n        return {\n            recommendations: removedRecommendations,\n            oldBackups,\n            total: totalRemoved\n        };\n    }, 'cleanupStorage', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.CLEANUP_ERROR);\n    return result || {\n        recommendations: 0,\n        oldBackups: 0,\n        total: 0\n    };\n}\n/**\n * Download exported data as a JSON file\n * @param filename Custom filename (default: 'petfood-data-export.json')\n * @returns true if download initiated successfully, false otherwise\n */ function downloadExportedData() {\n    let filename = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'petfood-data-export.json';\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        const exportString = exportData();\n        // Create a Blob with the data\n        const blob = new Blob([\n            exportString\n        ], {\n            type: 'application/json'\n        });\n        const url = URL.createObjectURL(blob);\n        // Create a temporary link and trigger download\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = filename;\n        document.body.appendChild(link);\n        link.click();\n        // Clean up\n        setTimeout(()=>{\n            URL.revokeObjectURL(url);\n            document.body.removeChild(link);\n        }, 100);\n        return true;\n    }, 'downloadExportedData', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.EXPORT_ERROR);\n    return result === true;\n}\n/**\n * Import data from an uploaded file\n * @param file The uploaded File object\n * @param mergeStrategy How to handle existing data ('replace', 'merge', 'keep-newer')\n * @returns Promise resolving to true if import successful, false otherwise\n */ async function importDataFromFile(file) {\n    let mergeStrategy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'replace';\n    return new Promise((resolve)=>{\n        const reader = new FileReader();\n        reader.onload = (event)=>{\n            try {\n                var _event_target;\n                const jsonData = (_event_target = event.target) === null || _event_target === void 0 ? void 0 : _event_target.result;\n                const success = importDataWithStrategy(jsonData, mergeStrategy);\n                resolve(success);\n            } catch (error) {\n                console.error('Error importing data from file:', error);\n                resolve(false);\n            }\n        };\n        reader.onerror = ()=>{\n            console.error('Error reading file');\n            resolve(false);\n        };\n        reader.readAsText(file);\n    });\n}\n/**\n * Import data with the specified merge strategy\n * @param jsonData JSON string with user data\n * @param mergeStrategy How to handle existing data ('replace', 'merge', 'keep-newer')\n * @returns true if import successful, false otherwise\n */ function importDataWithStrategy(jsonData) {\n    let mergeStrategy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'replace';\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        var _importedData_dogProfiles_data, _importedData_dogProfiles, _importedData_savedRecommendations_data, _importedData_savedRecommendations, _importedData_userPreferences;\n        const importedData = JSON.parse(jsonData);\n        // Validate imported data\n        if (!importedData.schemaVersion || !importedData.exportDate) {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Invalid export data format', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.IMPORT_ERROR);\n        }\n        // Create backup before making any changes\n        createBackup();\n        // Handle dog profiles based on merge strategy\n        if ((_importedData_dogProfiles = importedData.dogProfiles) === null || _importedData_dogProfiles === void 0 ? void 0 : (_importedData_dogProfiles_data = _importedData_dogProfiles.data) === null || _importedData_dogProfiles_data === void 0 ? void 0 : _importedData_dogProfiles_data.profiles) {\n            if (mergeStrategy === 'replace') {\n                // Simply replace existing data\n                saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, importedData.dogProfiles.data);\n            } else {\n                var _existingProfiles_data;\n                // Merge or keep-newer strategies\n                const existingProfiles = loadDogProfiles();\n                if (existingProfiles === null || existingProfiles === void 0 ? void 0 : (_existingProfiles_data = existingProfiles.data) === null || _existingProfiles_data === void 0 ? void 0 : _existingProfiles_data.profiles) {\n                    const mergedProfiles = {\n                        ...existingProfiles.data\n                    };\n                    // Process each imported profile\n                    Object.entries(importedData.dogProfiles.data.profiles).forEach((param)=>{\n                        let [id, profile] = param;\n                        const existingProfile = mergedProfiles.profiles[id];\n                        if (!existingProfile) {\n                            // Profile doesn't exist in current data, add it\n                            mergedProfiles.profiles[id] = profile;\n                        } else if (mergeStrategy === 'keep-newer') {\n                            // Compare update timestamps and keep newer\n                            const importedTimestamp = importedData.dogProfiles.updatedAt || 0;\n                            const existingTimestamp = existingProfiles.updatedAt || 0;\n                            if (importedTimestamp > existingTimestamp) {\n                                mergedProfiles.profiles[id] = profile;\n                            }\n                        } else {\n                            // For 'merge' strategy, always update\n                            mergedProfiles.profiles[id] = profile;\n                        }\n                    });\n                    // Save merged profiles\n                    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, mergedProfiles);\n                } else {\n                    // No existing profiles, just import\n                    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, importedData.dogProfiles.data);\n                }\n            }\n        }\n        // Handle recommendations with similar merge strategy\n        if ((_importedData_savedRecommendations = importedData.savedRecommendations) === null || _importedData_savedRecommendations === void 0 ? void 0 : (_importedData_savedRecommendations_data = _importedData_savedRecommendations.data) === null || _importedData_savedRecommendations_data === void 0 ? void 0 : _importedData_savedRecommendations_data.recommendations) {\n            if (mergeStrategy === 'replace') {\n                saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, importedData.savedRecommendations.data);\n            } else {\n                var _existingRecommendations_data;\n                const existingRecommendations = loadRecommendations();\n                if (existingRecommendations === null || existingRecommendations === void 0 ? void 0 : (_existingRecommendations_data = existingRecommendations.data) === null || _existingRecommendations_data === void 0 ? void 0 : _existingRecommendations_data.recommendations) {\n                    const mergedRecommendations = {\n                        recommendations: {\n                            ...existingRecommendations.data.recommendations\n                        },\n                        savedDates: {\n                            ...existingRecommendations.data.savedDates\n                        }\n                    };\n                    // Process each imported recommendation\n                    Object.entries(importedData.savedRecommendations.data.recommendations).forEach((param)=>{\n                        let [id, recommendation] = param;\n                        var _importedData_savedRecommendations_data_savedDates;\n                        const existingRecommendation = mergedRecommendations.recommendations[id];\n                        const importedSavedDate = ((_importedData_savedRecommendations_data_savedDates = importedData.savedRecommendations.data.savedDates) === null || _importedData_savedRecommendations_data_savedDates === void 0 ? void 0 : _importedData_savedRecommendations_data_savedDates[id]) || 0;\n                        const existingSavedDate = mergedRecommendations.savedDates[id] || 0;\n                        if (!existingRecommendation) {\n                            // Recommendation doesn't exist, add it\n                            mergedRecommendations.recommendations[id] = recommendation;\n                            mergedRecommendations.savedDates[id] = importedSavedDate;\n                        } else if (mergeStrategy === 'keep-newer' && importedSavedDate > existingSavedDate) {\n                            // 'keep-newer' strategy - update if imported is newer\n                            mergedRecommendations.recommendations[id] = recommendation;\n                            mergedRecommendations.savedDates[id] = importedSavedDate;\n                        } else if (mergeStrategy === 'merge') {\n                            // 'merge' strategy - always update\n                            mergedRecommendations.recommendations[id] = recommendation;\n                            mergedRecommendations.savedDates[id] = importedSavedDate;\n                        }\n                    });\n                    // Save merged recommendations\n                    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, mergedRecommendations);\n                } else {\n                    // No existing recommendations, just import\n                    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, importedData.savedRecommendations.data);\n                }\n            }\n        }\n        // Handle user preferences\n        if ((_importedData_userPreferences = importedData.userPreferences) === null || _importedData_userPreferences === void 0 ? void 0 : _importedData_userPreferences.data) {\n            if (mergeStrategy === 'replace') {\n                saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, importedData.userPreferences.data);\n            } else {\n                const existingPreferences = loadFromStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_USER_PREFERENCES_STORAGE);\n                if (existingPreferences === null || existingPreferences === void 0 ? void 0 : existingPreferences.data) {\n                    if (mergeStrategy === 'keep-newer') {\n                        const importedTimestamp = importedData.userPreferences.updatedAt || 0;\n                        const existingTimestamp = existingPreferences.updatedAt || 0;\n                        if (importedTimestamp > existingTimestamp) {\n                            saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, importedData.userPreferences.data);\n                        }\n                    } else {\n                        // For 'merge' strategy, merge objects\n                        const mergedPreferences = {\n                            ...existingPreferences.data,\n                            ...importedData.userPreferences.data\n                        };\n                        saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, mergedPreferences);\n                    }\n                } else {\n                    // No existing preferences, just import\n                    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, importedData.userPreferences.data);\n                }\n            }\n        }\n        return true;\n    }, 'importDataWithStrategy', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.IMPORT_ERROR);\n    return result === true;\n}\n/**\n * Get statistics about storage usage and item counts\n * @returns Object with storage usage statistics\n */ function getStorageStats() {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        var _dogProfiles_data, _savedRecommendations_data;\n        // Get storage usage\n        const usage = getStorageUsage();\n        // Count items\n        const dogProfiles = loadDogProfiles();\n        const savedRecommendations = loadRecommendations();\n        // Count backups\n        let backupCount = 0;\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if (key && key.startsWith(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES)) {\n                backupCount++;\n            }\n        }\n        // Get profile and recommendation counts\n        const profileCount = (dogProfiles === null || dogProfiles === void 0 ? void 0 : (_dogProfiles_data = dogProfiles.data) === null || _dogProfiles_data === void 0 ? void 0 : _dogProfiles_data.profiles) ? Object.keys(dogProfiles.data.profiles).length : 0;\n        const recommendationCount = (savedRecommendations === null || savedRecommendations === void 0 ? void 0 : (_savedRecommendations_data = savedRecommendations.data) === null || _savedRecommendations_data === void 0 ? void 0 : _savedRecommendations_data.recommendations) ? Object.keys(savedRecommendations.data.recommendations).length : 0;\n        return {\n            usage,\n            counts: {\n                dogProfiles: profileCount,\n                savedRecommendations: recommendationCount,\n                backups: backupCount\n            },\n            lastUpdated: {\n                dogProfiles: dogProfiles === null || dogProfiles === void 0 ? void 0 : dogProfiles.updatedAt,\n                savedRecommendations: savedRecommendations === null || savedRecommendations === void 0 ? void 0 : savedRecommendations.updatedAt,\n                backups: getLatestBackupTimestamp()\n            }\n        };\n    }, 'getStorageStats');\n    return result || {\n        usage: {\n            used: 0\n        },\n        counts: {\n            dogProfiles: 0,\n            savedRecommendations: 0,\n            backups: 0\n        },\n        lastUpdated: {}\n    };\n}\n/**\n * Get the timestamp of the most recent backup\n * @returns Timestamp of the most recent backup, or undefined if none exists\n */ function getLatestBackupTimestamp() {\n    const { result } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        let latestTimestamp;\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if (key && key.startsWith(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES)) {\n                try {\n                    const timestamp = parseInt(key.replace(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX, ''), 10);\n                    if (!isNaN(timestamp) && (!latestTimestamp || timestamp > latestTimestamp)) {\n                        latestTimestamp = timestamp;\n                    }\n                } catch (e) {\n                    continue;\n                }\n            }\n        }\n        return latestTimestamp;\n    }, 'getLatestBackupTimestamp');\n    return result || undefined;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9zdG9yYWdlVXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBVWdDO0FBR3NFO0FBRXRHOzs7Q0FHQyxHQUNNLFNBQVNTO0lBQ2QsSUFBSTtRQUNGLE1BQU1DLFVBQVU7UUFDaEJDLGFBQWFDLE9BQU8sQ0FBQ0YsU0FBUztRQUM5QixNQUFNRyxTQUFTRixhQUFhRyxPQUFPLENBQUNKLGFBQWE7UUFDakRDLGFBQWFJLFVBQVUsQ0FBQ0w7UUFDeEIsT0FBT0c7SUFDVCxFQUFFLE9BQU9HLEdBQUc7UUFDVixPQUFPO0lBQ1Q7QUFDRjtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNDO0lBQ2QsTUFBTSxFQUFFSixNQUFNLEVBQUVLLEtBQUssRUFBRSxHQUFHViwrREFBZUEsQ0FBQztRQUN4QyxJQUFJVyxZQUFZO1FBRWhCLG9EQUFvRDtRQUNwRCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVQsYUFBYVUsTUFBTSxFQUFFRCxJQUFLO1lBQzVDLE1BQU1FLE1BQU1YLGFBQWFXLEdBQUcsQ0FBQ0Y7WUFDN0IsSUFBSUUsS0FBSztnQkFDUCxNQUFNQyxRQUFRWixhQUFhRyxPQUFPLENBQUNRLFFBQVE7Z0JBQzNDSCxhQUFhRyxJQUFJRCxNQUFNLEdBQUdFLE1BQU1GLE1BQU07WUFDeEM7UUFDRjtRQUVBLG9FQUFvRTtRQUNwRSxNQUFNRyxZQUFZTCxZQUFZO1FBRTlCLG1FQUFtRTtRQUNuRSxNQUFNTSxpQkFBaUIsSUFBSSxPQUFPO1FBRWxDLE9BQU87WUFDTEMsTUFBTUY7WUFDTkcsV0FBV0YsaUJBQWlCRDtZQUM1QkksYUFBYSxZQUFhSCxpQkFBa0I7UUFDOUM7SUFDRixHQUFHO0lBRUgsSUFBSVAsT0FBTztRQUNULE9BQU87WUFBRVEsTUFBTTtRQUFFO0lBQ25CO0lBRUEsT0FBT2IsVUFBVTtRQUFFYSxNQUFNO0lBQUU7QUFDN0I7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0c7UUFBb0JD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RDRDLFNBQVM4RjtZQUNYO1FBQ0Y7SUFDRixHQUFHO0lBRUgsT0FBT3BLLFVBQVU7UUFDZmtCLE9BQU87WUFBRUwsTUFBTTtRQUFFO1FBQ2pCcUosUUFBUTtZQUFFL0csYUFBYTtZQUFHRSxzQkFBc0I7WUFBR2lCLFNBQVM7UUFBRTtRQUM5RDZGLGFBQWEsQ0FBQztJQUNoQjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0M7SUFDUCxNQUFNLEVBQUVwSyxNQUFNLEVBQUUsR0FBR0wsK0RBQWVBLENBQUM7UUFDakMsSUFBSWlFO1FBRUosSUFBSyxJQUFJckQsSUFBSSxHQUFHQSxJQUFJVCxhQUFhVSxNQUFNLEVBQUVELElBQUs7WUFDNUMsTUFBTUUsTUFBTVgsYUFBYVcsR0FBRyxDQUFDRjtZQUM3QixJQUFJRSxPQUFPQSxJQUFJb0QsVUFBVSxDQUFDekUsNERBQVVBLENBQUMwRCxhQUFhLEtBQUssQ0FBQ3JDLElBQUlxRCxRQUFRLENBQUMxRSw0REFBVUEsQ0FBQ2dFLFlBQVksS0FDeEYsQ0FBQzNDLElBQUlxRCxRQUFRLENBQUMxRSw0REFBVUEsQ0FBQ2tFLHFCQUFxQixLQUFLLENBQUM3QyxJQUFJcUQsUUFBUSxDQUFDMUUsNERBQVVBLENBQUNvRSxnQkFBZ0IsR0FBRztnQkFDakcsSUFBSTtvQkFDRixNQUFNUCxZQUFZYyxTQUFTdEQsSUFBSXVELE9BQU8sQ0FBQzVFLDREQUFVQSxDQUFDMEQsYUFBYSxFQUFFLEtBQUs7b0JBQ3RFLElBQUksQ0FBQ21CLE1BQU1oQixjQUFlLEVBQUNXLG1CQUFtQlgsWUFBWVcsZUFBYyxHQUFJO3dCQUMxRUEsa0JBQWtCWDtvQkFDcEI7Z0JBQ0YsRUFBRSxPQUFPOUMsR0FBRztvQkFDVjtnQkFDRjtZQUNGO1FBQ0Y7UUFFQSxPQUFPeUQ7SUFDVCxHQUFHO0lBRUgsT0FBTzVELFVBQVVxSztBQUNuQiIsInNvdXJjZXMiOlsiL1VzZXJzL2pvbmF0aGFubWFocnRndXlvdS9EZXNrdG9wL0pvTWFHdXkgUHJvamVjdHMvUGV0Rm9vZC9zcmMvdXRpbHMvc3RvcmFnZVV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxuICBCYXNlU3RvcmFnZVNjaGVtYSwgXG4gIFNDSEVNQV9WRVJTSU9OLCBcbiAgU3RvcmFnZUtleSxcbiAgREVGQVVMVF9ET0dfUFJPRklMRVNfU1RPUkFHRSxcbiAgREVGQVVMVF9TQVZFRF9SRUNPTU1FTkRBVElPTlNfU1RPUkFHRSxcbiAgREVGQVVMVF9VU0VSX1BSRUZFUkVOQ0VTX1NUT1JBR0UsXG4gIERvZ1Byb2ZpbGVzU3RvcmFnZVNjaGVtYSxcbiAgU2F2ZWRSZWNvbW1lbmRhdGlvbnNTdG9yYWdlU2NoZW1hLFxuICBVc2VyUHJlZmVyZW5jZXNTdG9yYWdlU2NoZW1hXG59IGZyb20gJy4uL3R5cGVzL3N0b3JhZ2VTY2hlbWEnO1xuaW1wb3J0IHsgRG9nUHJvZmlsZSB9IGZyb20gJy4uL3R5cGVzL2RvZ1Byb2ZpbGUnO1xuaW1wb3J0IHsgRm9vZFJlY29tbWVuZGF0aW9uIH0gZnJvbSAnLi9yZWNvbW1lbmRhdGlvbkFsZ29yaXRobSc7XG5pbXBvcnQgeyBTdG9yYWdlRXJyb3IsIFN0b3JhZ2VFcnJvclR5cGUsIGhhbmRsZVN0b3JhZ2VFcnJvciwgdHJ5Q2F0Y2hTdG9yYWdlIH0gZnJvbSAnLi9lcnJvckhhbmRsaW5nJztcblxuLyoqXG4gKiBDaGVjayBpZiBsb2NhbCBzdG9yYWdlIGlzIGF2YWlsYWJsZVxuICogQHJldHVybnMgdHJ1ZSBpZiBhdmFpbGFibGUsIGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdG9yYWdlQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGNvbnN0IHRlc3RLZXkgPSAnX19zdG9yYWdlX3Rlc3RfXyc7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGVzdEtleSwgJ3Rlc3QnKTtcbiAgICBjb25zdCByZXN1bHQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0ZXN0S2V5KSA9PT0gJ3Rlc3QnO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRlc3RLZXkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIGVzdGltYXRlZCBsb2NhbCBzdG9yYWdlIHNwYWNlIHVzYWdlIGluIGJ5dGVzXG4gKiBAcmV0dXJucyBPYmplY3QgY29udGFpbmluZyB1c2VkIHNwYWNlIGFuZCBhdmFpbGFibGUgc3BhY2UgKGlmIHBvc3NpYmxlIHRvIGRldGVybWluZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0b3JhZ2VVc2FnZSgpOiB7IHVzZWQ6IG51bWJlcjsgYXZhaWxhYmxlPzogbnVtYmVyOyBwZXJjZW50VXNlZD86IG51bWJlciB9IHtcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB0cnlDYXRjaFN0b3JhZ2UoKCkgPT4ge1xuICAgIGxldCB0b3RhbFNpemUgPSAwO1xuICAgIFxuICAgIC8vIEVzdGltYXRlIHNwYWNlIHVzZWQgYnkgaXRlcmF0aW5nIHRocm91Z2ggYWxsIGtleXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpIHx8ICcnO1xuICAgICAgICB0b3RhbFNpemUgKz0ga2V5Lmxlbmd0aCArIHZhbHVlLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ29udmVydCB0byBieXRlcyAoYXBwcm94aW1hdGUgYXMgMiBieXRlcyBwZXIgY2hhcmFjdGVyIGluIFVURi0xNilcbiAgICBjb25zdCB1c2VkQnl0ZXMgPSB0b3RhbFNpemUgKiAyO1xuICAgIFxuICAgIC8vIExvY2FsIHN0b3JhZ2UgbGltaXQgaXMgdHlwaWNhbGx5IDVNQiwgYnV0IHRoaXMgdmFyaWVzIGJ5IGJyb3dzZXJcbiAgICBjb25zdCBlc3RpbWF0ZWRMaW1pdCA9IDUgKiAxMDI0ICogMTAyNDtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgdXNlZDogdXNlZEJ5dGVzLFxuICAgICAgYXZhaWxhYmxlOiBlc3RpbWF0ZWRMaW1pdCAtIHVzZWRCeXRlcyxcbiAgICAgIHBlcmNlbnRVc2VkOiAodXNlZEJ5dGVzIC8gZXN0aW1hdGVkTGltaXQpICogMTAwXG4gICAgfTtcbiAgfSwgJ2dldFN0b3JhZ2VVc2FnZScpO1xuICBcbiAgaWYgKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgdXNlZDogMCB9O1xuICB9XG4gIFxuICByZXR1cm4gcmVzdWx0IHx8IHsgdXNlZDogMCB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHN0b3JhZ2UgaXMgbmVhcmx5IGZ1bGwgKG92ZXIgc3BlY2lmaWVkIHRocmVzaG9sZClcbiAqIEBwYXJhbSB0aHJlc2hvbGRQZXJjZW50IFBlcmNlbnRhZ2UgdGhyZXNob2xkIChkZWZhdWx0OiA4MCUpXG4gKiBAcmV0dXJucyB0cnVlIGlmIHN0b3JhZ2UgdXNhZ2UgaXMgb3ZlciB0aHJlc2hvbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RvcmFnZU5lYXJseUZ1bGwodGhyZXNob2xkUGVyY2VudDogbnVtYmVyID0gODApOiBib29sZWFuIHtcbiAgY29uc3QgdXNhZ2UgPSBnZXRTdG9yYWdlVXNhZ2UoKTtcbiAgcmV0dXJuICEhdXNhZ2UucGVyY2VudFVzZWQgJiYgdXNhZ2UucGVyY2VudFVzZWQgPiB0aHJlc2hvbGRQZXJjZW50O1xufVxuXG4vKipcbiAqIFNhdmUgZGF0YSB0byBsb2NhbCBzdG9yYWdlIHdpdGggdmVyc2lvbmluZ1xuICogQHBhcmFtIGtleSBTdG9yYWdlIGtleVxuICogQHBhcmFtIGRhdGEgRGF0YSB0byBzYXZlXG4gKiBAdGhyb3dzIFN0b3JhZ2VFcnJvciBpZiBzdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgb3Igc2F2aW5nIGZhaWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYXZlVG9TdG9yYWdlPFQ+KGtleTogc3RyaW5nLCBkYXRhOiBUKTogdm9pZCB7XG4gIGlmICghaXNTdG9yYWdlQXZhaWxhYmxlKCkpIHtcbiAgICB0aHJvdyBuZXcgU3RvcmFnZUVycm9yKFxuICAgICAgJ0xvY2FsIHN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZScsXG4gICAgICBTdG9yYWdlRXJyb3JUeXBlLlNUT1JBR0VfVU5BVkFJTEFCTEVcbiAgICApO1xuICB9XG4gIFxuICAvLyBDaGVjayBpZiBzdG9yYWdlIGlzIG5lYXJseSBmdWxsXG4gIGlmIChpc1N0b3JhZ2VOZWFybHlGdWxsKCkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0xvY2FsIHN0b3JhZ2UgaXMgbmVhcmx5IGZ1bGwuIENvbnNpZGVyIGNsZWFuaW5nIHVwIG9sZCBkYXRhLicpO1xuICB9XG4gIFxuICB0cnkge1xuICAgIC8vIENyZWF0ZSB2ZXJzaW9uZWQgZGF0YSBjb250YWluZXJcbiAgICBjb25zdCBzdG9yYWdlRGF0YTogQmFzZVN0b3JhZ2VTY2hlbWE8VD4gPSB7XG4gICAgICB2ZXJzaW9uOiBTQ0hFTUFfVkVSU0lPTixcbiAgICAgIHVwZGF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIFxuICAgIC8vIFNlcmlhbGl6ZSBhbmQgc2F2ZVxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkoc3RvcmFnZURhdGEpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhpcyBpcyBhIHF1b3RhIGVycm9yXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gJ1F1b3RhRXhjZWVkZWRFcnJvcicpIHtcbiAgICAgIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoXG4gICAgICAgICdTdG9yYWdlIHF1b3RhIGV4Y2VlZGVkJyxcbiAgICAgICAgU3RvcmFnZUVycm9yVHlwZS5TVE9SQUdFX1FVT1RBX0VYQ0VFREVELFxuICAgICAgICB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH1cbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIHRocm93IGhhbmRsZVN0b3JhZ2VFcnJvcihcbiAgICAgIGVycm9yLCBcbiAgICAgIGBzYXZlVG9TdG9yYWdlKCR7a2V5fSlgLCBcbiAgICAgIFN0b3JhZ2VFcnJvclR5cGUuV1JJVEVfRVJST1JcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTG9hZCBkYXRhIGZyb20gbG9jYWwgc3RvcmFnZSB3aXRoIHZlcnNpb24gY2hlY2tpbmdcbiAqIEBwYXJhbSBrZXkgU3RvcmFnZSBrZXlcbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgRGVmYXVsdCB2YWx1ZSBpZiBub3QgZm91bmQgb3IgaW52YWxpZFxuICogQHJldHVybnMgVGhlIHN0b3JlZCBkYXRhIG9yIGRlZmF1bHQgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWRGcm9tU3RvcmFnZTxUPihrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlOiBCYXNlU3RvcmFnZVNjaGVtYTxUPik6IEJhc2VTdG9yYWdlU2NoZW1hPFQ+IHtcbiAgaWYgKCFpc1N0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgIGNvbnNvbGUud2FybignTG9jYWwgc3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxuICBcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB0cnlDYXRjaFN0b3JhZ2UoKCkgPT4ge1xuICAgIC8vIEdldCBzZXJpYWxpemVkIGRhdGFcbiAgICBjb25zdCBzZXJpYWxpemVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICBcbiAgICBpZiAoIXNlcmlhbGl6ZWQpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIFxuICAgIC8vIFBhcnNlIHNlcmlhbGl6ZWQgZGF0YVxuICAgIGNvbnN0IHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWQpIGFzIEJhc2VTdG9yYWdlU2NoZW1hPFQ+O1xuICAgIFxuICAgIC8vIFZlcnNpb24gY2hlY2tcbiAgICBpZiAocGFyc2VkRGF0YS52ZXJzaW9uICE9PSBTQ0hFTUFfVkVSU0lPTikge1xuICAgICAgY29uc29sZS53YXJuKGBTdG9yYWdlIHNjaGVtYSB2ZXJzaW9uIG1pc21hdGNoIGZvciAke2tleX0uIEV4cGVjdGVkICR7U0NIRU1BX1ZFUlNJT059LCBnb3QgJHtwYXJzZWREYXRhLnZlcnNpb259YCk7XG4gICAgICAvLyBIZXJlIHdlIHdvdWxkIGFkZCBtaWdyYXRpb24gbG9naWMgZm9yIGRpZmZlcmVudCB2ZXJzaW9uc1xuICAgICAgLy8gRm9yIG5vdyBqdXN0IHJldHVybiBkZWZhdWx0XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcGFyc2VkRGF0YTtcbiAgfSwgYGxvYWRGcm9tU3RvcmFnZSgke2tleX0pYCk7XG4gIFxuICBpZiAoZXJyb3IpIHtcbiAgICAvLyBBdHRlbXB0IHRvIHJlY292ZXIgZnJvbSBiYWNrdXAgb24gZXJyb3JcbiAgICBjb25zdCBiYWNrdXBSZXN1bHQgPSB0cnlSZXN0b3JlSXRlbUZyb21CYWNrdXAoa2V5KTtcbiAgICBpZiAoYmFja3VwUmVzdWx0LnN1Y2Nlc3MgJiYgYmFja3VwUmVzdWx0LmRhdGEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEJhY2t1cCA9IEpTT04ucGFyc2UoYmFja3VwUmVzdWx0LmRhdGEpIGFzIEJhc2VTdG9yYWdlU2NoZW1hPFQ+O1xuICAgICAgICByZXR1cm4gcGFyc2VkQmFja3VwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZiBiYWNrdXAgcGFyc2luZyBmYWlscywgcmV0dXJuIGRlZmF1bHRcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdCB8fCBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogVHJ5IHRvIHJlc3RvcmUgYSBzaW5nbGUgaXRlbSBmcm9tIGl0cyBiYWNrdXBcbiAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byByZXN0b3JlXG4gKiBAcmV0dXJucyBTdWNjZXNzIHN0YXR1cyBhbmQgZGF0YSBpZiBzdWNjZXNzZnVsXG4gKi9cbmZ1bmN0aW9uIHRyeVJlc3RvcmVJdGVtRnJvbUJhY2t1cChrZXk6IHN0cmluZyk6IHsgc3VjY2VzczogYm9vbGVhbjsgZGF0YTogc3RyaW5nIHwgbnVsbCB9IHtcbiAgdHJ5IHtcbiAgICAvLyBGaW5kIGJhY2t1cHMgZm9yIHRoaXMgc3BlY2lmaWMga2V5XG4gICAgY29uc3QgYmFja3VwS2V5ID0gYCR7U3RvcmFnZUtleS5CQUNLVVBfUFJFRklYfSR7a2V5fWA7XG4gICAgY29uc3QgYmFja3VwRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGJhY2t1cEtleSk7XG4gICAgXG4gICAgaWYgKGJhY2t1cERhdGEpIHtcbiAgICAgIC8vIFJlc3RvcmUgZnJvbSBiYWNrdXBcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgYmFja3VwRGF0YSk7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBiYWNrdXBEYXRhIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBkYXRhOiBudWxsIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZGF0YTogbnVsbCB9O1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYmFja3VwIG9mIGFsbCBhcHBsaWNhdGlvbiBkYXRhXG4gKiBAcmV0dXJucyB0cnVlIGlmIGJhY2t1cCBzdWNjZXNzZnVsLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJhY2t1cCgpOiBib29sZWFuIHtcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB0cnlDYXRjaFN0b3JhZ2UoKCkgPT4ge1xuICAgIGlmICghaXNTdG9yYWdlQXZhaWxhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoXG4gICAgICAgICdMb2NhbCBzdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUsIGNhbm5vdCBjcmVhdGUgYmFja3VwJyxcbiAgICAgICAgU3RvcmFnZUVycm9yVHlwZS5TVE9SQUdFX1VOQVZBSUxBQkxFXG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGJhY2t1cEtleSA9IGAke1N0b3JhZ2VLZXkuQkFDS1VQX1BSRUZJWH0ke3RpbWVzdGFtcH1gO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIGJhY2t1cCBvYmplY3Qgd2l0aCBhbGwgYXBwIGRhdGFcbiAgICBjb25zdCBiYWNrdXAgPSB7XG4gICAgICB0aW1lc3RhbXAsXG4gICAgICB2ZXJzaW9uOiBTQ0hFTUFfVkVSU0lPTixcbiAgICAgIGRvZ1Byb2ZpbGVzOiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTdG9yYWdlS2V5LkRPR19QUk9GSUxFUyksXG4gICAgICBzYXZlZFJlY29tbWVuZGF0aW9uczogbG9jYWxTdG9yYWdlLmdldEl0ZW0oU3RvcmFnZUtleS5TQVZFRF9SRUNPTU1FTkRBVElPTlMpLFxuICAgICAgdXNlclByZWZlcmVuY2VzOiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTdG9yYWdlS2V5LlVTRVJfUFJFRkVSRU5DRVMpXG4gICAgfTtcbiAgICBcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShiYWNrdXBLZXksIEpTT04uc3RyaW5naWZ5KGJhY2t1cCkpO1xuICAgIFxuICAgIC8vIEFsc28gY3JlYXRlIGluZGl2aWR1YWwgYmFja3VwcyBvZiBlYWNoIGtleVxuICAgIGlmIChiYWNrdXAuZG9nUHJvZmlsZXMpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGAke1N0b3JhZ2VLZXkuQkFDS1VQX1BSRUZJWH0ke1N0b3JhZ2VLZXkuRE9HX1BST0ZJTEVTfWAsIGJhY2t1cC5kb2dQcm9maWxlcyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChiYWNrdXAuc2F2ZWRSZWNvbW1lbmRhdGlvbnMpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGAke1N0b3JhZ2VLZXkuQkFDS1VQX1BSRUZJWH0ke1N0b3JhZ2VLZXkuU0FWRURfUkVDT01NRU5EQVRJT05TfWAsIGJhY2t1cC5zYXZlZFJlY29tbWVuZGF0aW9ucyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChiYWNrdXAudXNlclByZWZlcmVuY2VzKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgJHtTdG9yYWdlS2V5LkJBQ0tVUF9QUkVGSVh9JHtTdG9yYWdlS2V5LlVTRVJfUFJFRkVSRU5DRVN9YCwgYmFja3VwLnVzZXJQcmVmZXJlbmNlcyk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9LCAnY3JlYXRlQmFja3VwJywgU3RvcmFnZUVycm9yVHlwZS5CQUNLVVBfRVJST1IpO1xuICBcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXN0b3JlIGRhdGEgZnJvbSB0aGUgbW9zdCByZWNlbnQgYmFja3VwXG4gKiBAcmV0dXJucyB0cnVlIGlmIHJlc3RvcmUgc3VjY2Vzc2Z1bCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlRnJvbUJhY2t1cCgpOiBib29sZWFuIHtcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB0cnlDYXRjaFN0b3JhZ2UoKCkgPT4ge1xuICAgIGlmICghaXNTdG9yYWdlQXZhaWxhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoXG4gICAgICAgICdMb2NhbCBzdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUsIGNhbm5vdCByZXN0b3JlIGJhY2t1cCcsXG4gICAgICAgIFN0b3JhZ2VFcnJvclR5cGUuU1RPUkFHRV9VTkFWQUlMQUJMRVxuICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmluZCB0aGUgbGF0ZXN0IGJhY2t1cFxuICAgIGxldCBsYXRlc3RCYWNrdXBLZXk6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgIGxldCBsYXRlc3RUaW1lc3RhbXAgPSAwO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpO1xuICAgICAgaWYgKGtleSAmJiBrZXkuc3RhcnRzV2l0aChTdG9yYWdlS2V5LkJBQ0tVUF9QUkVGSVgpICYmICFrZXkuaW5jbHVkZXMoU3RvcmFnZUtleS5ET0dfUFJPRklMRVMpICYmIFxuICAgICAgICAgICFrZXkuaW5jbHVkZXMoU3RvcmFnZUtleS5TQVZFRF9SRUNPTU1FTkRBVElPTlMpICYmICFrZXkuaW5jbHVkZXMoU3RvcmFnZUtleS5VU0VSX1BSRUZFUkVOQ0VTKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IHBhcnNlSW50KGtleS5yZXBsYWNlKFN0b3JhZ2VLZXkuQkFDS1VQX1BSRUZJWCwgJycpLCAxMCk7XG4gICAgICAgICAgaWYgKCFpc05hTih0aW1lc3RhbXApICYmIHRpbWVzdGFtcCA+IGxhdGVzdFRpbWVzdGFtcCkge1xuICAgICAgICAgICAgbGF0ZXN0VGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgbGF0ZXN0QmFja3VwS2V5ID0ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIFNraXAga2V5cyB0aGF0IGRvbid0IGhhdmUgdmFsaWQgdGltZXN0YW1wc1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmICghbGF0ZXN0QmFja3VwS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgU3RvcmFnZUVycm9yKFxuICAgICAgICAnTm8gYmFja3VwIGZvdW5kJyxcbiAgICAgICAgU3RvcmFnZUVycm9yVHlwZS5SRVNUT1JFX0VSUk9SXG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICAvLyBSZXN0b3JlIGZyb20gYmFja3VwXG4gICAgY29uc3Qgc2VyaWFsaXplZEJhY2t1cCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGxhdGVzdEJhY2t1cEtleSk7XG4gICAgaWYgKCFzZXJpYWxpemVkQmFja3VwKSB7XG4gICAgICB0aHJvdyBuZXcgU3RvcmFnZUVycm9yKFxuICAgICAgICAnQmFja3VwIGlzIGVtcHR5IG9yIGNvcnJ1cHRlZCcsXG4gICAgICAgIFN0b3JhZ2VFcnJvclR5cGUuUkVTVE9SRV9FUlJPUlxuICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgYmFja3VwID0gSlNPTi5wYXJzZShzZXJpYWxpemVkQmFja3VwKTtcbiAgICBcbiAgICBpZiAoYmFja3VwLmRvZ1Byb2ZpbGVzKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTdG9yYWdlS2V5LkRPR19QUk9GSUxFUywgYmFja3VwLmRvZ1Byb2ZpbGVzKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGJhY2t1cC5zYXZlZFJlY29tbWVuZGF0aW9ucykge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU3RvcmFnZUtleS5TQVZFRF9SRUNPTU1FTkRBVElPTlMsIGJhY2t1cC5zYXZlZFJlY29tbWVuZGF0aW9ucyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChiYWNrdXAudXNlclByZWZlcmVuY2VzKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTdG9yYWdlS2V5LlVTRVJfUFJFRkVSRU5DRVMsIGJhY2t1cC51c2VyUHJlZmVyZW5jZXMpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgJ3Jlc3RvcmVGcm9tQmFja3VwJywgU3RvcmFnZUVycm9yVHlwZS5SRVNUT1JFX0VSUk9SKTtcbiAgXG4gIHJldHVybiByZXN1bHQgPT09IHRydWU7XG59XG5cbi8qKlxuICogUmVtb3ZlIG9sZCBiYWNrdXBzLCBrZWVwaW5nIG9ubHkgdGhlIG1vc3QgcmVjZW50IG9uZXNcbiAqIEBwYXJhbSBrZWVwQ291bnQgTnVtYmVyIG9mIHJlY2VudCBiYWNrdXBzIHRvIGtlZXAgKGRlZmF1bHQ6IDMpXG4gKiBAcmV0dXJucyBudW1iZXIgb2YgYmFja3VwcyByZW1vdmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbnVwT2xkQmFja3VwcyhrZWVwQ291bnQ6IG51bWJlciA9IDMpOiBudW1iZXIge1xuICBjb25zdCB7IHJlc3VsdCwgZXJyb3IgfSA9IHRyeUNhdGNoU3RvcmFnZSgoKSA9PiB7XG4gICAgaWYgKCFpc1N0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIFxuICAgIC8vIEZpbmQgYWxsIGJhY2t1cHMgYW5kIHRoZWlyIHRpbWVzdGFtcHNcbiAgICBjb25zdCBiYWNrdXBzOiB7IGtleTogc3RyaW5nOyB0aW1lc3RhbXA6IG51bWJlciB9W10gPSBbXTtcbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgIGlmIChrZXkgJiYga2V5LnN0YXJ0c1dpdGgoU3RvcmFnZUtleS5CQUNLVVBfUFJFRklYKSAmJiAha2V5LmluY2x1ZGVzKFN0b3JhZ2VLZXkuRE9HX1BST0ZJTEVTKSAmJiBcbiAgICAgICAgICAha2V5LmluY2x1ZGVzKFN0b3JhZ2VLZXkuU0FWRURfUkVDT01NRU5EQVRJT05TKSAmJiAha2V5LmluY2x1ZGVzKFN0b3JhZ2VLZXkuVVNFUl9QUkVGRVJFTkNFUykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBwYXJzZUludChrZXkucmVwbGFjZShTdG9yYWdlS2V5LkJBQ0tVUF9QUkVGSVgsICcnKSwgMTApO1xuICAgICAgICAgIGlmICghaXNOYU4odGltZXN0YW1wKSkge1xuICAgICAgICAgICAgYmFja3Vwcy5wdXNoKHsga2V5LCB0aW1lc3RhbXAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gU2tpcCBrZXlzIHRoYXQgZG9uJ3QgaGF2ZSB2YWxpZCB0aW1lc3RhbXBzXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gU29ydCBieSB0aW1lc3RhbXAgKG5ld2VzdCBmaXJzdClcbiAgICBiYWNrdXBzLnNvcnQoKGEsIGIpID0+IGIudGltZXN0YW1wIC0gYS50aW1lc3RhbXApO1xuICAgIFxuICAgIC8vIFJlbW92ZSBvbGQgYmFja3VwcyBrZWVwaW5nIHRoZSBtb3N0IHJlY2VudCBvbmVzXG4gICAgbGV0IHJlbW92ZWRDb3VudCA9IDA7XG4gICAgaWYgKGJhY2t1cHMubGVuZ3RoID4ga2VlcENvdW50KSB7XG4gICAgICBjb25zdCB0b1JlbW92ZSA9IGJhY2t1cHMuc2xpY2Uoa2VlcENvdW50KTtcbiAgICAgIHRvUmVtb3ZlLmZvckVhY2goYmFja3VwID0+IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oYmFja3VwLmtleSk7XG4gICAgICAgIHJlbW92ZWRDb3VudCsrO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZW1vdmVkQ291bnQ7XG4gIH0sICdjbGVhbnVwT2xkQmFja3VwcycpO1xuICBcbiAgcmV0dXJuIHJlc3VsdCB8fCAwO1xufVxuXG4vKipcbiAqIFNhdmUgZG9nIHByb2ZpbGVzIHRvIHN0b3JhZ2VcbiAqIEBwYXJhbSBwcm9maWxlcyBNYXAgb2YgZG9nIHByb2ZpbGVzIGJ5IElEXG4gKiBAcGFyYW0gYWN0aXZlUHJvZmlsZUlkIElEIG9mIHRoZSBhY3RpdmUgcHJvZmlsZSAob3B0aW9uYWwpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYXZlRG9nUHJvZmlsZXMoXG4gIHByb2ZpbGVzOiBSZWNvcmQ8c3RyaW5nLCBEb2dQcm9maWxlPiwgXG4gIGFjdGl2ZVByb2ZpbGVJZD86IHN0cmluZ1xuKTogdm9pZCB7XG4gIGNvbnN0IGRhdGE6IERvZ1Byb2ZpbGVzU3RvcmFnZVNjaGVtYVsnZGF0YSddID0ge1xuICAgIHByb2ZpbGVzLFxuICAgIGFjdGl2ZVByb2ZpbGVJZFxuICB9O1xuICBcbiAgc2F2ZVRvU3RvcmFnZTxEb2dQcm9maWxlc1N0b3JhZ2VTY2hlbWFbJ2RhdGEnXT4oU3RvcmFnZUtleS5ET0dfUFJPRklMRVMsIGRhdGEpO1xufVxuXG4vKipcbiAqIExvYWQgZG9nIHByb2ZpbGVzIGZyb20gc3RvcmFnZVxuICogQHJldHVybnMgVGhlIHN0b3JlZCBkb2cgcHJvZmlsZXMgb3IgZGVmYXVsdCBlbXB0eSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkRG9nUHJvZmlsZXMoKTogRG9nUHJvZmlsZXNTdG9yYWdlU2NoZW1hIHtcbiAgcmV0dXJuIGxvYWRGcm9tU3RvcmFnZTxEb2dQcm9maWxlc1N0b3JhZ2VTY2hlbWFbJ2RhdGEnXT4oXG4gICAgU3RvcmFnZUtleS5ET0dfUFJPRklMRVMsIFxuICAgIERFRkFVTFRfRE9HX1BST0ZJTEVTX1NUT1JBR0VcbiAgKTtcbn1cblxuLyoqXG4gKiBTYXZlIHNhdmVkIHJlY29tbWVuZGF0aW9ucyB0byBzdG9yYWdlXG4gKiBAcGFyYW0gcmVjb21tZW5kYXRpb25zIE1hcCBvZiBzYXZlZCByZWNvbW1lbmRhdGlvbnMgYnkgcHJvZHVjdCBJRFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVJlY29tbWVuZGF0aW9ucyhyZWNvbW1lbmRhdGlvbnM6IFJlY29yZDxzdHJpbmcsIEZvb2RSZWNvbW1lbmRhdGlvbj4pOiB2b2lkIHtcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB0cnlDYXRjaFN0b3JhZ2UoKCkgPT4ge1xuICAgIGNvbnN0IHNhdmVkRGF0ZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICBcbiAgICAvLyBVcGRhdGUgdGltZXN0YW1wcyBmb3IgYW55IG5ldyByZWNvbW1lbmRhdGlvbnNcbiAgICBPYmplY3Qua2V5cyhyZWNvbW1lbmRhdGlvbnMpLmZvckVhY2goaWQgPT4ge1xuICAgICAgLy8gVXNlIGV4aXN0aW5nIHRpbWVzdGFtcCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1c2UgY3VycmVudCB0aW1lXG4gICAgICBzYXZlZERhdGVzW2lkXSA9IERhdGUubm93KCk7XG4gICAgfSk7XG4gICAgXG4gICAgY29uc3QgZGF0YTogU2F2ZWRSZWNvbW1lbmRhdGlvbnNTdG9yYWdlU2NoZW1hWydkYXRhJ10gPSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMsXG4gICAgICBzYXZlZERhdGVzXG4gICAgfTtcbiAgICBcbiAgICBzYXZlVG9TdG9yYWdlPFNhdmVkUmVjb21tZW5kYXRpb25zU3RvcmFnZVNjaGVtYVsnZGF0YSddPihTdG9yYWdlS2V5LlNBVkVEX1JFQ09NTUVOREFUSU9OUywgZGF0YSk7XG4gIH0sICdzYXZlUmVjb21tZW5kYXRpb25zJyk7XG4gIFxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIExvYWQgc2F2ZWQgcmVjb21tZW5kYXRpb25zIGZyb20gc3RvcmFnZVxuICogQHJldHVybnMgVGhlIHN0b3JlZCByZWNvbW1lbmRhdGlvbnMgb3IgZGVmYXVsdCBlbXB0eSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkUmVjb21tZW5kYXRpb25zKCk6IFNhdmVkUmVjb21tZW5kYXRpb25zU3RvcmFnZVNjaGVtYSB7XG4gIHJldHVybiBsb2FkRnJvbVN0b3JhZ2U8U2F2ZWRSZWNvbW1lbmRhdGlvbnNTdG9yYWdlU2NoZW1hWydkYXRhJ10+KFxuICAgIFN0b3JhZ2VLZXkuU0FWRURfUkVDT01NRU5EQVRJT05TLCBcbiAgICBERUZBVUxUX1NBVkVEX1JFQ09NTUVOREFUSU9OU19TVE9SQUdFXG4gICk7XG59XG5cbi8qKlxuICogRXhwb3J0IGFsbCB1c2VyIGRhdGEgdG8gYSBkb3dubG9hZGFibGUgSlNPTiBmaWxlXG4gKiBAcmV0dXJucyBKU09OIHN0cmluZyBvZiBhbGwgdXNlciBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBvcnREYXRhKCk6IHN0cmluZyB7XG4gIGNvbnN0IHsgcmVzdWx0LCBlcnJvciB9ID0gdHJ5Q2F0Y2hTdG9yYWdlKCgpID0+IHtcbiAgICBjb25zdCBkb2dQcm9maWxlcyA9IGxvYWREb2dQcm9maWxlcygpO1xuICAgIGNvbnN0IHNhdmVkUmVjb21tZW5kYXRpb25zID0gbG9hZFJlY29tbWVuZGF0aW9ucygpO1xuICAgIGNvbnN0IHVzZXJQcmVmZXJlbmNlcyA9IGxvYWRGcm9tU3RvcmFnZTxVc2VyUHJlZmVyZW5jZXNTdG9yYWdlU2NoZW1hWydkYXRhJ10+KFxuICAgICAgU3RvcmFnZUtleS5VU0VSX1BSRUZFUkVOQ0VTLFxuICAgICAgREVGQVVMVF9VU0VSX1BSRUZFUkVOQ0VTX1NUT1JBR0VcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IGV4cG9ydERhdGEgPSB7XG4gICAgICBzY2hlbWFWZXJzaW9uOiBTQ0hFTUFfVkVSU0lPTixcbiAgICAgIGV4cG9ydERhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGRvZ1Byb2ZpbGVzLFxuICAgICAgc2F2ZWRSZWNvbW1lbmRhdGlvbnMsXG4gICAgICB1c2VyUHJlZmVyZW5jZXNcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShleHBvcnREYXRhLCBudWxsLCAyKTtcbiAgfSwgJ2V4cG9ydERhdGEnLCBTdG9yYWdlRXJyb3JUeXBlLkVYUE9SVF9FUlJPUik7XG4gIFxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdCB8fCAne30nO1xufVxuXG4vKipcbiAqIEltcG9ydCB1c2VyIGRhdGEgZnJvbSBhIEpTT04gc3RyaW5nXG4gKiBAcGFyYW0ganNvbkRhdGEgSlNPTiBzdHJpbmcgd2l0aCB1c2VyIGRhdGFcbiAqIEByZXR1cm5zIHRydWUgaWYgaW1wb3J0IHN1Y2Nlc3NmdWwsIGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW1wb3J0RGF0YShqc29uRGF0YTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBpbXBvcnREYXRhV2l0aFN0cmF0ZWd5KGpzb25EYXRhLCAncmVwbGFjZScpO1xufVxuXG4vKipcbiAqIENsZWFudXAgb2xkIG9yIHVudXNlZCBkYXRhIGZyb20gc3RvcmFnZSBiYXNlZCBvbiBhZ2UgdGhyZXNob2xkXG4gKiBAcGFyYW0gb2xkZXJUaGFuRGF5cyBOdW1iZXIgb2YgZGF5cyBhZnRlciB3aGljaCBkYXRhIGlzIGNvbnNpZGVyZWQgb2xkIChkZWZhdWx0OiA5MClcbiAqIEByZXR1cm5zIE9iamVjdCB3aXRoIGNvdW50cyBvZiBpdGVtcyBjbGVhbmVkIHVwIGJ5IGNhdGVnb3J5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbnVwU3RvcmFnZShvbGRlclRoYW5EYXlzOiBudW1iZXIgPSA5MCk6IHsgXG4gIHJlY29tbWVuZGF0aW9uczogbnVtYmVyOyBcbiAgb2xkQmFja3VwczogbnVtYmVyO1xuICB0b3RhbDogbnVtYmVyO1xufSB7XG4gIGNvbnN0IHsgcmVzdWx0LCBlcnJvciB9ID0gdHJ5Q2F0Y2hTdG9yYWdlKCgpID0+IHtcbiAgICBpZiAoIWlzU3RvcmFnZUF2YWlsYWJsZSgpKSB7XG4gICAgICByZXR1cm4geyByZWNvbW1lbmRhdGlvbnM6IDAsIG9sZEJhY2t1cHM6IDAsIHRvdGFsOiAwIH07XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgYWdlVGhyZXNob2xkID0gbm93IC0gKG9sZGVyVGhhbkRheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKTsgLy8gQ29udmVydCBkYXlzIHRvIG1pbGxpc2Vjb25kc1xuICAgIGxldCByZW1vdmVkUmVjb21tZW5kYXRpb25zID0gMDtcbiAgICBcbiAgICAvLyBDbGVhbiB1cCBvbGQgc2F2ZWQgcmVjb21tZW5kYXRpb25zXG4gICAgY29uc3Qgc2F2ZWRSZWNvbW1lbmRhdGlvbnMgPSBsb2FkUmVjb21tZW5kYXRpb25zKCk7XG4gICAgaWYgKHNhdmVkUmVjb21tZW5kYXRpb25zPy5kYXRhPy5yZWNvbW1lbmRhdGlvbnMgJiYgc2F2ZWRSZWNvbW1lbmRhdGlvbnM/LmRhdGE/LnNhdmVkRGF0ZXMpIHtcbiAgICAgIGNvbnN0IHsgcmVjb21tZW5kYXRpb25zLCBzYXZlZERhdGVzIH0gPSBzYXZlZFJlY29tbWVuZGF0aW9ucy5kYXRhO1xuICAgICAgY29uc3QgdXBkYXRlZFJlY29tbWVuZGF0aW9uczogUmVjb3JkPHN0cmluZywgRm9vZFJlY29tbWVuZGF0aW9uPiA9IHt9O1xuICAgICAgY29uc3QgdXBkYXRlZFNhdmVkRGF0ZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICAgIFxuICAgICAgT2JqZWN0LmVudHJpZXMocmVjb21tZW5kYXRpb25zKS5mb3JFYWNoKChbaWQsIHJlY29tbWVuZGF0aW9uXSkgPT4ge1xuICAgICAgICBjb25zdCBzYXZlZERhdGUgPSBzYXZlZERhdGVzW2lkXSB8fCAwO1xuICAgICAgICBcbiAgICAgICAgLy8gS2VlcCByZWNvbW1lbmRhdGlvbnMgbmV3ZXIgdGhhbiB0aGUgdGhyZXNob2xkXG4gICAgICAgIGlmIChzYXZlZERhdGUgPiBhZ2VUaHJlc2hvbGQpIHtcbiAgICAgICAgICB1cGRhdGVkUmVjb21tZW5kYXRpb25zW2lkXSA9IHJlY29tbWVuZGF0aW9uO1xuICAgICAgICAgIHVwZGF0ZWRTYXZlZERhdGVzW2lkXSA9IHNhdmVkRGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkUmVjb21tZW5kYXRpb25zKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBPbmx5IHNhdmUgaWYgd2UgcmVtb3ZlZCBhbnkgcmVjb21tZW5kYXRpb25zXG4gICAgICBpZiAocmVtb3ZlZFJlY29tbWVuZGF0aW9ucyA+IDApIHtcbiAgICAgICAgc2F2ZVRvU3RvcmFnZShTdG9yYWdlS2V5LlNBVkVEX1JFQ09NTUVOREFUSU9OUywge1xuICAgICAgICAgIHJlY29tbWVuZGF0aW9uczogdXBkYXRlZFJlY29tbWVuZGF0aW9ucyxcbiAgICAgICAgICBzYXZlZERhdGVzOiB1cGRhdGVkU2F2ZWREYXRlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgb2xkIGJhY2t1cHNcbiAgICBjb25zdCBvbGRCYWNrdXBzID0gY2xlYW51cE9sZEJhY2t1cHMoMyk7IC8vIEtlZXAgMyBtb3N0IHJlY2VudCBiYWNrdXBzXG4gICAgXG4gICAgY29uc3QgdG90YWxSZW1vdmVkID0gcmVtb3ZlZFJlY29tbWVuZGF0aW9ucyArIG9sZEJhY2t1cHM7XG4gICAgXG4gICAgcmV0dXJuIHsgXG4gICAgICByZWNvbW1lbmRhdGlvbnM6IHJlbW92ZWRSZWNvbW1lbmRhdGlvbnMsIFxuICAgICAgb2xkQmFja3VwcywgXG4gICAgICB0b3RhbDogdG90YWxSZW1vdmVkIFxuICAgIH07XG4gIH0sICdjbGVhbnVwU3RvcmFnZScsIFN0b3JhZ2VFcnJvclR5cGUuQ0xFQU5VUF9FUlJPUik7XG4gIFxuICByZXR1cm4gcmVzdWx0IHx8IHsgcmVjb21tZW5kYXRpb25zOiAwLCBvbGRCYWNrdXBzOiAwLCB0b3RhbDogMCB9O1xufVxuXG4vKipcbiAqIERvd25sb2FkIGV4cG9ydGVkIGRhdGEgYXMgYSBKU09OIGZpbGVcbiAqIEBwYXJhbSBmaWxlbmFtZSBDdXN0b20gZmlsZW5hbWUgKGRlZmF1bHQ6ICdwZXRmb29kLWRhdGEtZXhwb3J0Lmpzb24nKVxuICogQHJldHVybnMgdHJ1ZSBpZiBkb3dubG9hZCBpbml0aWF0ZWQgc3VjY2Vzc2Z1bGx5LCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvd25sb2FkRXhwb3J0ZWREYXRhKGZpbGVuYW1lOiBzdHJpbmcgPSAncGV0Zm9vZC1kYXRhLWV4cG9ydC5qc29uJyk6IGJvb2xlYW4ge1xuICBjb25zdCB7IHJlc3VsdCwgZXJyb3IgfSA9IHRyeUNhdGNoU3RvcmFnZSgoKSA9PiB7XG4gICAgY29uc3QgZXhwb3J0U3RyaW5nID0gZXhwb3J0RGF0YSgpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIEJsb2Igd2l0aCB0aGUgZGF0YVxuICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbZXhwb3J0U3RyaW5nXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vanNvbicgfSk7XG4gICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgbGluayBhbmQgdHJpZ2dlciBkb3dubG9hZFxuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgbGluay5ocmVmID0gdXJsO1xuICAgIGxpbmsuZG93bmxvYWQgPSBmaWxlbmFtZTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xuICAgIGxpbmsuY2xpY2soKTtcbiAgICBcbiAgICAvLyBDbGVhbiB1cFxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICB9LCAxMDApO1xuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9LCAnZG93bmxvYWRFeHBvcnRlZERhdGEnLCBTdG9yYWdlRXJyb3JUeXBlLkVYUE9SVF9FUlJPUik7XG4gIFxuICByZXR1cm4gcmVzdWx0ID09PSB0cnVlO1xufVxuXG4vKipcbiAqIEltcG9ydCBkYXRhIGZyb20gYW4gdXBsb2FkZWQgZmlsZVxuICogQHBhcmFtIGZpbGUgVGhlIHVwbG9hZGVkIEZpbGUgb2JqZWN0XG4gKiBAcGFyYW0gbWVyZ2VTdHJhdGVneSBIb3cgdG8gaGFuZGxlIGV4aXN0aW5nIGRhdGEgKCdyZXBsYWNlJywgJ21lcmdlJywgJ2tlZXAtbmV3ZXInKVxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdHJ1ZSBpZiBpbXBvcnQgc3VjY2Vzc2Z1bCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXBvcnREYXRhRnJvbUZpbGUoXG4gIGZpbGU6IEZpbGUsIFxuICBtZXJnZVN0cmF0ZWd5OiAncmVwbGFjZScgfCAnbWVyZ2UnIHwgJ2tlZXAtbmV3ZXInID0gJ3JlcGxhY2UnXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBcbiAgICByZWFkZXIub25sb2FkID0gKGV2ZW50KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBqc29uRGF0YSA9IGV2ZW50LnRhcmdldD8ucmVzdWx0IGFzIHN0cmluZztcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGltcG9ydERhdGFXaXRoU3RyYXRlZ3koanNvbkRhdGEsIG1lcmdlU3RyYXRlZ3kpO1xuICAgICAgICByZXNvbHZlKHN1Y2Nlc3MpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW1wb3J0aW5nIGRhdGEgZnJvbSBmaWxlOicsIGVycm9yKTtcbiAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlYWRpbmcgZmlsZScpO1xuICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgfTtcbiAgICBcbiAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW1wb3J0IGRhdGEgd2l0aCB0aGUgc3BlY2lmaWVkIG1lcmdlIHN0cmF0ZWd5XG4gKiBAcGFyYW0ganNvbkRhdGEgSlNPTiBzdHJpbmcgd2l0aCB1c2VyIGRhdGFcbiAqIEBwYXJhbSBtZXJnZVN0cmF0ZWd5IEhvdyB0byBoYW5kbGUgZXhpc3RpbmcgZGF0YSAoJ3JlcGxhY2UnLCAnbWVyZ2UnLCAna2VlcC1uZXdlcicpXG4gKiBAcmV0dXJucyB0cnVlIGlmIGltcG9ydCBzdWNjZXNzZnVsLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGltcG9ydERhdGFXaXRoU3RyYXRlZ3koXG4gIGpzb25EYXRhOiBzdHJpbmcsIFxuICBtZXJnZVN0cmF0ZWd5OiAncmVwbGFjZScgfCAnbWVyZ2UnIHwgJ2tlZXAtbmV3ZXInID0gJ3JlcGxhY2UnXG4pOiBib29sZWFuIHtcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB0cnlDYXRjaFN0b3JhZ2UoKCkgPT4ge1xuICAgIGNvbnN0IGltcG9ydGVkRGF0YSA9IEpTT04ucGFyc2UoanNvbkRhdGEpO1xuICAgIFxuICAgIC8vIFZhbGlkYXRlIGltcG9ydGVkIGRhdGFcbiAgICBpZiAoIWltcG9ydGVkRGF0YS5zY2hlbWFWZXJzaW9uIHx8ICFpbXBvcnRlZERhdGEuZXhwb3J0RGF0ZSkge1xuICAgICAgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcihcbiAgICAgICAgJ0ludmFsaWQgZXhwb3J0IGRhdGEgZm9ybWF0JyxcbiAgICAgICAgU3RvcmFnZUVycm9yVHlwZS5JTVBPUlRfRVJST1JcbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSBiYWNrdXAgYmVmb3JlIG1ha2luZyBhbnkgY2hhbmdlc1xuICAgIGNyZWF0ZUJhY2t1cCgpO1xuICAgIFxuICAgIC8vIEhhbmRsZSBkb2cgcHJvZmlsZXMgYmFzZWQgb24gbWVyZ2Ugc3RyYXRlZ3lcbiAgICBpZiAoaW1wb3J0ZWREYXRhLmRvZ1Byb2ZpbGVzPy5kYXRhPy5wcm9maWxlcykge1xuICAgICAgaWYgKG1lcmdlU3RyYXRlZ3kgPT09ICdyZXBsYWNlJykge1xuICAgICAgICAvLyBTaW1wbHkgcmVwbGFjZSBleGlzdGluZyBkYXRhXG4gICAgICAgIHNhdmVUb1N0b3JhZ2UoU3RvcmFnZUtleS5ET0dfUFJPRklMRVMsIGltcG9ydGVkRGF0YS5kb2dQcm9maWxlcy5kYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1lcmdlIG9yIGtlZXAtbmV3ZXIgc3RyYXRlZ2llc1xuICAgICAgICBjb25zdCBleGlzdGluZ1Byb2ZpbGVzID0gbG9hZERvZ1Byb2ZpbGVzKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZXhpc3RpbmdQcm9maWxlcz8uZGF0YT8ucHJvZmlsZXMpIHtcbiAgICAgICAgICBjb25zdCBtZXJnZWRQcm9maWxlcyA9IHsgLi4uZXhpc3RpbmdQcm9maWxlcy5kYXRhIH07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUHJvY2VzcyBlYWNoIGltcG9ydGVkIHByb2ZpbGVcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhpbXBvcnRlZERhdGEuZG9nUHJvZmlsZXMuZGF0YS5wcm9maWxlcykuZm9yRWFjaCgoW2lkLCBwcm9maWxlXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdQcm9maWxlID0gbWVyZ2VkUHJvZmlsZXMucHJvZmlsZXNbaWRdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIWV4aXN0aW5nUHJvZmlsZSkge1xuICAgICAgICAgICAgICAvLyBQcm9maWxlIGRvZXNuJ3QgZXhpc3QgaW4gY3VycmVudCBkYXRhLCBhZGQgaXRcbiAgICAgICAgICAgICAgbWVyZ2VkUHJvZmlsZXMucHJvZmlsZXNbaWRdID0gcHJvZmlsZSBhcyBEb2dQcm9maWxlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJnZVN0cmF0ZWd5ID09PSAna2VlcC1uZXdlcicpIHtcbiAgICAgICAgICAgICAgLy8gQ29tcGFyZSB1cGRhdGUgdGltZXN0YW1wcyBhbmQga2VlcCBuZXdlclxuICAgICAgICAgICAgICBjb25zdCBpbXBvcnRlZFRpbWVzdGFtcCA9IGltcG9ydGVkRGF0YS5kb2dQcm9maWxlcy51cGRhdGVkQXQgfHwgMDtcbiAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUaW1lc3RhbXAgPSBleGlzdGluZ1Byb2ZpbGVzLnVwZGF0ZWRBdCB8fCAwO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKGltcG9ydGVkVGltZXN0YW1wID4gZXhpc3RpbmdUaW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRQcm9maWxlcy5wcm9maWxlc1tpZF0gPSBwcm9maWxlIGFzIERvZ1Byb2ZpbGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEZvciAnbWVyZ2UnIHN0cmF0ZWd5LCBhbHdheXMgdXBkYXRlXG4gICAgICAgICAgICAgIG1lcmdlZFByb2ZpbGVzLnByb2ZpbGVzW2lkXSA9IHByb2ZpbGUgYXMgRG9nUHJvZmlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTYXZlIG1lcmdlZCBwcm9maWxlc1xuICAgICAgICAgIHNhdmVUb1N0b3JhZ2UoU3RvcmFnZUtleS5ET0dfUFJPRklMRVMsIG1lcmdlZFByb2ZpbGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBleGlzdGluZyBwcm9maWxlcywganVzdCBpbXBvcnRcbiAgICAgICAgICBzYXZlVG9TdG9yYWdlKFN0b3JhZ2VLZXkuRE9HX1BST0ZJTEVTLCBpbXBvcnRlZERhdGEuZG9nUHJvZmlsZXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIHJlY29tbWVuZGF0aW9ucyB3aXRoIHNpbWlsYXIgbWVyZ2Ugc3RyYXRlZ3lcbiAgICBpZiAoaW1wb3J0ZWREYXRhLnNhdmVkUmVjb21tZW5kYXRpb25zPy5kYXRhPy5yZWNvbW1lbmRhdGlvbnMpIHtcbiAgICAgIGlmIChtZXJnZVN0cmF0ZWd5ID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgc2F2ZVRvU3RvcmFnZShTdG9yYWdlS2V5LlNBVkVEX1JFQ09NTUVOREFUSU9OUywgaW1wb3J0ZWREYXRhLnNhdmVkUmVjb21tZW5kYXRpb25zLmRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdSZWNvbW1lbmRhdGlvbnMgPSBsb2FkUmVjb21tZW5kYXRpb25zKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZXhpc3RpbmdSZWNvbW1lbmRhdGlvbnM/LmRhdGE/LnJlY29tbWVuZGF0aW9ucykge1xuICAgICAgICAgIGNvbnN0IG1lcmdlZFJlY29tbWVuZGF0aW9ucyA9IHsgXG4gICAgICAgICAgICByZWNvbW1lbmRhdGlvbnM6IHsgLi4uZXhpc3RpbmdSZWNvbW1lbmRhdGlvbnMuZGF0YS5yZWNvbW1lbmRhdGlvbnMgfSxcbiAgICAgICAgICAgIHNhdmVkRGF0ZXM6IHsgLi4uZXhpc3RpbmdSZWNvbW1lbmRhdGlvbnMuZGF0YS5zYXZlZERhdGVzIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFByb2Nlc3MgZWFjaCBpbXBvcnRlZCByZWNvbW1lbmRhdGlvblxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGltcG9ydGVkRGF0YS5zYXZlZFJlY29tbWVuZGF0aW9ucy5kYXRhLnJlY29tbWVuZGF0aW9ucykuZm9yRWFjaCgoW2lkLCByZWNvbW1lbmRhdGlvbl0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUmVjb21tZW5kYXRpb24gPSBtZXJnZWRSZWNvbW1lbmRhdGlvbnMucmVjb21tZW5kYXRpb25zW2lkXTtcbiAgICAgICAgICAgIGNvbnN0IGltcG9ydGVkU2F2ZWREYXRlID0gaW1wb3J0ZWREYXRhLnNhdmVkUmVjb21tZW5kYXRpb25zLmRhdGEuc2F2ZWREYXRlcz8uW2lkXSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdTYXZlZERhdGUgPSBtZXJnZWRSZWNvbW1lbmRhdGlvbnMuc2F2ZWREYXRlc1tpZF0gfHwgMDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFleGlzdGluZ1JlY29tbWVuZGF0aW9uKSB7XG4gICAgICAgICAgICAgIC8vIFJlY29tbWVuZGF0aW9uIGRvZXNuJ3QgZXhpc3QsIGFkZCBpdFxuICAgICAgICAgICAgICBtZXJnZWRSZWNvbW1lbmRhdGlvbnMucmVjb21tZW5kYXRpb25zW2lkXSA9IHJlY29tbWVuZGF0aW9uIGFzIEZvb2RSZWNvbW1lbmRhdGlvbjtcbiAgICAgICAgICAgICAgbWVyZ2VkUmVjb21tZW5kYXRpb25zLnNhdmVkRGF0ZXNbaWRdID0gaW1wb3J0ZWRTYXZlZERhdGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmdlU3RyYXRlZ3kgPT09ICdrZWVwLW5ld2VyJyAmJiBpbXBvcnRlZFNhdmVkRGF0ZSA+IGV4aXN0aW5nU2F2ZWREYXRlKSB7XG4gICAgICAgICAgICAgIC8vICdrZWVwLW5ld2VyJyBzdHJhdGVneSAtIHVwZGF0ZSBpZiBpbXBvcnRlZCBpcyBuZXdlclxuICAgICAgICAgICAgICBtZXJnZWRSZWNvbW1lbmRhdGlvbnMucmVjb21tZW5kYXRpb25zW2lkXSA9IHJlY29tbWVuZGF0aW9uIGFzIEZvb2RSZWNvbW1lbmRhdGlvbjtcbiAgICAgICAgICAgICAgbWVyZ2VkUmVjb21tZW5kYXRpb25zLnNhdmVkRGF0ZXNbaWRdID0gaW1wb3J0ZWRTYXZlZERhdGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1lcmdlU3RyYXRlZ3kgPT09ICdtZXJnZScpIHtcbiAgICAgICAgICAgICAgLy8gJ21lcmdlJyBzdHJhdGVneSAtIGFsd2F5cyB1cGRhdGVcbiAgICAgICAgICAgICAgbWVyZ2VkUmVjb21tZW5kYXRpb25zLnJlY29tbWVuZGF0aW9uc1tpZF0gPSByZWNvbW1lbmRhdGlvbiBhcyBGb29kUmVjb21tZW5kYXRpb247XG4gICAgICAgICAgICAgIG1lcmdlZFJlY29tbWVuZGF0aW9ucy5zYXZlZERhdGVzW2lkXSA9IGltcG9ydGVkU2F2ZWREYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNhdmUgbWVyZ2VkIHJlY29tbWVuZGF0aW9uc1xuICAgICAgICAgIHNhdmVUb1N0b3JhZ2UoU3RvcmFnZUtleS5TQVZFRF9SRUNPTU1FTkRBVElPTlMsIG1lcmdlZFJlY29tbWVuZGF0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gZXhpc3RpbmcgcmVjb21tZW5kYXRpb25zLCBqdXN0IGltcG9ydFxuICAgICAgICAgIHNhdmVUb1N0b3JhZ2UoU3RvcmFnZUtleS5TQVZFRF9SRUNPTU1FTkRBVElPTlMsIGltcG9ydGVkRGF0YS5zYXZlZFJlY29tbWVuZGF0aW9ucy5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgdXNlciBwcmVmZXJlbmNlc1xuICAgIGlmIChpbXBvcnRlZERhdGEudXNlclByZWZlcmVuY2VzPy5kYXRhKSB7XG4gICAgICBpZiAobWVyZ2VTdHJhdGVneSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgIHNhdmVUb1N0b3JhZ2UoU3RvcmFnZUtleS5VU0VSX1BSRUZFUkVOQ0VTLCBpbXBvcnRlZERhdGEudXNlclByZWZlcmVuY2VzLmRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQcmVmZXJlbmNlcyA9IGxvYWRGcm9tU3RvcmFnZTxVc2VyUHJlZmVyZW5jZXNTdG9yYWdlU2NoZW1hWydkYXRhJ10+KFxuICAgICAgICAgIFN0b3JhZ2VLZXkuVVNFUl9QUkVGRVJFTkNFUyxcbiAgICAgICAgICBERUZBVUxUX1VTRVJfUFJFRkVSRU5DRVNfU1RPUkFHRVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgaWYgKGV4aXN0aW5nUHJlZmVyZW5jZXM/LmRhdGEpIHtcbiAgICAgICAgICBpZiAobWVyZ2VTdHJhdGVneSA9PT0gJ2tlZXAtbmV3ZXInKSB7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnRlZFRpbWVzdGFtcCA9IGltcG9ydGVkRGF0YS51c2VyUHJlZmVyZW5jZXMudXBkYXRlZEF0IHx8IDA7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1RpbWVzdGFtcCA9IGV4aXN0aW5nUHJlZmVyZW5jZXMudXBkYXRlZEF0IHx8IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChpbXBvcnRlZFRpbWVzdGFtcCA+IGV4aXN0aW5nVGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgIHNhdmVUb1N0b3JhZ2UoU3RvcmFnZUtleS5VU0VSX1BSRUZFUkVOQ0VTLCBpbXBvcnRlZERhdGEudXNlclByZWZlcmVuY2VzLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGb3IgJ21lcmdlJyBzdHJhdGVneSwgbWVyZ2Ugb2JqZWN0c1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkUHJlZmVyZW5jZXMgPSB7XG4gICAgICAgICAgICAgIC4uLmV4aXN0aW5nUHJlZmVyZW5jZXMuZGF0YSxcbiAgICAgICAgICAgICAgLi4uaW1wb3J0ZWREYXRhLnVzZXJQcmVmZXJlbmNlcy5kYXRhXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2F2ZVRvU3RvcmFnZShTdG9yYWdlS2V5LlVTRVJfUFJFRkVSRU5DRVMsIG1lcmdlZFByZWZlcmVuY2VzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gZXhpc3RpbmcgcHJlZmVyZW5jZXMsIGp1c3QgaW1wb3J0XG4gICAgICAgICAgc2F2ZVRvU3RvcmFnZShTdG9yYWdlS2V5LlVTRVJfUFJFRkVSRU5DRVMsIGltcG9ydGVkRGF0YS51c2VyUHJlZmVyZW5jZXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sICdpbXBvcnREYXRhV2l0aFN0cmF0ZWd5JywgU3RvcmFnZUVycm9yVHlwZS5JTVBPUlRfRVJST1IpO1xuICBcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXQgc3RhdGlzdGljcyBhYm91dCBzdG9yYWdlIHVzYWdlIGFuZCBpdGVtIGNvdW50c1xuICogQHJldHVybnMgT2JqZWN0IHdpdGggc3RvcmFnZSB1c2FnZSBzdGF0aXN0aWNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdG9yYWdlU3RhdHMoKToge1xuICB1c2FnZTogeyB1c2VkOiBudW1iZXI7IGF2YWlsYWJsZT86IG51bWJlcjsgcGVyY2VudFVzZWQ/OiBudW1iZXIgfTtcbiAgY291bnRzOiB7IGRvZ1Byb2ZpbGVzOiBudW1iZXI7IHNhdmVkUmVjb21tZW5kYXRpb25zOiBudW1iZXI7IGJhY2t1cHM6IG51bWJlciB9O1xuICBsYXN0VXBkYXRlZDogeyBkb2dQcm9maWxlcz86IG51bWJlcjsgc2F2ZWRSZWNvbW1lbmRhdGlvbnM/OiBudW1iZXI7IGJhY2t1cHM/OiBudW1iZXIgfTtcbn0ge1xuICBjb25zdCB7IHJlc3VsdCwgZXJyb3IgfSA9IHRyeUNhdGNoU3RvcmFnZSgoKSA9PiB7XG4gICAgLy8gR2V0IHN0b3JhZ2UgdXNhZ2VcbiAgICBjb25zdCB1c2FnZSA9IGdldFN0b3JhZ2VVc2FnZSgpO1xuICAgIFxuICAgIC8vIENvdW50IGl0ZW1zXG4gICAgY29uc3QgZG9nUHJvZmlsZXMgPSBsb2FkRG9nUHJvZmlsZXMoKTtcbiAgICBjb25zdCBzYXZlZFJlY29tbWVuZGF0aW9ucyA9IGxvYWRSZWNvbW1lbmRhdGlvbnMoKTtcbiAgICBcbiAgICAvLyBDb3VudCBiYWNrdXBzXG4gICAgbGV0IGJhY2t1cENvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgIGlmIChrZXkgJiYga2V5LnN0YXJ0c1dpdGgoU3RvcmFnZUtleS5CQUNLVVBfUFJFRklYKSAmJiAha2V5LmluY2x1ZGVzKFN0b3JhZ2VLZXkuRE9HX1BST0ZJTEVTKSAmJiBcbiAgICAgICAgICAha2V5LmluY2x1ZGVzKFN0b3JhZ2VLZXkuU0FWRURfUkVDT01NRU5EQVRJT05TKSAmJiAha2V5LmluY2x1ZGVzKFN0b3JhZ2VLZXkuVVNFUl9QUkVGRVJFTkNFUykpIHtcbiAgICAgICAgYmFja3VwQ291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gR2V0IHByb2ZpbGUgYW5kIHJlY29tbWVuZGF0aW9uIGNvdW50c1xuICAgIGNvbnN0IHByb2ZpbGVDb3VudCA9IGRvZ1Byb2ZpbGVzPy5kYXRhPy5wcm9maWxlcyA/IE9iamVjdC5rZXlzKGRvZ1Byb2ZpbGVzLmRhdGEucHJvZmlsZXMpLmxlbmd0aCA6IDA7XG4gICAgY29uc3QgcmVjb21tZW5kYXRpb25Db3VudCA9IHNhdmVkUmVjb21tZW5kYXRpb25zPy5kYXRhPy5yZWNvbW1lbmRhdGlvbnMgXG4gICAgICA/IE9iamVjdC5rZXlzKHNhdmVkUmVjb21tZW5kYXRpb25zLmRhdGEucmVjb21tZW5kYXRpb25zKS5sZW5ndGggXG4gICAgICA6IDA7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHVzYWdlLFxuICAgICAgY291bnRzOiB7XG4gICAgICAgIGRvZ1Byb2ZpbGVzOiBwcm9maWxlQ291bnQsXG4gICAgICAgIHNhdmVkUmVjb21tZW5kYXRpb25zOiByZWNvbW1lbmRhdGlvbkNvdW50LFxuICAgICAgICBiYWNrdXBzOiBiYWNrdXBDb3VudFxuICAgICAgfSxcbiAgICAgIGxhc3RVcGRhdGVkOiB7XG4gICAgICAgIGRvZ1Byb2ZpbGVzOiBkb2dQcm9maWxlcz8udXBkYXRlZEF0LFxuICAgICAgICBzYXZlZFJlY29tbWVuZGF0aW9uczogc2F2ZWRSZWNvbW1lbmRhdGlvbnM/LnVwZGF0ZWRBdCxcbiAgICAgICAgYmFja3VwczogZ2V0TGF0ZXN0QmFja3VwVGltZXN0YW1wKClcbiAgICAgIH1cbiAgICB9O1xuICB9LCAnZ2V0U3RvcmFnZVN0YXRzJyk7XG4gIFxuICByZXR1cm4gcmVzdWx0IHx8IHtcbiAgICB1c2FnZTogeyB1c2VkOiAwIH0sXG4gICAgY291bnRzOiB7IGRvZ1Byb2ZpbGVzOiAwLCBzYXZlZFJlY29tbWVuZGF0aW9uczogMCwgYmFja3VwczogMCB9LFxuICAgIGxhc3RVcGRhdGVkOiB7fVxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgdGltZXN0YW1wIG9mIHRoZSBtb3N0IHJlY2VudCBiYWNrdXBcbiAqIEByZXR1cm5zIFRpbWVzdGFtcCBvZiB0aGUgbW9zdCByZWNlbnQgYmFja3VwLCBvciB1bmRlZmluZWQgaWYgbm9uZSBleGlzdHNcbiAqL1xuZnVuY3Rpb24gZ2V0TGF0ZXN0QmFja3VwVGltZXN0YW1wKCk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHsgcmVzdWx0IH0gPSB0cnlDYXRjaFN0b3JhZ2UoKCkgPT4ge1xuICAgIGxldCBsYXRlc3RUaW1lc3RhbXA6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgIGlmIChrZXkgJiYga2V5LnN0YXJ0c1dpdGgoU3RvcmFnZUtleS5CQUNLVVBfUFJFRklYKSAmJiAha2V5LmluY2x1ZGVzKFN0b3JhZ2VLZXkuRE9HX1BST0ZJTEVTKSAmJiBcbiAgICAgICAgICAha2V5LmluY2x1ZGVzKFN0b3JhZ2VLZXkuU0FWRURfUkVDT01NRU5EQVRJT05TKSAmJiAha2V5LmluY2x1ZGVzKFN0b3JhZ2VLZXkuVVNFUl9QUkVGRVJFTkNFUykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBwYXJzZUludChrZXkucmVwbGFjZShTdG9yYWdlS2V5LkJBQ0tVUF9QUkVGSVgsICcnKSwgMTApO1xuICAgICAgICAgIGlmICghaXNOYU4odGltZXN0YW1wKSAmJiAoIWxhdGVzdFRpbWVzdGFtcCB8fCB0aW1lc3RhbXAgPiBsYXRlc3RUaW1lc3RhbXApKSB7XG4gICAgICAgICAgICBsYXRlc3RUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGxhdGVzdFRpbWVzdGFtcDtcbiAgfSwgJ2dldExhdGVzdEJhY2t1cFRpbWVzdGFtcCcpO1xuICBcbiAgcmV0dXJuIHJlc3VsdCB8fCB1bmRlZmluZWQ7XG59ICJdLCJuYW1lcyI6WyJTQ0hFTUFfVkVSU0lPTiIsIlN0b3JhZ2VLZXkiLCJERUZBVUxUX0RPR19QUk9GSUxFU19TVE9SQUdFIiwiREVGQVVMVF9TQVZFRF9SRUNPTU1FTkRBVElPTlNfU1RPUkFHRSIsIkRFRkFVTFRfVVNFUl9QUkVGRVJFTkNFU19TVE9SQUdFIiwiU3RvcmFnZUVycm9yIiwiU3RvcmFnZUVycm9yVHlwZSIsImhhbmRsZVN0b3JhZ2VFcnJvciIsInRyeUNhdGNoU3RvcmFnZSIsImlzU3RvcmFnZUF2YWlsYWJsZSIsInRlc3RLZXkiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwicmVzdWx0IiwiZ2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJlIiwiZ2V0U3RvcmFnZVVzYWdlIiwiZXJyb3IiLCJ0b3RhbFNpemUiLCJpIiwibGVuZ3RoIiwia2V5IiwidmFsdWUiLCJ1c2VkQnl0ZXMiLCJlc3RpbWF0ZWRMaW1pdCIsInVzZWQiLCJhdmFpbGFibGUiLCJwZXJjZW50VXNlZCIsImlzU3RvcmFnZU5lYXJseUZ1bGwiLCJ0aHJlc2hvbGRQZXJjZW50IiwidXNhZ2UiLCJzYXZlVG9TdG9yYWdlIiwiZGF0YSIsIlNUT1JBR0VfVU5BVkFJTEFCTEUiLCJjb25zb2xlIiwid2FybiIsInN0b3JhZ2VEYXRhIiwidmVyc2lvbiIsInVwZGF0ZWRBdCIsIkRhdGUiLCJub3ciLCJKU09OIiwic3RyaW5naWZ5IiwiRXJyb3IiLCJuYW1lIiwiU1RPUkFHRV9RVU9UQV9FWENFRURFRCIsIm9yaWdpbmFsRXJyb3IiLCJXUklURV9FUlJPUiIsImxvYWRGcm9tU3RvcmFnZSIsImRlZmF1bHRWYWx1ZSIsInNlcmlhbGl6ZWQiLCJwYXJzZWREYXRhIiwicGFyc2UiLCJiYWNrdXBSZXN1bHQiLCJ0cnlSZXN0b3JlSXRlbUZyb21CYWNrdXAiLCJzdWNjZXNzIiwicGFyc2VkQmFja3VwIiwiYmFja3VwS2V5IiwiQkFDS1VQX1BSRUZJWCIsImJhY2t1cERhdGEiLCJjcmVhdGVCYWNrdXAiLCJ0aW1lc3RhbXAiLCJiYWNrdXAiLCJkb2dQcm9maWxlcyIsIkRPR19QUk9GSUxFUyIsInNhdmVkUmVjb21tZW5kYXRpb25zIiwiU0FWRURfUkVDT01NRU5EQVRJT05TIiwidXNlclByZWZlcmVuY2VzIiwiVVNFUl9QUkVGRVJFTkNFUyIsIkJBQ0tVUF9FUlJPUiIsInJlc3RvcmVGcm9tQmFja3VwIiwibGF0ZXN0QmFja3VwS2V5IiwibGF0ZXN0VGltZXN0YW1wIiwic3RhcnRzV2l0aCIsImluY2x1ZGVzIiwicGFyc2VJbnQiLCJyZXBsYWNlIiwiaXNOYU4iLCJSRVNUT1JFX0VSUk9SIiwic2VyaWFsaXplZEJhY2t1cCIsImNsZWFudXBPbGRCYWNrdXBzIiwia2VlcENvdW50IiwiYmFja3VwcyIsInB1c2giLCJzb3J0IiwiYSIsImIiLCJyZW1vdmVkQ291bnQiLCJ0b1JlbW92ZSIsInNsaWNlIiwiZm9yRWFjaCIsInNhdmVEb2dQcm9maWxlcyIsInByb2ZpbGVzIiwiYWN0aXZlUHJvZmlsZUlkIiwibG9hZERvZ1Byb2ZpbGVzIiwic2F2ZVJlY29tbWVuZGF0aW9ucyIsInJlY29tbWVuZGF0aW9ucyIsInNhdmVkRGF0ZXMiLCJPYmplY3QiLCJrZXlzIiwiaWQiLCJsb2FkUmVjb21tZW5kYXRpb25zIiwiZXhwb3J0RGF0YSIsInNjaGVtYVZlcnNpb24iLCJleHBvcnREYXRlIiwidG9JU09TdHJpbmciLCJFWFBPUlRfRVJST1IiLCJpbXBvcnREYXRhIiwianNvbkRhdGEiLCJpbXBvcnREYXRhV2l0aFN0cmF0ZWd5IiwiY2xlYW51cFN0b3JhZ2UiLCJvbGRlclRoYW5EYXlzIiwib2xkQmFja3VwcyIsInRvdGFsIiwiYWdlVGhyZXNob2xkIiwicmVtb3ZlZFJlY29tbWVuZGF0aW9ucyIsInVwZGF0ZWRSZWNvbW1lbmRhdGlvbnMiLCJ1cGRhdGVkU2F2ZWREYXRlcyIsImVudHJpZXMiLCJyZWNvbW1lbmRhdGlvbiIsInNhdmVkRGF0ZSIsInRvdGFsUmVtb3ZlZCIsIkNMRUFOVVBfRVJST1IiLCJkb3dubG9hZEV4cG9ydGVkRGF0YSIsImZpbGVuYW1lIiwiZXhwb3J0U3RyaW5nIiwiYmxvYiIsIkJsb2IiLCJ0eXBlIiwidXJsIiwiVVJMIiwiY3JlYXRlT2JqZWN0VVJMIiwibGluayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImhyZWYiLCJkb3dubG9hZCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNsaWNrIiwic2V0VGltZW91dCIsInJldm9rZU9iamVjdFVSTCIsInJlbW92ZUNoaWxkIiwiaW1wb3J0RGF0YUZyb21GaWxlIiwiZmlsZSIsIm1lcmdlU3RyYXRlZ3kiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJldmVudCIsInRhcmdldCIsIm9uZXJyb3IiLCJyZWFkQXNUZXh0IiwiaW1wb3J0ZWREYXRhIiwiSU1QT1JUX0VSUk9SIiwiZXhpc3RpbmdQcm9maWxlcyIsIm1lcmdlZFByb2ZpbGVzIiwicHJvZmlsZSIsImV4aXN0aW5nUHJvZmlsZSIsImltcG9ydGVkVGltZXN0YW1wIiwiZXhpc3RpbmdUaW1lc3RhbXAiLCJleGlzdGluZ1JlY29tbWVuZGF0aW9ucyIsIm1lcmdlZFJlY29tbWVuZGF0aW9ucyIsImV4aXN0aW5nUmVjb21tZW5kYXRpb24iLCJpbXBvcnRlZFNhdmVkRGF0ZSIsImV4aXN0aW5nU2F2ZWREYXRlIiwiZXhpc3RpbmdQcmVmZXJlbmNlcyIsIm1lcmdlZFByZWZlcmVuY2VzIiwiZ2V0U3RvcmFnZVN0YXRzIiwiYmFja3VwQ291bnQiLCJwcm9maWxlQ291bnQiLCJyZWNvbW1lbmRhdGlvbkNvdW50IiwiY291bnRzIiwibGFzdFVwZGF0ZWQiLCJnZXRMYXRlc3RCYWNrdXBUaW1lc3RhbXAiLCJ1bmRlZmluZWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/storageUtils.ts\n"));

/***/ })

});