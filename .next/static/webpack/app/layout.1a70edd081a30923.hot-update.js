"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/context/DogProfileContext.tsx":
/*!*******************************************!*\
  !*** ./src/context/DogProfileContext.tsx ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DogProfilesProvider: () => (/* binding */ DogProfilesProvider),\n/* harmony export */   useDogProfiles: () => (/* binding */ useDogProfiles)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _types_dogProfile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../types/dogProfile */ \"(app-pages-browser)/./src/types/dogProfile.ts\");\n/* harmony import */ var _utils_localStorage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/localStorage */ \"(app-pages-browser)/./src/utils/localStorage.ts\");\n/* __next_internal_client_entry_do_not_use__ DogProfilesProvider,useDogProfiles auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n/**\n * Initial state for dog profiles\n */ const initialDogProfilesState = {\n    profiles: [],\n    currentProfile: null,\n    initialized: false\n};\n/**\n * Dog profiles context for providing access to dog profile data\n */ const DogProfilesContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\n/**\n * Generate a unique ID for a dog profile\n */ const generateId = ()=>{\n    return Math.random().toString(36).substring(2, 9);\n};\n/**\n * Provider component for dog profiles context\n */ function DogProfilesProvider(param) {\n    let { children } = param;\n    _s();\n    // State for dog profiles\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialDogProfilesState);\n    const [storageAvailable] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)((0,_utils_localStorage__WEBPACK_IMPORTED_MODULE_3__.isLocalStorageAvailable)());\n    // Load profiles from local storage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"DogProfilesProvider.useEffect\": ()=>{\n            if (!storageAvailable) {\n                console.warn('Local storage is not available. Dog profiles will not persist.');\n                setState({\n                    \"DogProfilesProvider.useEffect\": (prev)=>({\n                            ...prev,\n                            initialized: true\n                        })\n                }[\"DogProfilesProvider.useEffect\"]);\n                return;\n            }\n            try {\n                const savedState = (0,_utils_localStorage__WEBPACK_IMPORTED_MODULE_3__.loadFromLocalStorage)(_utils_localStorage__WEBPACK_IMPORTED_MODULE_3__.STORAGE_KEYS.DOG_PROFILES, {\n                    ...initialDogProfilesState,\n                    initialized: true\n                });\n                // Validate all loaded profiles\n                const validProfiles = savedState.profiles.filter({\n                    \"DogProfilesProvider.useEffect.validProfiles\": (profile)=>{\n                        const validation = (0,_types_dogProfile__WEBPACK_IMPORTED_MODULE_2__.validateDogProfile)(profile);\n                        if (!validation.success) {\n                            console.warn(\"Invalid dog profile found in storage:\", profile);\n                        }\n                        return validation.success;\n                    }\n                }[\"DogProfilesProvider.useEffect.validProfiles\"]);\n                setState({\n                    profiles: validProfiles,\n                    currentProfile: savedState.currentProfile,\n                    initialized: true\n                });\n            } catch (error) {\n                console.error('Error loading dog profiles from storage:', error);\n                setState({\n                    \"DogProfilesProvider.useEffect\": (prev)=>({\n                            ...prev,\n                            initialized: true\n                        })\n                }[\"DogProfilesProvider.useEffect\"]);\n            }\n        }\n    }[\"DogProfilesProvider.useEffect\"], [\n        storageAvailable\n    ]);\n    // Save profiles to local storage whenever they change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"DogProfilesProvider.useEffect\": ()=>{\n            // Skip initial save before data is initialized\n            if (!state.initialized || !storageAvailable) return;\n            (0,_utils_localStorage__WEBPACK_IMPORTED_MODULE_3__.saveToLocalStorage)(_utils_localStorage__WEBPACK_IMPORTED_MODULE_3__.STORAGE_KEYS.DOG_PROFILES, state);\n        }\n    }[\"DogProfilesProvider.useEffect\"], [\n        state,\n        storageAvailable\n    ]);\n    /**\n   * Add a new dog profile\n   */ const addProfile = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"DogProfilesProvider.useCallback[addProfile]\": (profile)=>{\n            const id = profile.id || generateId();\n            const newProfile = {\n                ...profile,\n                id,\n                createdAt: new Date(),\n                updatedAt: new Date()\n            };\n            // Validate the profile before adding\n            const validation = (0,_types_dogProfile__WEBPACK_IMPORTED_MODULE_2__.validateDogProfile)(newProfile);\n            if (!validation.success) {\n                var _validation_errors;\n                throw new Error(\"Invalid dog profile: \".concat((_validation_errors = validation.errors) === null || _validation_errors === void 0 ? void 0 : _validation_errors.toString()));\n            }\n            setState({\n                \"DogProfilesProvider.useCallback[addProfile]\": (prevState)=>({\n                        ...prevState,\n                        profiles: [\n                            ...prevState.profiles,\n                            newProfile\n                        ],\n                        // If this is the first profile, set it as current\n                        currentProfile: prevState.profiles.length === 0 ? newProfile : prevState.currentProfile\n                    })\n            }[\"DogProfilesProvider.useCallback[addProfile]\"]);\n            return id;\n        }\n    }[\"DogProfilesProvider.useCallback[addProfile]\"], []);\n    /**\n   * Update an existing dog profile\n   */ const updateProfile = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"DogProfilesProvider.useCallback[updateProfile]\": (id, profileUpdate)=>{\n            let updated = false;\n            setState({\n                \"DogProfilesProvider.useCallback[updateProfile]\": (prevState)=>{\n                    var _prevState_currentProfile;\n                    const profileIndex = prevState.profiles.findIndex({\n                        \"DogProfilesProvider.useCallback[updateProfile].profileIndex\": (p)=>p.id === id\n                    }[\"DogProfilesProvider.useCallback[updateProfile].profileIndex\"]);\n                    if (profileIndex === -1) return prevState;\n                    const updatedProfile = {\n                        ...prevState.profiles[profileIndex],\n                        ...profileUpdate,\n                        updatedAt: new Date()\n                    };\n                    // Validate the updated profile\n                    const validation = (0,_types_dogProfile__WEBPACK_IMPORTED_MODULE_2__.validateDogProfile)(updatedProfile);\n                    if (!validation.success) {\n                        var _validation_errors;\n                        console.error(\"Invalid profile update: \".concat((_validation_errors = validation.errors) === null || _validation_errors === void 0 ? void 0 : _validation_errors.toString()));\n                        return prevState;\n                    }\n                    const updatedProfiles = [\n                        ...prevState.profiles\n                    ];\n                    updatedProfiles[profileIndex] = updatedProfile;\n                    // Update current profile if it was the one updated\n                    const updatedCurrentProfile = ((_prevState_currentProfile = prevState.currentProfile) === null || _prevState_currentProfile === void 0 ? void 0 : _prevState_currentProfile.id) === id ? updatedProfile : prevState.currentProfile;\n                    updated = true;\n                    return {\n                        ...prevState,\n                        profiles: updatedProfiles,\n                        currentProfile: updatedCurrentProfile\n                    };\n                }\n            }[\"DogProfilesProvider.useCallback[updateProfile]\"]);\n            return updated;\n        }\n    }[\"DogProfilesProvider.useCallback[updateProfile]\"], []);\n    /**\n   * Delete a dog profile\n   */ const deleteProfile = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"DogProfilesProvider.useCallback[deleteProfile]\": (id)=>{\n            let deleted = false;\n            setState({\n                \"DogProfilesProvider.useCallback[deleteProfile]\": (prevState)=>{\n                    var _prevState_currentProfile;\n                    const filteredProfiles = prevState.profiles.filter({\n                        \"DogProfilesProvider.useCallback[deleteProfile].filteredProfiles\": (p)=>p.id !== id\n                    }[\"DogProfilesProvider.useCallback[deleteProfile].filteredProfiles\"]);\n                    // If no profiles were filtered out, the profile doesn't exist\n                    if (filteredProfiles.length === prevState.profiles.length) {\n                        return prevState;\n                    }\n                    deleted = true;\n                    // If the deleted profile was the current one, set currentProfile to null\n                    const updatedCurrentProfile = ((_prevState_currentProfile = prevState.currentProfile) === null || _prevState_currentProfile === void 0 ? void 0 : _prevState_currentProfile.id) === id ? null : prevState.currentProfile;\n                    return {\n                        ...prevState,\n                        profiles: filteredProfiles,\n                        currentProfile: updatedCurrentProfile\n                    };\n                }\n            }[\"DogProfilesProvider.useCallback[deleteProfile]\"]);\n            return deleted;\n        }\n    }[\"DogProfilesProvider.useCallback[deleteProfile]\"], []);\n    /**\n   * Set the currently active dog profile\n   */ const setCurrentProfile = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"DogProfilesProvider.useCallback[setCurrentProfile]\": (id)=>{\n            let success = false;\n            setState({\n                \"DogProfilesProvider.useCallback[setCurrentProfile]\": (prevState)=>{\n                    const profile = prevState.profiles.find({\n                        \"DogProfilesProvider.useCallback[setCurrentProfile].profile\": (p)=>p.id === id\n                    }[\"DogProfilesProvider.useCallback[setCurrentProfile].profile\"]);\n                    if (!profile) return prevState;\n                    success = true;\n                    return {\n                        ...prevState,\n                        currentProfile: profile\n                    };\n                }\n            }[\"DogProfilesProvider.useCallback[setCurrentProfile]\"]);\n            return success;\n        }\n    }[\"DogProfilesProvider.useCallback[setCurrentProfile]\"], []);\n    /**\n   * Clear the currently active dog profile\n   */ const clearCurrentProfile = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"DogProfilesProvider.useCallback[clearCurrentProfile]\": ()=>{\n            setState({\n                \"DogProfilesProvider.useCallback[clearCurrentProfile]\": (prevState)=>({\n                        ...prevState,\n                        currentProfile: null\n                    })\n            }[\"DogProfilesProvider.useCallback[clearCurrentProfile]\"]);\n        }\n    }[\"DogProfilesProvider.useCallback[clearCurrentProfile]\"], []);\n    /**\n   * Sort profiles by a given field\n   */ const sortProfiles = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"DogProfilesProvider.useCallback[sortProfiles]\": function(field) {\n            let ascending = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;\n            return [\n                ...state.profiles\n            ].sort({\n                \"DogProfilesProvider.useCallback[sortProfiles]\": (a, b)=>{\n                    const aValue = a[field];\n                    const bValue = b[field];\n                    if (aValue === undefined || bValue === undefined) return 0;\n                    if (typeof aValue === 'string' && typeof bValue === 'string') {\n                        return ascending ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);\n                    }\n                    if (aValue instanceof Date && bValue instanceof Date) {\n                        return ascending ? aValue.getTime() - bValue.getTime() : bValue.getTime() - aValue.getTime();\n                    }\n                    if (typeof aValue === 'number' && typeof bValue === 'number') {\n                        return ascending ? aValue - bValue : bValue - aValue;\n                    }\n                    return 0;\n                }\n            }[\"DogProfilesProvider.useCallback[sortProfiles]\"]);\n        }\n    }[\"DogProfilesProvider.useCallback[sortProfiles]\"], [\n        state.profiles\n    ]);\n    /**\n   * Filter profiles by a given criteria\n   */ const filterProfiles = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"DogProfilesProvider.useCallback[filterProfiles]\": (criteria)=>{\n            return state.profiles.filter({\n                \"DogProfilesProvider.useCallback[filterProfiles]\": (profile)=>{\n                    return Object.entries(criteria).every({\n                        \"DogProfilesProvider.useCallback[filterProfiles]\": (param)=>{\n                            let [key, value] = param;\n                            const profileValue = profile[key];\n                            // Handle arrays (like healthConditions)\n                            if (Array.isArray(value) && Array.isArray(profileValue)) {\n                                return value.every({\n                                    \"DogProfilesProvider.useCallback[filterProfiles]\": (v)=>profileValue.includes(v)\n                                }[\"DogProfilesProvider.useCallback[filterProfiles]\"]);\n                            }\n                            return profileValue === value;\n                        }\n                    }[\"DogProfilesProvider.useCallback[filterProfiles]\"]);\n                }\n            }[\"DogProfilesProvider.useCallback[filterProfiles]\"]);\n        }\n    }[\"DogProfilesProvider.useCallback[filterProfiles]\"], [\n        state.profiles\n    ]);\n    // Combine state and actions\n    const value = {\n        ...state,\n        addProfile,\n        updateProfile,\n        deleteProfile,\n        setCurrentProfile,\n        clearCurrentProfile,\n        sortProfiles,\n        filterProfiles\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(DogProfilesContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/jonathanmahrtguyou/Desktop/JoMaGuy Projects/PetFood/src/context/DogProfileContext.tsx\",\n        lineNumber: 350,\n        columnNumber: 5\n    }, this);\n}\n_s(DogProfilesProvider, \"0uCByXTaVlKzuCKMxS8yP/dkY0A=\");\n_c = DogProfilesProvider;\n/**\n * Custom hook to use the dog profiles context\n * @returns Dog profiles context state and actions\n * @throws Error if used outside of a DogProfilesProvider\n */ function useDogProfiles() {\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(DogProfilesContext);\n    if (context === undefined) {\n        throw new Error('useDogProfiles must be used within a DogProfilesProvider');\n    }\n    return context;\n}\n_s1(useDogProfiles, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nvar _c;\n$RefreshReg$(_c, \"DogProfilesProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0L0RvZ1Byb2ZpbGVDb250ZXh0LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFK0Y7QUFDTDtBQUM4QjtBQThEeEg7O0NBRUMsR0FDRCxNQUFNVSwwQkFBNEM7SUFDaERDLFVBQVUsRUFBRTtJQUNaQyxnQkFBZ0I7SUFDaEJDLGFBQWE7QUFDZjtBQU9BOztDQUVDLEdBQ0QsTUFBTUMsbUNBQXFCZCxvREFBYUEsQ0FBcUNlO0FBUzdFOztDQUVDLEdBQ0QsTUFBTUMsYUFBYTtJQUNqQixPQUFPQyxLQUFLQyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxTQUFTLENBQUMsR0FBRztBQUNqRDtBQUVBOztDQUVDLEdBQ00sU0FBU0Msb0JBQW9CLEtBQXNDO1FBQXRDLEVBQUVDLFFBQVEsRUFBNEIsR0FBdEM7O0lBQ2xDLHlCQUF5QjtJQUN6QixNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR3RCLCtDQUFRQSxDQUFtQlE7SUFDckQsTUFBTSxDQUFDZSxpQkFBaUIsR0FBR3ZCLCtDQUFRQSxDQUFVTyw0RUFBdUJBO0lBRXBFLDRDQUE0QztJQUM1Q0wsZ0RBQVNBO3lDQUFDO1lBQ1IsSUFBSSxDQUFDcUIsa0JBQWtCO2dCQUNyQkMsUUFBUUMsSUFBSSxDQUFDO2dCQUNiSDtxREFBU0ksQ0FBQUEsT0FBUzs0QkFBRSxHQUFHQSxJQUFJOzRCQUFFZixhQUFhO3dCQUFLOztnQkFDL0M7WUFDRjtZQUVBLElBQUk7Z0JBQ0YsTUFBTWdCLGFBQWF0Qix5RUFBb0JBLENBQ3JDRCw2REFBWUEsQ0FBQ3dCLFlBQVksRUFDekI7b0JBQUUsR0FBR3BCLHVCQUF1QjtvQkFBRUcsYUFBYTtnQkFBSztnQkFHbEQsK0JBQStCO2dCQUMvQixNQUFNa0IsZ0JBQWdCRixXQUFXbEIsUUFBUSxDQUFDcUIsTUFBTTttRUFBQ0MsQ0FBQUE7d0JBQy9DLE1BQU1DLGFBQWE3QixxRUFBa0JBLENBQUM0Qjt3QkFDdEMsSUFBSSxDQUFD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ZTlDLE9BQU8sQ0FBQzRDLElBQXdCOzRCQUVyRCx3Q0FBd0M7NEJBQ3hDLElBQUlHLE1BQU1DLE9BQU8sQ0FBQ0gsVUFBVUUsTUFBTUMsT0FBTyxDQUFDRixlQUFlO2dDQUN2RCxPQUFPRCxNQUFNRixLQUFLO3VGQUFDTSxDQUFBQSxJQUFLSCxhQUFhSSxRQUFRLENBQUNEOzs0QkFDaEQ7NEJBRUEsT0FBT0gsaUJBQWlCRDt3QkFDMUI7O2dCQUNGOztRQUNGOzBEQUFHO1FBQUN2RCxNQUFNWixRQUFRO0tBQUM7SUFFbkIsNEJBQTRCO0lBQzVCLE1BQU1tRSxRQUFnQztRQUNwQyxHQUFHdkQsS0FBSztRQUNSYztRQUNBVTtRQUNBUztRQUNBRztRQUNBRTtRQUNBQztRQUNBVTtJQUNGO0lBRUEscUJBQ0UsOERBQUMxRCxtQkFBbUJzRSxRQUFRO1FBQUNOLE9BQU9BO2tCQUNqQ3hEOzs7Ozs7QUFHUDtHQTNQZ0JEO0tBQUFBO0FBNlBoQjs7OztDQUlDLEdBQ00sU0FBU2dFOztJQUNkLE1BQU1DLFVBQVVyRixpREFBVUEsQ0FBQ2E7SUFFM0IsSUFBSXdFLFlBQVl2RSxXQUFXO1FBQ3pCLE1BQU0sSUFBSTRCLE1BQU07SUFDbEI7SUFFQSxPQUFPMkM7QUFDVDtJQVJnQkQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb25hdGhhbm1haHJ0Z3V5b3UvRGVza3RvcC9Kb01hR3V5IFByb2plY3RzL1BldEZvb2Qvc3JjL2NvbnRleHQvRG9nUHJvZmlsZUNvbnRleHQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgUmVhY3ROb2RlLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERvZ1Byb2ZpbGUsIERFRkFVTFRfRE9HX1BST0ZJTEUsIHZhbGlkYXRlRG9nUHJvZmlsZSB9IGZyb20gJy4uL3R5cGVzL2RvZ1Byb2ZpbGUnO1xuaW1wb3J0IHsgU1RPUkFHRV9LRVlTLCBsb2FkRnJvbUxvY2FsU3RvcmFnZSwgc2F2ZVRvTG9jYWxTdG9yYWdlLCBpc0xvY2FsU3RvcmFnZUF2YWlsYWJsZSB9IGZyb20gJy4uL3V0aWxzL2xvY2FsU3RvcmFnZSc7XG5cbi8qKlxuICogU3RhdGUgaW50ZXJmYWNlIGZvciB0aGUgZG9nIHByb2ZpbGVzIGNvbnRleHRcbiAqL1xuaW50ZXJmYWNlIERvZ1Byb2ZpbGVzU3RhdGUge1xuICAvKipcbiAgICogQXJyYXkgb2YgYWxsIHNhdmVkIGRvZyBwcm9maWxlc1xuICAgKi9cbiAgcHJvZmlsZXM6IERvZ1Byb2ZpbGVbXTtcbiAgXG4gIC8qKlxuICAgKiBDdXJyZW50bHkgYWN0aXZlIGRvZyBwcm9maWxlXG4gICAqL1xuICBjdXJyZW50UHJvZmlsZTogRG9nUHJvZmlsZSB8IG51bGw7XG5cbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiBkYXRhIGhhcyBiZWVuIGluaXRpYWxpemVkIGZyb20gc3RvcmFnZVxuICAgKi9cbiAgaW5pdGlhbGl6ZWQ6IGJvb2xlYW47XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciB0aGUgYWN0aW9ucyB0aGF0IGNhbiBiZSBwZXJmb3JtZWQgb24gZG9nIHByb2ZpbGVzXG4gKi9cbmludGVyZmFjZSBEb2dQcm9maWxlc0FjdGlvbnMge1xuICAvKipcbiAgICogQWRkIGEgbmV3IGRvZyBwcm9maWxlXG4gICAqL1xuICBhZGRQcm9maWxlOiAocHJvZmlsZTogRG9nUHJvZmlsZSkgPT4gc3RyaW5nO1xuICBcbiAgLyoqXG4gICAqIFVwZGF0ZSBhbiBleGlzdGluZyBkb2cgcHJvZmlsZVxuICAgKi9cbiAgdXBkYXRlUHJvZmlsZTogKGlkOiBzdHJpbmcsIHByb2ZpbGU6IFBhcnRpYWw8RG9nUHJvZmlsZT4pID0+IGJvb2xlYW47XG4gIFxuICAvKipcbiAgICogRGVsZXRlIGEgZG9nIHByb2ZpbGVcbiAgICovXG4gIGRlbGV0ZVByb2ZpbGU6IChpZDogc3RyaW5nKSA9PiBib29sZWFuO1xuICBcbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudGx5IGFjdGl2ZSBkb2cgcHJvZmlsZVxuICAgKi9cbiAgc2V0Q3VycmVudFByb2ZpbGU6IChpZDogc3RyaW5nKSA9PiBib29sZWFuO1xuICBcbiAgLyoqXG4gICAqIENsZWFyIHRoZSBjdXJyZW50bHkgYWN0aXZlIGRvZyBwcm9maWxlXG4gICAqL1xuICBjbGVhckN1cnJlbnRQcm9maWxlOiAoKSA9PiB2b2lkO1xuICBcbiAgLyoqXG4gICAqIFNvcnQgcHJvZmlsZXMgYnkgYSBnaXZlbiBmaWVsZFxuICAgKi9cbiAgc29ydFByb2ZpbGVzOiAoZmllbGQ6IGtleW9mIERvZ1Byb2ZpbGUsIGFzY2VuZGluZz86IGJvb2xlYW4pID0+IERvZ1Byb2ZpbGVbXTtcbiAgXG4gIC8qKlxuICAgKiBGaWx0ZXIgcHJvZmlsZXMgYnkgYSBnaXZlbiBjcml0ZXJpYVxuICAgKi9cbiAgZmlsdGVyUHJvZmlsZXM6IChjcml0ZXJpYTogUGFydGlhbDxEb2dQcm9maWxlPikgPT4gRG9nUHJvZmlsZVtdO1xufVxuXG4vKipcbiAqIEluaXRpYWwgc3RhdGUgZm9yIGRvZyBwcm9maWxlc1xuICovXG5jb25zdCBpbml0aWFsRG9nUHJvZmlsZXNTdGF0ZTogRG9nUHJvZmlsZXNTdGF0ZSA9IHtcbiAgcHJvZmlsZXM6IFtdLFxuICBjdXJyZW50UHJvZmlsZTogbnVsbCxcbiAgaW5pdGlhbGl6ZWQ6IGZhbHNlXG59O1xuXG4vKipcbiAqIENvbWJpbmVkIGludGVyZmFjZSBmb3Igc3RhdGUgYW5kIGFjdGlvbnNcbiAqL1xudHlwZSBEb2dQcm9maWxlc0NvbnRleHRUeXBlID0gRG9nUHJvZmlsZXNTdGF0ZSAmIERvZ1Byb2ZpbGVzQWN0aW9ucztcblxuLyoqXG4gKiBEb2cgcHJvZmlsZXMgY29udGV4dCBmb3IgcHJvdmlkaW5nIGFjY2VzcyB0byBkb2cgcHJvZmlsZSBkYXRhXG4gKi9cbmNvbnN0IERvZ1Byb2ZpbGVzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8RG9nUHJvZmlsZXNDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuLyoqXG4gKiBQcm9wcyBmb3IgdGhlIGRvZyBwcm9maWxlcyBwcm92aWRlciBjb21wb25lbnRcbiAqL1xuaW50ZXJmYWNlIERvZ1Byb2ZpbGVzUHJvdmlkZXJQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdE5vZGU7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSB1bmlxdWUgSUQgZm9yIGEgZG9nIHByb2ZpbGVcbiAqL1xuY29uc3QgZ2VuZXJhdGVJZCA9ICgpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDkpO1xufTtcblxuLyoqXG4gKiBQcm92aWRlciBjb21wb25lbnQgZm9yIGRvZyBwcm9maWxlcyBjb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBEb2dQcm9maWxlc1Byb3ZpZGVyKHsgY2hpbGRyZW4gfTogRG9nUHJvZmlsZXNQcm92aWRlclByb3BzKSB7XG4gIC8vIFN0YXRlIGZvciBkb2cgcHJvZmlsZXNcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTxEb2dQcm9maWxlc1N0YXRlPihpbml0aWFsRG9nUHJvZmlsZXNTdGF0ZSk7XG4gIGNvbnN0IFtzdG9yYWdlQXZhaWxhYmxlXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlKCkpO1xuICBcbiAgLy8gTG9hZCBwcm9maWxlcyBmcm9tIGxvY2FsIHN0b3JhZ2Ugb24gbW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXN0b3JhZ2VBdmFpbGFibGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignTG9jYWwgc3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlLiBEb2cgcHJvZmlsZXMgd2lsbCBub3QgcGVyc2lzdC4nKTtcbiAgICAgIHNldFN0YXRlKHByZXYgPT4gKHsgLi4ucHJldiwgaW5pdGlhbGl6ZWQ6IHRydWUgfSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2F2ZWRTdGF0ZSA9IGxvYWRGcm9tTG9jYWxTdG9yYWdlPERvZ1Byb2ZpbGVzU3RhdGU+KFxuICAgICAgICBTVE9SQUdFX0tFWVMuRE9HX1BST0ZJTEVTLCBcbiAgICAgICAgeyAuLi5pbml0aWFsRG9nUHJvZmlsZXNTdGF0ZSwgaW5pdGlhbGl6ZWQ6IHRydWUgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gVmFsaWRhdGUgYWxsIGxvYWRlZCBwcm9maWxlc1xuICAgICAgY29uc3QgdmFsaWRQcm9maWxlcyA9IHNhdmVkU3RhdGUucHJvZmlsZXMuZmlsdGVyKHByb2ZpbGUgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uID0gdmFsaWRhdGVEb2dQcm9maWxlKHByb2ZpbGUpO1xuICAgICAgICBpZiAoIXZhbGlkYXRpb24uc3VjY2Vzcykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBkb2cgcHJvZmlsZSBmb3VuZCBpbiBzdG9yYWdlOmAsIHByb2ZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZGF0aW9uLnN1Y2Nlc3M7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBwcm9maWxlczogdmFsaWRQcm9maWxlcyxcbiAgICAgICAgY3VycmVudFByb2ZpbGU6IHNhdmVkU3RhdGUuY3VycmVudFByb2ZpbGUsXG4gICAgICAgIGluaXRpYWxpemVkOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBkb2cgcHJvZmlsZXMgZnJvbSBzdG9yYWdlOicsIGVycm9yKTtcbiAgICAgIHNldFN0YXRlKHByZXYgPT4gKHsgLi4ucHJldiwgaW5pdGlhbGl6ZWQ6IHRydWUgfSkpO1xuICAgIH1cbiAgfSwgW3N0b3JhZ2VBdmFpbGFibGVdKTtcbiAgXG4gIC8vIFNhdmUgcHJvZmlsZXMgdG8gbG9jYWwgc3RvcmFnZSB3aGVuZXZlciB0aGV5IGNoYW5nZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFNraXAgaW5pdGlhbCBzYXZlIGJlZm9yZSBkYXRhIGlzIGluaXRpYWxpemVkXG4gICAgaWYgKCFzdGF0ZS5pbml0aWFsaXplZCB8fCAhc3RvcmFnZUF2YWlsYWJsZSkgcmV0dXJuO1xuICAgIFxuICAgIHNhdmVUb0xvY2FsU3RvcmFnZShTVE9SQUdFX0tFWVMuRE9HX1BST0ZJTEVTLCBzdGF0ZSk7XG4gIH0sIFtzdGF0ZSwgc3RvcmFnZUF2YWlsYWJsZV0pO1xuICBcbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBkb2cgcHJvZmlsZVxuICAgKi9cbiAgY29uc3QgYWRkUHJvZmlsZSA9IHVzZUNhbGxiYWNrKChwcm9maWxlOiBEb2dQcm9maWxlKTogc3RyaW5nID0+IHtcbiAgICBjb25zdCBpZCA9IHByb2ZpbGUuaWQgfHwgZ2VuZXJhdGVJZCgpO1xuICAgIGNvbnN0IG5ld1Byb2ZpbGUgPSB7IFxuICAgICAgLi4ucHJvZmlsZSwgXG4gICAgICBpZCwgXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKCkgXG4gICAgfTtcbiAgICBcbiAgICAvLyBWYWxpZGF0ZSB0aGUgcHJvZmlsZSBiZWZvcmUgYWRkaW5nXG4gICAgY29uc3QgdmFsaWRhdGlvbiA9IHZhbGlkYXRlRG9nUHJvZmlsZShuZXdQcm9maWxlKTtcbiAgICBpZiAoIXZhbGlkYXRpb24uc3VjY2Vzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRvZyBwcm9maWxlOiAke3ZhbGlkYXRpb24uZXJyb3JzPy50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICBcbiAgICBzZXRTdGF0ZShwcmV2U3RhdGUgPT4gKHtcbiAgICAgIC4uLnByZXZTdGF0ZSxcbiAgICAgIHByb2ZpbGVzOiBbLi4ucHJldlN0YXRlLnByb2ZpbGVzLCBuZXdQcm9maWxlXSxcbiAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IHByb2ZpbGUsIHNldCBpdCBhcyBjdXJyZW50XG4gICAgICBjdXJyZW50UHJvZmlsZTogcHJldlN0YXRlLnByb2ZpbGVzLmxlbmd0aCA9PT0gMCA/IG5ld1Byb2ZpbGUgOiBwcmV2U3RhdGUuY3VycmVudFByb2ZpbGVcbiAgICB9KSk7XG4gICAgXG4gICAgcmV0dXJuIGlkO1xuICB9LCBbXSk7XG4gIFxuICAvKipcbiAgICogVXBkYXRlIGFuIGV4aXN0aW5nIGRvZyBwcm9maWxlXG4gICAqL1xuICBjb25zdCB1cGRhdGVQcm9maWxlID0gdXNlQ2FsbGJhY2soKGlkOiBzdHJpbmcsIHByb2ZpbGVVcGRhdGU6IFBhcnRpYWw8RG9nUHJvZmlsZT4pOiBib29sZWFuID0+IHtcbiAgICBsZXQgdXBkYXRlZCA9IGZhbHNlO1xuICAgIFxuICAgIHNldFN0YXRlKHByZXZTdGF0ZSA9PiB7XG4gICAgICBjb25zdCBwcm9maWxlSW5kZXggPSBwcmV2U3RhdGUucHJvZmlsZXMuZmluZEluZGV4KHAgPT4gcC5pZCA9PT0gaWQpO1xuICAgICAgXG4gICAgICBpZiAocHJvZmlsZUluZGV4ID09PSAtMSkgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICAgIFxuICAgICAgY29uc3QgdXBkYXRlZFByb2ZpbGUgPSB7XG4gICAgICAgIC4uLnByZXZTdGF0ZS5wcm9maWxlc1twcm9maWxlSW5kZXhdLFxuICAgICAgICAuLi5wcm9maWxlVXBkYXRlLFxuICAgICAgICB1cGRhdGVkQXQ6IG5ldyBEYXRlKClcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIHRoZSB1cGRhdGVkIHByb2ZpbGVcbiAgICAgIGNvbnN0IHZhbGlkYXRpb24gPSB2YWxpZGF0ZURvZ1Byb2ZpbGUodXBkYXRlZFByb2ZpbGUpO1xuICAgICAgaWYgKCF2YWxpZGF0aW9uLnN1Y2Nlc3MpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCBwcm9maWxlIHVwZGF0ZTogJHt2YWxpZGF0aW9uLmVycm9ycz8udG9TdHJpbmcoKX1gKTtcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgdXBkYXRlZFByb2ZpbGVzID0gWy4uLnByZXZTdGF0ZS5wcm9maWxlc107XG4gICAgICB1cGRhdGVkUHJvZmlsZXNbcHJvZmlsZUluZGV4XSA9IHVwZGF0ZWRQcm9maWxlO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgY3VycmVudCBwcm9maWxlIGlmIGl0IHdhcyB0aGUgb25lIHVwZGF0ZWRcbiAgICAgIGNvbnN0IHVwZGF0ZWRDdXJyZW50UHJvZmlsZSA9IFxuICAgICAgICBwcmV2U3RhdGUuY3VycmVudFByb2ZpbGU/LmlkID09PSBpZCBcbiAgICAgICAgICA/IHVwZGF0ZWRQcm9maWxlIFxuICAgICAgICAgIDogcHJldlN0YXRlLmN1cnJlbnRQcm9maWxlO1xuICAgICAgXG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHJldlN0YXRlLFxuICAgICAgICBwcm9maWxlczogdXBkYXRlZFByb2ZpbGVzLFxuICAgICAgICBjdXJyZW50UHJvZmlsZTogdXBkYXRlZEN1cnJlbnRQcm9maWxlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB1cGRhdGVkO1xuICB9LCBbXSk7XG4gIFxuICAvKipcbiAgICogRGVsZXRlIGEgZG9nIHByb2ZpbGVcbiAgICovXG4gIGNvbnN0IGRlbGV0ZVByb2ZpbGUgPSB1c2VDYWxsYmFjaygoaWQ6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG4gICAgXG4gICAgc2V0U3RhdGUocHJldlN0YXRlID0+IHtcbiAgICAgIGNvbnN0IGZpbHRlcmVkUHJvZmlsZXMgPSBwcmV2U3RhdGUucHJvZmlsZXMuZmlsdGVyKHAgPT4gcC5pZCAhPT0gaWQpO1xuICAgICAgXG4gICAgICAvLyBJZiBubyBwcm9maWxlcyB3ZXJlIGZpbHRlcmVkIG91dCwgdGhlIHByb2ZpbGUgZG9lc24ndCBleGlzdFxuICAgICAgaWYgKGZpbHRlcmVkUHJvZmlsZXMubGVuZ3RoID09PSBwcmV2U3RhdGUucHJvZmlsZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgXG4gICAgICAvLyBJZiB0aGUgZGVsZXRlZCBwcm9maWxlIHdhcyB0aGUgY3VycmVudCBvbmUsIHNldCBjdXJyZW50UHJvZmlsZSB0byBudWxsXG4gICAgICBjb25zdCB1cGRhdGVkQ3VycmVudFByb2ZpbGUgPSBcbiAgICAgICAgcHJldlN0YXRlLmN1cnJlbnRQcm9maWxlPy5pZCA9PT0gaWQgXG4gICAgICAgICAgPyBudWxsIFxuICAgICAgICAgIDogcHJldlN0YXRlLmN1cnJlbnRQcm9maWxlO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5wcmV2U3RhdGUsXG4gICAgICAgIHByb2ZpbGVzOiBmaWx0ZXJlZFByb2ZpbGVzLFxuICAgICAgICBjdXJyZW50UHJvZmlsZTogdXBkYXRlZEN1cnJlbnRQcm9maWxlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBkZWxldGVkO1xuICB9LCBbXSk7XG4gIFxuICAvKipcbiAgICogU2V0IHRoZSBjdXJyZW50bHkgYWN0aXZlIGRvZyBwcm9maWxlXG4gICAqL1xuICBjb25zdCBzZXRDdXJyZW50UHJvZmlsZSA9IHVzZUNhbGxiYWNrKChpZDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gICAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICBcbiAgICBzZXRTdGF0ZShwcmV2U3RhdGUgPT4ge1xuICAgICAgY29uc3QgcHJvZmlsZSA9IHByZXZTdGF0ZS5wcm9maWxlcy5maW5kKHAgPT4gcC5pZCA9PT0gaWQpO1xuICAgICAgXG4gICAgICBpZiAoIXByb2ZpbGUpIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICBcbiAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5wcmV2U3RhdGUsXG4gICAgICAgIGN1cnJlbnRQcm9maWxlOiBwcm9maWxlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9LCBbXSk7XG4gIFxuICAvKipcbiAgICogQ2xlYXIgdGhlIGN1cnJlbnRseSBhY3RpdmUgZG9nIHByb2ZpbGVcbiAgICovXG4gIGNvbnN0IGNsZWFyQ3VycmVudFByb2ZpbGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0U3RhdGUocHJldlN0YXRlID0+ICh7XG4gICAgICAuLi5wcmV2U3RhdGUsXG4gICAgICBjdXJyZW50UHJvZmlsZTogbnVsbFxuICAgIH0pKTtcbiAgfSwgW10pO1xuICBcbiAgLyoqXG4gICAqIFNvcnQgcHJvZmlsZXMgYnkgYSBnaXZlbiBmaWVsZFxuICAgKi9cbiAgY29uc3Qgc29ydFByb2ZpbGVzID0gdXNlQ2FsbGJhY2soKGZpZWxkOiBrZXlvZiBEb2dQcm9maWxlLCBhc2NlbmRpbmc6IGJvb2xlYW4gPSB0cnVlKTogRG9nUHJvZmlsZVtdID0+IHtcbiAgICByZXR1cm4gWy4uLnN0YXRlLnByb2ZpbGVzXS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBhVmFsdWUgPSBhW2ZpZWxkXTtcbiAgICAgIGNvbnN0IGJWYWx1ZSA9IGJbZmllbGRdO1xuICAgICAgXG4gICAgICBpZiAoYVZhbHVlID09PSB1bmRlZmluZWQgfHwgYlZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICAgICAgXG4gICAgICBpZiAodHlwZW9mIGFWYWx1ZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGJWYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGFzY2VuZGluZyBcbiAgICAgICAgICA/IGFWYWx1ZS5sb2NhbGVDb21wYXJlKGJWYWx1ZSkgXG4gICAgICAgICAgOiBiVmFsdWUubG9jYWxlQ29tcGFyZShhVmFsdWUpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoYVZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiBiVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBhc2NlbmRpbmcgXG4gICAgICAgICAgPyBhVmFsdWUuZ2V0VGltZSgpIC0gYlZhbHVlLmdldFRpbWUoKSBcbiAgICAgICAgICA6IGJWYWx1ZS5nZXRUaW1lKCkgLSBhVmFsdWUuZ2V0VGltZSgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodHlwZW9mIGFWYWx1ZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGJWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGFzY2VuZGluZyBcbiAgICAgICAgICA/IGFWYWx1ZSAtIGJWYWx1ZSBcbiAgICAgICAgICA6IGJWYWx1ZSAtIGFWYWx1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gIH0sIFtzdGF0ZS5wcm9maWxlc10pO1xuICBcbiAgLyoqXG4gICAqIEZpbHRlciBwcm9maWxlcyBieSBhIGdpdmVuIGNyaXRlcmlhXG4gICAqL1xuICBjb25zdCBmaWx0ZXJQcm9maWxlcyA9IHVzZUNhbGxiYWNrKChjcml0ZXJpYTogUGFydGlhbDxEb2dQcm9maWxlPik6IERvZ1Byb2ZpbGVbXSA9PiB7XG4gICAgcmV0dXJuIHN0YXRlLnByb2ZpbGVzLmZpbHRlcihwcm9maWxlID0+IHtcbiAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhjcml0ZXJpYSkuZXZlcnkoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9maWxlVmFsdWUgPSBwcm9maWxlW2tleSBhcyBrZXlvZiBEb2dQcm9maWxlXTtcbiAgICAgICAgXG4gICAgICAgIC8vIEhhbmRsZSBhcnJheXMgKGxpa2UgaGVhbHRoQ29uZGl0aW9ucylcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIEFycmF5LmlzQXJyYXkocHJvZmlsZVZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5ldmVyeSh2ID0+IHByb2ZpbGVWYWx1ZS5pbmNsdWRlcyh2KSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBwcm9maWxlVmFsdWUgPT09IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIFtzdGF0ZS5wcm9maWxlc10pO1xuICBcbiAgLy8gQ29tYmluZSBzdGF0ZSBhbmQgYWN0aW9uc1xuICBjb25zdCB2YWx1ZTogRG9nUHJvZmlsZXNDb250ZXh0VHlwZSA9IHtcbiAgICAuLi5zdGF0ZSxcbiAgICBhZGRQcm9maWxlLFxuICAgIHVwZGF0ZVByb2ZpbGUsXG4gICAgZGVsZXRlUHJvZmlsZSxcbiAgICBzZXRDdXJyZW50UHJvZmlsZSxcbiAgICBjbGVhckN1cnJlbnRQcm9maWxlLFxuICAgIHNvcnRQcm9maWxlcyxcbiAgICBmaWx0ZXJQcm9maWxlc1xuICB9O1xuICBcbiAgcmV0dXJuIChcbiAgICA8RG9nUHJvZmlsZXNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt2YWx1ZX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9Eb2dQcm9maWxlc0NvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG5cbi8qKlxuICogQ3VzdG9tIGhvb2sgdG8gdXNlIHRoZSBkb2cgcHJvZmlsZXMgY29udGV4dFxuICogQHJldHVybnMgRG9nIHByb2ZpbGVzIGNvbnRleHQgc3RhdGUgYW5kIGFjdGlvbnNcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdXNlZCBvdXRzaWRlIG9mIGEgRG9nUHJvZmlsZXNQcm92aWRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRG9nUHJvZmlsZXMoKTogRG9nUHJvZmlsZXNDb250ZXh0VHlwZSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KERvZ1Byb2ZpbGVzQ29udGV4dCk7XG4gIFxuICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1c2VEb2dQcm9maWxlcyBtdXN0IGJlIHVzZWQgd2l0aGluIGEgRG9nUHJvZmlsZXNQcm92aWRlcicpO1xuICB9XG4gIFxuICByZXR1cm4gY29udGV4dDtcbn0gIl0sIm5hbWVzIjpbImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInZhbGlkYXRlRG9nUHJvZmlsZSIsIlNUT1JBR0VfS0VZUyIsImxvYWRGcm9tTG9jYWxTdG9yYWdlIiwic2F2ZVRvTG9jYWxTdG9yYWdlIiwiaXNMb2NhbFN0b3JhZ2VBdmFpbGFibGUiLCJpbml0aWFsRG9nUHJvZmlsZXNTdGF0ZSIsInByb2ZpbGVzIiwiY3VycmVudFByb2ZpbGUiLCJpbml0aWFsaXplZCIsIkRvZ1Byb2ZpbGVzQ29udGV4dCIsInVuZGVmaW5lZCIsImdlbmVyYXRlSWQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJEb2dQcm9maWxlc1Byb3ZpZGVyIiwiY2hpbGRyZW4iLCJzdGF0ZSIsInNldFN0YXRlIiwic3RvcmFnZUF2YWlsYWJsZSIsImNvbnNvbGUiLCJ3YXJuIiwicHJldiIsInNhdmVkU3RhdGUiLCJET0dfUFJPRklMRVMiLCJ2YWxpZFByb2ZpbGVzIiwiZmlsdGVyIiwicHJvZmlsZSIsInZhbGlkYXRpb24iLCJzdWNjZXNzIiwiZXJyb3IiLCJhZGRQcm9maWxlIiwiaWQiLCJuZXdQcm9maWxlIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInVwZGF0ZWRBdCIsIkVycm9yIiwiZXJyb3JzIiwicHJldlN0YXRlIiwibGVuZ3RoIiwidXBkYXRlUHJvZmlsZSIsInByb2ZpbGVVcGRhdGUiLCJ1cGRhdGVkIiwicHJvZmlsZUluZGV4IiwiZmluZEluZGV4IiwicCIsInVwZGF0ZWRQcm9maWxlIiwidXBkYXRlZFByb2ZpbGVzIiwidXBkYXRlZEN1cnJlbnRQcm9maWxlIiwiZGVsZXRlUHJvZmlsZSIsImRlbGV0ZWQiLCJmaWx0ZXJlZFByb2ZpbGVzIiwic2V0Q3VycmVudFByb2ZpbGUiLCJmaW5kIiwiY2xlYXJDdXJyZW50UHJvZmlsZSIsInNvcnRQcm9maWxlcyIsImZpZWxkIiwiYXNjZW5kaW5nIiwic29ydCIsImEiLCJiIiwiYVZhbHVlIiwiYlZhbHVlIiwibG9jYWxlQ29tcGFyZSIsImdldFRpbWUiLCJmaWx0ZXJQcm9maWxlcyIsImNyaXRlcmlhIiwiT2JqZWN0IiwiZW50cmllcyIsImV2ZXJ5Iiwia2V5IiwidmFsdWUiLCJwcm9maWxlVmFsdWUiLCJBcnJheSIsImlzQXJyYXkiLCJ2IiwiaW5jbHVkZXMiLCJQcm92aWRlciIsInVzZURvZ1Byb2ZpbGVzIiwiY29udGV4dCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/context/DogProfileContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/localStorage.ts":
/*!***********************************!*\
  !*** ./src/utils/localStorage.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CURRENT_STORAGE_VERSION: () => (/* binding */ CURRENT_STORAGE_VERSION),\n/* harmony export */   STORAGE_KEYS: () => (/* binding */ STORAGE_KEYS),\n/* harmony export */   clearAllStorageData: () => (/* binding */ clearAllStorageData),\n/* harmony export */   isLocalStorageAvailable: () => (/* binding */ isLocalStorageAvailable),\n/* harmony export */   loadFromLocalStorage: () => (/* binding */ loadFromLocalStorage),\n/* harmony export */   saveToLocalStorage: () => (/* binding */ saveToLocalStorage)\n/* harmony export */ });\n/**\n * Local storage utility functions\n */ // Constants for storage keys\nconst STORAGE_KEYS = {\n    DOG_PROFILES: 'petfood_dog_profiles',\n    FOOD_DATABASE: 'petfood_food_database',\n    USER_PREFERENCES: 'petfood_user_preferences',\n    STORAGE_VERSION: 'petfood_storage_version'\n};\n// Current storage version\nconst CURRENT_STORAGE_VERSION = '1.0';\n/**\n * Save data to local storage with versioning\n * @param key Storage key\n * @param data Data to store\n * @returns true if successful, false otherwise\n */ function saveToLocalStorage(key, data) {\n    try {\n        const versionedData = {\n            version: CURRENT_STORAGE_VERSION,\n            data,\n            timestamp: Date.now()\n        };\n        const serialized = JSON.stringify(versionedData);\n        localStorage.setItem(key, serialized);\n        localStorage.setItem(STORAGE_KEYS.STORAGE_VERSION, CURRENT_STORAGE_VERSION);\n        return true;\n    } catch (error) {\n        console.error(\"Error saving to localStorage (\".concat(key, \"):\"), error);\n        return false;\n    }\n}\n/**\n * Load data from local storage with version checking\n * @param key Storage key\n * @param defaultValue Default value if data not found or invalid\n * @returns The stored data or the default value\n */ function loadFromLocalStorage(key, defaultValue) {\n    try {\n        const serialized = localStorage.getItem(key);\n        if (!serialized) {\n            return defaultValue;\n        }\n        const versionedData = JSON.parse(serialized);\n        // Check if version matches\n        if (versionedData.version !== CURRENT_STORAGE_VERSION) {\n            console.warn(\"Storage version mismatch for \".concat(key, \". Expected \").concat(CURRENT_STORAGE_VERSION, \", got \").concat(versionedData.version));\n            // Here we could implement migration logic for different versions\n            // For now, just return the default value\n            return defaultValue;\n        }\n        return versionedData.data;\n    } catch (error) {\n        console.error(\"Error loading from localStorage (\".concat(key, \"):\"), error);\n        return defaultValue;\n    }\n}\n/**\n * Clear all application data from local storage\n */ function clearAllStorageData() {\n    try {\n        Object.values(STORAGE_KEYS).forEach((key)=>{\n            localStorage.removeItem(key);\n        });\n    } catch (error) {\n        console.error('Error clearing localStorage:', error);\n    }\n}\n/**\n * Check if local storage is available\n * @returns true if local storage is available, false otherwise\n */ function isLocalStorageAvailable() {\n    try {\n        const testKey = '__storage_test__';\n        localStorage.setItem(testKey, testKey);\n        localStorage.removeItem(testKey);\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9sb2NhbFN0b3JhZ2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FFRCw2QkFBNkI7QUFDdEIsTUFBTUEsZUFBZTtJQUMxQkMsY0FBYztJQUNkQyxlQUFlO0lBQ2ZDLGtCQUFrQjtJQUNsQkMsaUJBQWlCO0FBQ25CLEVBQUU7QUFFRiwwQkFBMEI7QUFDbkIsTUFBTUMsMEJBQTBCLE1BQU07QUFXN0M7Ozs7O0NBS0MsR0FDTSxTQUFTQyxtQkFBc0JDLEdBQVcsRUFBRUMsSUFBTztJQUN4RCxJQUFJO1FBQ0YsTUFBTUMsZ0JBQWtDO1lBQ3RDQyxTQUFTTDtZQUNURztZQUNBRyxXQUFXQyxLQUFLQyxHQUFHO1FBQ3JCO1FBRUEsTUFBTUMsYUFBYUMsS0FBS0MsU0FBUyxDQUFDUDtRQUNsQ1EsYUFBYUMsT0FBTyxDQUFDWCxLQUFLTztRQUMxQkcsYUFBYUMsT0FBTyxDQUFDbEIsYUFBYUksZUFBZSxFQUFFQztRQUNuRCxPQUFPO0lBQ1QsRUFBRSxPQUFPYyxPQUFPO1FBQ2RDLFFBQVFELEtBQUssQ0FBQyxpQ0FBcUMsT0FBSlosS0FBSSxPQUFLWTtRQUN4RCxPQUFPO0lBQ1Q7QUFDRjtBQUVBOzs7OztDQUtDLEdBQ00sU0FBU0UscUJBQXdCZCxHQUFXLEVBQUVlLFlBQWU7SUFDbEUsSUFBSTtRQUNGLE1BQU1SLGFBQWFHLGFBQWFNLE9BQU8sQ0FBQ2hCO1FBRXhDLElBQUksQ0FBQ08sWUFBWTtZQUNmLE9BQU9RO1FBQ1Q7UUFFQSxNQUFNYixnQkFBZ0JNLEtBQUtTLEtBQUssQ0FBQ1Y7UUFFakMsMkJBQTJCO1FBQzNCLElBQUlMLGNBQWNDLE9BQU8sS0FBS0wseUJBQXlCO1lBQ3JEZSxRQUFRSyxJQUFJLENBQUMsZ0NBQWlEcEIsT0FBakJFLEtBQUksZUFBNkNFLE9BQWhDSix5QkFBd0IsVUFBOEIsT0FBdEJJLGNBQWNDLE9BQU87WUFDbkgsaUVBQWlFO1lBQ2pFLHlDQUF5QztZQUN6QyxPQUFPWTtRQUNUO1FBRUEsT0FBT2IsY0FBY0QsSUFBSTtJQUMzQixFQUFFLE9BQU9XLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLG9DQUF3QyxPQUFKWixLQUFJLE9BQUtZO1FBQzNELE9BQU9HO0lBQ1Q7QUFDRjtBQUVBOztDQUVDLEdBQ00sU0FBU0k7SUFDZCxJQUFJO1FBQ0ZDLE9BQU9DLE1BQU0sQ0FBQzVCLGNBQWM2QixPQUFPLENBQUN0QixDQUFBQTtZQUNsQ1UsYUFBYWEsVUFBVSxDQUFDdkI7UUFDMUI7SUFDRixFQUFFLE9BQU9ZLE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLGdDQUFnQ0E7SUFDaEQ7QUFDRjtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNZO0lBQ2QsSUFBSTtRQUNGLE1BQU1DLFVBQVU7UUFDaEJmLGFBQWFDLE9BQU8sQ0FBQ2MsU0FBU0E7UUFDOUJmLGFBQWFhLFVBQVUsQ0FBQ0U7UUFDeEIsT0FBTztJQUNULEVBQUUsT0FBT0MsR0FBRztRQUNWLE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvam9uYXRoYW5tYWhydGd1eW91L0Rlc2t0b3AvSm9NYUd1eSBQcm9qZWN0cy9QZXRGb29kL3NyYy91dGlscy9sb2NhbFN0b3JhZ2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2NhbCBzdG9yYWdlIHV0aWxpdHkgZnVuY3Rpb25zXG4gKi9cblxuLy8gQ29uc3RhbnRzIGZvciBzdG9yYWdlIGtleXNcbmV4cG9ydCBjb25zdCBTVE9SQUdFX0tFWVMgPSB7XG4gIERPR19QUk9GSUxFUzogJ3BldGZvb2RfZG9nX3Byb2ZpbGVzJyxcbiAgRk9PRF9EQVRBQkFTRTogJ3BldGZvb2RfZm9vZF9kYXRhYmFzZScsXG4gIFVTRVJfUFJFRkVSRU5DRVM6ICdwZXRmb29kX3VzZXJfcHJlZmVyZW5jZXMnLFxuICBTVE9SQUdFX1ZFUlNJT046ICdwZXRmb29kX3N0b3JhZ2VfdmVyc2lvbidcbn07XG5cbi8vIEN1cnJlbnQgc3RvcmFnZSB2ZXJzaW9uXG5leHBvcnQgY29uc3QgQ1VSUkVOVF9TVE9SQUdFX1ZFUlNJT04gPSAnMS4wJztcblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIHZlcnNpb25lZCBzdG9yYWdlIGRhdGFcbiAqL1xuaW50ZXJmYWNlIFZlcnNpb25lZERhdGE8VD4ge1xuICB2ZXJzaW9uOiBzdHJpbmc7XG4gIGRhdGE6IFQ7XG4gIHRpbWVzdGFtcDogbnVtYmVyO1xufVxuXG4vKipcbiAqIFNhdmUgZGF0YSB0byBsb2NhbCBzdG9yYWdlIHdpdGggdmVyc2lvbmluZ1xuICogQHBhcmFtIGtleSBTdG9yYWdlIGtleVxuICogQHBhcmFtIGRhdGEgRGF0YSB0byBzdG9yZVxuICogQHJldHVybnMgdHJ1ZSBpZiBzdWNjZXNzZnVsLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNhdmVUb0xvY2FsU3RvcmFnZTxUPihrZXk6IHN0cmluZywgZGF0YTogVCk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGE6IFZlcnNpb25lZERhdGE8VD4gPSB7XG4gICAgICB2ZXJzaW9uOiBDVVJSRU5UX1NUT1JBR0VfVkVSU0lPTixcbiAgICAgIGRhdGEsXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KClcbiAgICB9O1xuICAgIFxuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeSh2ZXJzaW9uZWREYXRhKTtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHNlcmlhbGl6ZWQpO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZUy5TVE9SQUdFX1ZFUlNJT04sIENVUlJFTlRfU1RPUkFHRV9WRVJTSU9OKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzYXZpbmcgdG8gbG9jYWxTdG9yYWdlICgke2tleX0pOmAsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBMb2FkIGRhdGEgZnJvbSBsb2NhbCBzdG9yYWdlIHdpdGggdmVyc2lvbiBjaGVja2luZ1xuICogQHBhcmFtIGtleSBTdG9yYWdlIGtleVxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBEZWZhdWx0IHZhbHVlIGlmIGRhdGEgbm90IGZvdW5kIG9yIGludmFsaWRcbiAqIEByZXR1cm5zIFRoZSBzdG9yZWQgZGF0YSBvciB0aGUgZGVmYXVsdCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9hZEZyb21Mb2NhbFN0b3JhZ2U8VD4oa2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZTogVCk6IFQge1xuICB0cnkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIFxuICAgIGlmICghc2VyaWFsaXplZCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IEpTT04ucGFyc2Uoc2VyaWFsaXplZCkgYXMgVmVyc2lvbmVkRGF0YTxUPjtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB2ZXJzaW9uIG1hdGNoZXNcbiAgICBpZiAodmVyc2lvbmVkRGF0YS52ZXJzaW9uICE9PSBDVVJSRU5UX1NUT1JBR0VfVkVSU0lPTikge1xuICAgICAgY29uc29sZS53YXJuKGBTdG9yYWdlIHZlcnNpb24gbWlzbWF0Y2ggZm9yICR7a2V5fS4gRXhwZWN0ZWQgJHtDVVJSRU5UX1NUT1JBR0VfVkVSU0lPTn0sIGdvdCAke3ZlcnNpb25lZERhdGEudmVyc2lvbn1gKTtcbiAgICAgIC8vIEhlcmUgd2UgY291bGQgaW1wbGVtZW50IG1pZ3JhdGlvbiBsb2dpYyBmb3IgZGlmZmVyZW50IHZlcnNpb25zXG4gICAgICAvLyBGb3Igbm93LCBqdXN0IHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGEuZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBsb2FkaW5nIGZyb20gbG9jYWxTdG9yYWdlICgke2tleX0pOmAsIGVycm9yKTtcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogQ2xlYXIgYWxsIGFwcGxpY2F0aW9uIGRhdGEgZnJvbSBsb2NhbCBzdG9yYWdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckFsbFN0b3JhZ2VEYXRhKCk6IHZvaWQge1xuICB0cnkge1xuICAgIE9iamVjdC52YWx1ZXMoU1RPUkFHRV9LRVlTKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNsZWFyaW5nIGxvY2FsU3RvcmFnZTonLCBlcnJvcik7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBsb2NhbCBzdG9yYWdlIGlzIGF2YWlsYWJsZVxuICogQHJldHVybnMgdHJ1ZSBpZiBsb2NhbCBzdG9yYWdlIGlzIGF2YWlsYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xvY2FsU3RvcmFnZUF2YWlsYWJsZSgpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0ZXN0S2V5ID0gJ19fc3RvcmFnZV90ZXN0X18nO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHRlc3RLZXksIHRlc3RLZXkpO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRlc3RLZXkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59ICJdLCJuYW1lcyI6WyJTVE9SQUdFX0tFWVMiLCJET0dfUFJPRklMRVMiLCJGT09EX0RBVEFCQVNFIiwiVVNFUl9QUkVGRVJFTkNFUyIsIlNUT1JBR0VfVkVSU0lPTiIsIkNVUlJFTlRfU1RPUkFHRV9WRVJTSU9OIiwic2F2ZVRvTG9jYWxTdG9yYWdlIiwia2V5IiwiZGF0YSIsInZlcnNpb25lZERhdGEiLCJ2ZXJzaW9uIiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsInNlcmlhbGl6ZWQiLCJKU09OIiwic3RyaW5naWZ5IiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsImVycm9yIiwiY29uc29sZSIsImxvYWRGcm9tTG9jYWxTdG9yYWdlIiwiZGVmYXVsdFZhbHVlIiwiZ2V0SXRlbSIsInBhcnNlIiwid2FybiIsImNsZWFyQWxsU3RvcmFnZURhdGEiLCJPYmplY3QiLCJ2YWx1ZXMiLCJmb3JFYWNoIiwicmVtb3ZlSXRlbSIsImlzTG9jYWxTdG9yYWdlQXZhaWxhYmxlIiwidGVzdEtleSIsImUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/localStorage.ts\n"));

/***/ })

});