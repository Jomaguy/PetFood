"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/utils/errorHandling.ts":
/*!************************************!*\
  !*** ./src/utils/errorHandling.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageError: () => (/* binding */ StorageError),\n/* harmony export */   StorageErrorType: () => (/* binding */ StorageErrorType),\n/* harmony export */   handleStorageError: () => (/* binding */ handleStorageError),\n/* harmony export */   logStorageError: () => (/* binding */ logStorageError),\n/* harmony export */   registerStorageErrorHandler: () => (/* binding */ registerStorageErrorHandler),\n/* harmony export */   tryCatchStorage: () => (/* binding */ tryCatchStorage),\n/* harmony export */   unregisterStorageErrorHandler: () => (/* binding */ unregisterStorageErrorHandler)\n/* harmony export */ });\n/**\n * Utility functions for enhanced error handling and logging\n */ // Define different types of storage errors\nvar StorageErrorType = /*#__PURE__*/ function(StorageErrorType) {\n    StorageErrorType[\"STORAGE_UNAVAILABLE\"] = \"storage_unavailable\";\n    StorageErrorType[\"STORAGE_QUOTA_EXCEEDED\"] = \"storage_quota_exceeded\";\n    StorageErrorType[\"PARSE_ERROR\"] = \"parse_error\";\n    StorageErrorType[\"WRITE_ERROR\"] = \"write_error\";\n    StorageErrorType[\"READ_ERROR\"] = \"read_error\";\n    StorageErrorType[\"VERSION_MISMATCH\"] = \"version_mismatch\";\n    StorageErrorType[\"BACKUP_ERROR\"] = \"backup_error\";\n    StorageErrorType[\"RESTORE_ERROR\"] = \"restore_error\";\n    StorageErrorType[\"EXPORT_ERROR\"] = \"export_error\";\n    StorageErrorType[\"IMPORT_ERROR\"] = \"import_error\";\n    StorageErrorType[\"CLEANUP_ERROR\"] = \"cleanup_error\";\n    StorageErrorType[\"UNKNOWN_ERROR\"] = \"unknown_error\";\n    return StorageErrorType;\n}({});\n// Custom storage error class\nclass StorageError extends Error {\n    // Get human-readable error message\n    getUserFriendlyMessage() {\n        switch(this.type){\n            case \"storage_unavailable\":\n                return 'Local storage is not available in your browser. Please enable cookies and local storage in your browser settings.';\n            case \"storage_quota_exceeded\":\n                return 'Storage space is full. Please delete some data or export your data as a backup.';\n            case \"parse_error\":\n                return 'Could not read stored data due to a format error. Your data might be corrupted.';\n            case \"write_error\":\n                return 'Failed to save data to storage. Please check your browser settings.';\n            case \"read_error\":\n                return 'Failed to read data from storage. Please check your browser settings.';\n            case \"version_mismatch\":\n                return 'The data format has changed since your last visit. Some data may need to be migrated.';\n            case \"backup_error\":\n                return 'Failed to create a backup of your data.';\n            case \"restore_error\":\n                return 'Failed to restore data from backup. The backup might be corrupted or missing.';\n            case \"export_error\":\n                return 'Failed to export data. Please try again later.';\n            case \"import_error\":\n                return 'Failed to import data. The file might be corrupted or in an invalid format.';\n            case \"cleanup_error\":\n                return 'Failed to clean up old data. Please try again later or perform a manual cleanup.';\n            default:\n                return this.message || 'An unknown error occurred while accessing storage.';\n        }\n    }\n    constructor(message, type = \"unknown_error\", details){\n        super(message);\n        this.name = 'StorageError';\n        this.type = type;\n        this.details = details;\n        this.timestamp = new Date();\n        // Ensure proper prototype chain for instanceof checks\n        Object.setPrototypeOf(this, StorageError.prototype);\n    }\n}\n// Error handler for storage operations\nfunction handleStorageError(error, operation, errorType) {\n    // Map the error to a StorageError type\n    let storageError;\n    if (error instanceof StorageError) {\n        // Already a StorageError, just return it\n        return error;\n    } else if (error instanceof Error) {\n        // Convert standard Error to StorageError\n        const type = errorType || determineErrorType(error, operation);\n        storageError = new StorageError(error.message || \"Error during \".concat(operation), type, {\n            originalError: error,\n            stack: error.stack\n        });\n    } else {\n        // Handle non-Error objects\n        storageError = new StorageError(String(error) || \"Unknown error during \".concat(operation), errorType || \"unknown_error\", {\n            originalError: error\n        });\n    }\n    // Log the error for debugging\n    logStorageError(storageError, operation);\n    return storageError;\n}\n// Determine error type from error message or stack trace\nfunction determineErrorType(error, operation) {\n    var _error_stack;\n    const errorMsg = error.message.toLowerCase();\n    const errorStack = ((_error_stack = error.stack) === null || _error_stack === void 0 ? void 0 : _error_stack.toLowerCase()) || '';\n    if (errorMsg.includes('quota') || errorMsg.includes('exceed') || errorMsg.includes('full')) {\n        return \"storage_quota_exceeded\";\n    } else if (errorMsg.includes('parse') || errorMsg.includes('json') || errorMsg.includes('format')) {\n        return \"parse_error\";\n    } else if (!window.localStorage || operation.includes('unavailable')) {\n        return \"storage_unavailable\";\n    } else if (operation.includes('write') || operation.includes('save')) {\n        return \"write_error\";\n    } else if (operation.includes('read') || operation.includes('load')) {\n        return \"read_error\";\n    } else if (operation.includes('version') || operation.includes('migration')) {\n        return \"version_mismatch\";\n    } else if (operation.includes('backup')) {\n        return \"backup_error\";\n    } else if (operation.includes('restore')) {\n        return \"restore_error\";\n    } else if (operation.includes('export')) {\n        return \"export_error\";\n    } else if (operation.includes('import')) {\n        return \"import_error\";\n    }\n    return \"unknown_error\";\n}\n// Enhanced error logging function\nfunction logStorageError(error, operation) {\n    console.group(\"Storage Error: \".concat(operation));\n    console.error(\"[\".concat(error.timestamp.toISOString(), \"] \").concat(error.name, \": \").concat(error.message));\n    console.error(\"Type: \".concat(error.type));\n    console.error(\"User friendly message: \".concat(error.getUserFriendlyMessage()));\n    if (error.details) {\n        console.error('Details:', error.details);\n    }\n    if (error.stack) {\n        console.error('Stack:', error.stack);\n    }\n    console.groupEnd();\n// In a production app, you might want to send this to a logging service\n// logToService(error, operation);\n}\n// Find the global StorageErrorContext if available\nlet globalSetStorageError = null;\n/**\n * Register a function to set global storage errors\n * This should be called by the StorageErrorProvider during initialization\n */ function registerStorageErrorHandler(handler) {\n    globalSetStorageError = handler;\n}\n/**\n * Unregister the global error handler\n */ function unregisterStorageErrorHandler() {\n    globalSetStorageError = null;\n}\n// Try-catch wrapper for storage operations\nfunction tryCatchStorage(operation, operationName, errorType, options) {\n    try {\n        const result = operation();\n        return {\n            result,\n            error: null\n        };\n    } catch (err) {\n        const error = handleStorageError(err, operationName, errorType);\n        // Check if this is a critical error that should be shown to the user\n        const isCritical = error.type === \"storage_unavailable\" || error.type === \"storage_quota_exceeded\";\n        // Only log critical errors if requested\n        if (!(options === null || options === void 0 ? void 0 : options.logOnlyCritical) || isCritical) {\n            logStorageError(error, operationName);\n        }\n        // Notify global error handler if available and notification is not suppressed\n        if (globalSetStorageError && !(options === null || options === void 0 ? void 0 : options.suppressNotification)) {\n            globalSetStorageError(error);\n        }\n        return {\n            result: null,\n            error\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9lcnJvckhhbmRsaW5nLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQUVELDJDQUEyQztBQUNwQyw4Q0FBS0E7Ozs7Ozs7Ozs7Ozs7V0FBQUE7TUFhWDtBQUVELDZCQUE2QjtBQUN0QixNQUFNQyxxQkFBcUJDO0lBb0JoQyxtQ0FBbUM7SUFDbkNDLHlCQUFpQztRQUMvQixPQUFRLElBQUksQ0FBQ0MsSUFBSTtZQUNmO2dCQUNFLE9BQU87WUFFVDtnQkFDRSxPQUFPO1lBRVQ7Z0JBQ0UsT0FBTztZQUVUO2dCQUNFLE9BQU87WUFFVDtnQkFDRSxPQUFPO1lBRVQ7Z0JBQ0UsT0FBTztZQUVUO2dCQUNFLE9BQU87WUFFVDtnQkFDRSxPQUFPO1lBRVQ7Z0JBQ0UsT0FBTztZQUVUO2dCQUNFLE9BQU87WUFFVDtnQkFDRSxPQUFPO1lBRVQ7Z0JBQ0UsT0FBTyxJQUFJLENBQUNDLE9BQU8sSUFBSTtRQUMzQjtJQUNGO0lBdERBQyxZQUNFRCxPQUFlLEVBQ2ZELHNCQUF1RCxFQUN2REcsT0FBYSxDQUNiO1FBQ0EsS0FBSyxDQUFDRjtRQUNOLElBQUksQ0FBQ0csSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDSixJQUFJLEdBQUdBO1FBQ1osSUFBSSxDQUFDRyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDRSxTQUFTLEdBQUcsSUFBSUM7UUFFckIsc0RBQXNEO1FBQ3REQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFWCxhQUFhWSxTQUFTO0lBQ3BEO0FBMENGO0FBRUEsdUNBQXVDO0FBQ2hDLFNBQVNDLG1CQUNkQyxLQUFjLEVBQ2RDLFNBQWlCLEVBQ2pCQyxTQUE0QjtJQUU1Qix1Q0FBdUM7SUFDdkMsSUFBSUM7SUFFSixJQUFJSCxpQkFBaUJkLGNBQWM7UUFDakMseUNBQXlDO1FBQ3pDLE9BQU9jO0lBQ1QsT0FBTyxJQUFJQSxpQkFBaUJiLE9BQU87UUFDakMseUNBQXlDO1FBQ3pDLE1BQU1FLE9B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LE1BQU1DLFNBQVN6QjtRQUNmLE9BQU87WUFBRXlCO1lBQVExQixPQUFPO1FBQUs7SUFDL0IsRUFBRSxPQUFPMkIsS0FBSztRQUNaLE1BQU0zQixRQUFRRCxtQkFBbUI0QixLQUFLSCxlQUFldEI7UUFFckQscUVBQXFFO1FBQ3JFLE1BQU0wQixhQUFhNUIsTUFBTVgsSUFBSSw4QkFDWlcsTUFBTVgsSUFBSTtRQUUzQix3Q0FBd0M7UUFDeEMsSUFBSSxFQUFDb0Msb0JBQUFBLDhCQUFBQSxRQUFTSSxlQUFlLEtBQUlELFlBQVk7WUFDM0NwQixnQkFBZ0JSLE9BQU93QjtRQUN6QjtRQUVBLDhFQUE4RTtRQUM5RSxJQUFJTCx5QkFBeUIsRUFBQ00sb0JBQUFBLDhCQUFBQSxRQUFTSyxvQkFBb0IsR0FBRTtZQUMzRFgsc0JBQXNCbkI7UUFDeEI7UUFFQSxPQUFPO1lBQUUwQixRQUFRO1lBQU0xQjtRQUFNO0lBQy9CO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb25hdGhhbm1haHJ0Z3V5b3UvRGVza3RvcC9Kb01hR3V5IFByb2plY3RzL1BldEZvb2Qvc3JjL3V0aWxzL2Vycm9ySGFuZGxpbmcudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZW5oYW5jZWQgZXJyb3IgaGFuZGxpbmcgYW5kIGxvZ2dpbmdcbiAqL1xuXG4vLyBEZWZpbmUgZGlmZmVyZW50IHR5cGVzIG9mIHN0b3JhZ2UgZXJyb3JzXG5leHBvcnQgZW51bSBTdG9yYWdlRXJyb3JUeXBlIHtcbiAgU1RPUkFHRV9VTkFWQUlMQUJMRSA9ICdzdG9yYWdlX3VuYXZhaWxhYmxlJyxcbiAgU1RPUkFHRV9RVU9UQV9FWENFRURFRCA9ICdzdG9yYWdlX3F1b3RhX2V4Y2VlZGVkJyxcbiAgUEFSU0VfRVJST1IgPSAncGFyc2VfZXJyb3InLFxuICBXUklURV9FUlJPUiA9ICd3cml0ZV9lcnJvcicsXG4gIFJFQURfRVJST1IgPSAncmVhZF9lcnJvcicsXG4gIFZFUlNJT05fTUlTTUFUQ0ggPSAndmVyc2lvbl9taXNtYXRjaCcsXG4gIEJBQ0tVUF9FUlJPUiA9ICdiYWNrdXBfZXJyb3InLFxuICBSRVNUT1JFX0VSUk9SID0gJ3Jlc3RvcmVfZXJyb3InLFxuICBFWFBPUlRfRVJST1IgPSAnZXhwb3J0X2Vycm9yJyxcbiAgSU1QT1JUX0VSUk9SID0gJ2ltcG9ydF9lcnJvcicsXG4gIENMRUFOVVBfRVJST1IgPSAnY2xlYW51cF9lcnJvcicsXG4gIFVOS05PV05fRVJST1IgPSAndW5rbm93bl9lcnJvcidcbn1cblxuLy8gQ3VzdG9tIHN0b3JhZ2UgZXJyb3IgY2xhc3NcbmV4cG9ydCBjbGFzcyBTdG9yYWdlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHR5cGU6IFN0b3JhZ2VFcnJvclR5cGU7XG4gIGRldGFpbHM/OiBhbnk7XG4gIHRpbWVzdGFtcDogRGF0ZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgdHlwZTogU3RvcmFnZUVycm9yVHlwZSA9IFN0b3JhZ2VFcnJvclR5cGUuVU5LTk9XTl9FUlJPUixcbiAgICBkZXRhaWxzPzogYW55XG4gICkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdTdG9yYWdlRXJyb3InO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB0aGlzLnRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG5cbiAgICAvLyBFbnN1cmUgcHJvcGVyIHByb3RvdHlwZSBjaGFpbiBmb3IgaW5zdGFuY2VvZiBjaGVja3NcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgU3RvcmFnZUVycm9yLnByb3RvdHlwZSk7XG4gIH1cblxuICAvLyBHZXQgaHVtYW4tcmVhZGFibGUgZXJyb3IgbWVzc2FnZVxuICBnZXRVc2VyRnJpZW5kbHlNZXNzYWdlKCk6IHN0cmluZyB7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgU3RvcmFnZUVycm9yVHlwZS5TVE9SQUdFX1VOQVZBSUxBQkxFOlxuICAgICAgICByZXR1cm4gJ0xvY2FsIHN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBpbiB5b3VyIGJyb3dzZXIuIFBsZWFzZSBlbmFibGUgY29va2llcyBhbmQgbG9jYWwgc3RvcmFnZSBpbiB5b3VyIGJyb3dzZXIgc2V0dGluZ3MuJztcbiAgICAgIFxuICAgICAgY2FzZSBTdG9yYWdlRXJyb3JUeXBlLlNUT1JBR0VfUVVPVEFfRVhDRUVERUQ6XG4gICAgICAgIHJldHVybiAnU3RvcmFnZSBzcGFjZSBpcyBmdWxsLiBQbGVhc2UgZGVsZXRlIHNvbWUgZGF0YSBvciBleHBvcnQgeW91ciBkYXRhIGFzIGEgYmFja3VwLic7XG4gICAgICBcbiAgICAgIGNhc2UgU3RvcmFnZUVycm9yVHlwZS5QQVJTRV9FUlJPUjpcbiAgICAgICAgcmV0dXJuICdDb3VsZCBub3QgcmVhZCBzdG9yZWQgZGF0YSBkdWUgdG8gYSBmb3JtYXQgZXJyb3IuIFlvdXIgZGF0YSBtaWdodCBiZSBjb3JydXB0ZWQuJztcbiAgICAgIFxuICAgICAgY2FzZSBTdG9yYWdlRXJyb3JUeXBlLldSSVRFX0VSUk9SOlxuICAgICAgICByZXR1cm4gJ0ZhaWxlZCB0byBzYXZlIGRhdGEgdG8gc3RvcmFnZS4gUGxlYXNlIGNoZWNrIHlvdXIgYnJvd3NlciBzZXR0aW5ncy4nO1xuICAgICAgXG4gICAgICBjYXNlIFN0b3JhZ2VFcnJvclR5cGUuUkVBRF9FUlJPUjpcbiAgICAgICAgcmV0dXJuICdGYWlsZWQgdG8gcmVhZCBkYXRhIGZyb20gc3RvcmFnZS4gUGxlYXNlIGNoZWNrIHlvdXIgYnJvd3NlciBzZXR0aW5ncy4nO1xuICAgICAgXG4gICAgICBjYXNlIFN0b3JhZ2VFcnJvclR5cGUuVkVSU0lPTl9NSVNNQVRDSDpcbiAgICAgICAgcmV0dXJuICdUaGUgZGF0YSBmb3JtYXQgaGFzIGNoYW5nZWQgc2luY2UgeW91ciBsYXN0IHZpc2l0LiBTb21lIGRhdGEgbWF5IG5lZWQgdG8gYmUgbWlncmF0ZWQuJztcbiAgICAgIFxuICAgICAgY2FzZSBTdG9yYWdlRXJyb3JUeXBlLkJBQ0tVUF9FUlJPUjpcbiAgICAgICAgcmV0dXJuICdGYWlsZWQgdG8gY3JlYXRlIGEgYmFja3VwIG9mIHlvdXIgZGF0YS4nO1xuICAgICAgXG4gICAgICBjYXNlIFN0b3JhZ2VFcnJvclR5cGUuUkVTVE9SRV9FUlJPUjpcbiAgICAgICAgcmV0dXJuICdGYWlsZWQgdG8gcmVzdG9yZSBkYXRhIGZyb20gYmFja3VwLiBUaGUgYmFja3VwIG1pZ2h0IGJlIGNvcnJ1cHRlZCBvciBtaXNzaW5nLic7XG4gICAgICBcbiAgICAgIGNhc2UgU3RvcmFnZUVycm9yVHlwZS5FWFBPUlRfRVJST1I6XG4gICAgICAgIHJldHVybiAnRmFpbGVkIHRvIGV4cG9ydCBkYXRhLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLic7XG4gICAgICBcbiAgICAgIGNhc2UgU3RvcmFnZUVycm9yVHlwZS5JTVBPUlRfRVJST1I6XG4gICAgICAgIHJldHVybiAnRmFpbGVkIHRvIGltcG9ydCBkYXRhLiBUaGUgZmlsZSBtaWdodCBiZSBjb3JydXB0ZWQgb3IgaW4gYW4gaW52YWxpZCBmb3JtYXQuJztcbiAgICAgIFxuICAgICAgY2FzZSBTdG9yYWdlRXJyb3JUeXBlLkNMRUFOVVBfRVJST1I6XG4gICAgICAgIHJldHVybiAnRmFpbGVkIHRvIGNsZWFuIHVwIG9sZCBkYXRhLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyIG9yIHBlcmZvcm0gYSBtYW51YWwgY2xlYW51cC4nO1xuICAgICAgXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlIHx8ICdBbiB1bmtub3duIGVycm9yIG9jY3VycmVkIHdoaWxlIGFjY2Vzc2luZyBzdG9yYWdlLic7XG4gICAgfVxuICB9XG59XG5cbi8vIEVycm9yIGhhbmRsZXIgZm9yIHN0b3JhZ2Ugb3BlcmF0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZVN0b3JhZ2VFcnJvcihcbiAgZXJyb3I6IHVua25vd24sXG4gIG9wZXJhdGlvbjogc3RyaW5nLFxuICBlcnJvclR5cGU/OiBTdG9yYWdlRXJyb3JUeXBlXG4pOiBTdG9yYWdlRXJyb3Ige1xuICAvLyBNYXAgdGhlIGVycm9yIHRvIGEgU3RvcmFnZUVycm9yIHR5cGVcbiAgbGV0IHN0b3JhZ2VFcnJvcjogU3RvcmFnZUVycm9yO1xuICBcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgU3RvcmFnZUVycm9yKSB7XG4gICAgLy8gQWxyZWFkeSBhIFN0b3JhZ2VFcnJvciwganVzdCByZXR1cm4gaXRcbiAgICByZXR1cm4gZXJyb3I7XG4gIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIC8vIENvbnZlcnQgc3RhbmRhcmQgRXJyb3IgdG8gU3RvcmFnZUVycm9yXG4gICAgY29uc3QgdHlwZSA9IGVycm9yVHlwZSB8fCBkZXRlcm1pbmVFcnJvclR5cGUoZXJyb3IsIG9wZXJhdGlvbik7XG4gICAgc3RvcmFnZUVycm9yID0gbmV3IFN0b3JhZ2VFcnJvcihcbiAgICAgIGVycm9yLm1lc3NhZ2UgfHwgYEVycm9yIGR1cmluZyAke29wZXJhdGlvbn1gLFxuICAgICAgdHlwZSxcbiAgICAgIHsgb3JpZ2luYWxFcnJvcjogZXJyb3IsIHN0YWNrOiBlcnJvci5zdGFjayB9XG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBIYW5kbGUgbm9uLUVycm9yIG9iamVjdHNcbiAgICBzdG9yYWdlRXJyb3IgPSBuZXcgU3RvcmFnZUVycm9yKFxuICAgICAgU3RyaW5nKGVycm9yKSB8fCBgVW5rbm93biBlcnJvciBkdXJpbmcgJHtvcGVyYXRpb259YCxcbiAgICAgIGVycm9yVHlwZSB8fCBTdG9yYWdlRXJyb3JUeXBlLlVOS05PV05fRVJST1IsXG4gICAgICB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH1cbiAgICApO1xuICB9XG4gIFxuICAvLyBMb2cgdGhlIGVycm9yIGZvciBkZWJ1Z2dpbmdcbiAgbG9nU3RvcmFnZUVycm9yKHN0b3JhZ2VFcnJvciwgb3BlcmF0aW9uKTtcbiAgXG4gIHJldHVybiBzdG9yYWdlRXJyb3I7XG59XG5cbi8vIERldGVybWluZSBlcnJvciB0eXBlIGZyb20gZXJyb3IgbWVzc2FnZSBvciBzdGFjayB0cmFjZVxuZnVuY3Rpb24gZGV0ZXJtaW5lRXJyb3JUeXBlKGVycm9yOiBFcnJvciwgb3BlcmF0aW9uOiBzdHJpbmcpOiBTdG9yYWdlRXJyb3JUeXBlIHtcbiAgY29uc3QgZXJyb3JNc2cgPSBlcnJvci5tZXNzYWdlLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGVycm9yU3RhY2sgPSBlcnJvci5zdGFjaz8udG9Mb3dlckNhc2UoKSB8fCAnJztcbiAgXG4gIGlmIChlcnJvck1zZy5pbmNsdWRlcygncXVvdGEnKSB8fCBlcnJvck1zZy5pbmNsdWRlcygnZXhjZWVkJykgfHwgZXJyb3JNc2cuaW5jbHVkZXMoJ2Z1bGwnKSkge1xuICAgIHJldHVybiBTdG9yYWdlRXJyb3JUeXBlLlNUT1JBR0VfUVVPVEFfRVhDRUVERUQ7XG4gIH0gZWxzZSBpZiAoZXJyb3JNc2cuaW5jbHVkZXMoJ3BhcnNlJykgfHwgZXJyb3JNc2cuaW5jbHVkZXMoJ2pzb24nKSB8fCBlcnJvck1zZy5pbmNsdWRlcygnZm9ybWF0JykpIHtcbiAgICByZXR1cm4gU3RvcmFnZUVycm9yVHlwZS5QQVJTRV9FUlJPUjtcbiAgfSBlbHNlIGlmICghd2luZG93LmxvY2FsU3RvcmFnZSB8fCBvcGVyYXRpb24uaW5jbHVkZXMoJ3VuYXZhaWxhYmxlJykpIHtcbiAgICByZXR1cm4gU3RvcmFnZUVycm9yVHlwZS5TVE9SQUdFX1VOQVZBSUxBQkxFO1xuICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5pbmNsdWRlcygnd3JpdGUnKSB8fCBvcGVyYXRpb24uaW5jbHVkZXMoJ3NhdmUnKSkge1xuICAgIHJldHVybiBTdG9yYWdlRXJyb3JUeXBlLldSSVRFX0VSUk9SO1xuICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5pbmNsdWRlcygncmVhZCcpIHx8IG9wZXJhdGlvbi5pbmNsdWRlcygnbG9hZCcpKSB7XG4gICAgcmV0dXJuIFN0b3JhZ2VFcnJvclR5cGUuUkVBRF9FUlJPUjtcbiAgfSBlbHNlIGlmIChvcGVyYXRpb24uaW5jbHVkZXMoJ3ZlcnNpb24nKSB8fCBvcGVyYXRpb24uaW5jbHVkZXMoJ21pZ3JhdGlvbicpKSB7XG4gICAgcmV0dXJuIFN0b3JhZ2VFcnJvclR5cGUuVkVSU0lPTl9NSVNNQVRDSDtcbiAgfSBlbHNlIGlmIChvcGVyYXRpb24uaW5jbHVkZXMoJ2JhY2t1cCcpKSB7XG4gICAgcmV0dXJuIFN0b3JhZ2VFcnJvclR5cGUuQkFDS1VQX0VSUk9SO1xuICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5pbmNsdWRlcygncmVzdG9yZScpKSB7XG4gICAgcmV0dXJuIFN0b3JhZ2VFcnJvclR5cGUuUkVTVE9SRV9FUlJPUjtcbiAgfSBlbHNlIGlmIChvcGVyYXRpb24uaW5jbHVkZXMoJ2V4cG9ydCcpKSB7XG4gICAgcmV0dXJuIFN0b3JhZ2VFcnJvclR5cGUuRVhQT1JUX0VSUk9SO1xuICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5pbmNsdWRlcygnaW1wb3J0JykpIHtcbiAgICByZXR1cm4gU3RvcmFnZUVycm9yVHlwZS5JTVBPUlRfRVJST1I7XG4gIH1cbiAgXG4gIHJldHVybiBTdG9yYWdlRXJyb3JUeXBlLlVOS05PV05fRVJST1I7XG59XG5cbi8vIEVuaGFuY2VkIGVycm9yIGxvZ2dpbmcgZnVuY3Rpb25cbmV4cG9ydCBmdW5jdGlvbiBsb2dTdG9yYWdlRXJyb3IoZXJyb3I6IFN0b3JhZ2VFcnJvciwgb3BlcmF0aW9uOiBzdHJpbmcpOiB2b2lkIHtcbiAgY29uc29sZS5ncm91cChgU3RvcmFnZSBFcnJvcjogJHtvcGVyYXRpb259YCk7XG4gIGNvbnNvbGUuZXJyb3IoYFske2Vycm9yLnRpbWVzdGFtcC50b0lTT1N0cmluZygpfV0gJHtlcnJvci5uYW1lfTogJHtlcnJvci5tZXNzYWdlfWApO1xuICBjb25zb2xlLmVycm9yKGBUeXBlOiAke2Vycm9yLnR5cGV9YCk7XG4gIGNvbnNvbGUuZXJyb3IoYFVzZXIgZnJpZW5kbHkgbWVzc2FnZTogJHtlcnJvci5nZXRVc2VyRnJpZW5kbHlNZXNzYWdlKCl9YCk7XG4gIGlmIChlcnJvci5kZXRhaWxzKSB7XG4gICAgY29uc29sZS5lcnJvcignRGV0YWlsczonLCBlcnJvci5kZXRhaWxzKTtcbiAgfVxuICBpZiAoZXJyb3Iuc3RhY2spIHtcbiAgICBjb25zb2xlLmVycm9yKCdTdGFjazonLCBlcnJvci5zdGFjayk7XG4gIH1cbiAgY29uc29sZS5ncm91cEVuZCgpO1xuXG4gIC8vIEluIGEgcHJvZHVjdGlvbiBhcHAsIHlvdSBtaWdodCB3YW50IHRvIHNlbmQgdGhpcyB0byBhIGxvZ2dpbmcgc2VydmljZVxuICAvLyBsb2dUb1NlcnZpY2UoZXJyb3IsIG9wZXJhdGlvbik7XG59XG5cbi8vIEZpbmQgdGhlIGdsb2JhbCBTdG9yYWdlRXJyb3JDb250ZXh0IGlmIGF2YWlsYWJsZVxubGV0IGdsb2JhbFNldFN0b3JhZ2VFcnJvcjogKChlcnJvcjogU3RvcmFnZUVycm9yKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgZnVuY3Rpb24gdG8gc2V0IGdsb2JhbCBzdG9yYWdlIGVycm9yc1xuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGJ5IHRoZSBTdG9yYWdlRXJyb3JQcm92aWRlciBkdXJpbmcgaW5pdGlhbGl6YXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyU3RvcmFnZUVycm9ySGFuZGxlcihoYW5kbGVyOiAoZXJyb3I6IFN0b3JhZ2VFcnJvcikgPT4gdm9pZCk6IHZvaWQge1xuICBnbG9iYWxTZXRTdG9yYWdlRXJyb3IgPSBoYW5kbGVyO1xufVxuXG4vKipcbiAqIFVucmVnaXN0ZXIgdGhlIGdsb2JhbCBlcnJvciBoYW5kbGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bnJlZ2lzdGVyU3RvcmFnZUVycm9ySGFuZGxlcigpOiB2b2lkIHtcbiAgZ2xvYmFsU2V0U3RvcmFnZUVycm9yID0gbnVsbDtcbn1cblxuLy8gVHJ5LWNhdGNoIHdyYXBwZXIgZm9yIHN0b3JhZ2Ugb3BlcmF0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHRyeUNhdGNoU3RvcmFnZTxUPihcbiAgb3BlcmF0aW9uOiAoKSA9PiBULFxuICBvcGVyYXRpb25OYW1lOiBzdHJpbmcsXG4gIGVycm9yVHlwZT86IFN0b3JhZ2VFcnJvclR5cGUsXG4gIG9wdGlvbnM/OiB7XG4gICAgLyoqIFdoZXRoZXIgdG8gc3VwcHJlc3MgVUkgbm90aWZpY2F0aW9ucyBmb3IgdGhpcyBlcnJvciAqL1xuICAgIHN1cHByZXNzTm90aWZpY2F0aW9uPzogYm9vbGVhbjtcbiAgICAvKiogV2hldGhlciB0byBvbmx5IGxvZyBjcml0aWNhbCBlcnJvcnMgKi9cbiAgICBsb2dPbmx5Q3JpdGljYWw/OiBib29sZWFuO1xuICB9XG4pOiB7IHJlc3VsdDogVCB8IG51bGw7IGVycm9yOiBTdG9yYWdlRXJyb3IgfCBudWxsIH0ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IG9wZXJhdGlvbigpO1xuICAgIHJldHVybiB7IHJlc3VsdCwgZXJyb3I6IG51bGwgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc3QgZXJyb3IgPSBoYW5kbGVTdG9yYWdlRXJyb3IoZXJyLCBvcGVyYXRpb25OYW1lLCBlcnJvclR5cGUpO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBjcml0aWNhbCBlcnJvciB0aGF0IHNob3VsZCBiZSBzaG93biB0byB0aGUgdXNlclxuICAgIGNvbnN0IGlzQ3JpdGljYWwgPSBlcnJvci50eXBlID09PSBTdG9yYWdlRXJyb3JUeXBlLlNUT1JBR0VfVU5BVkFJTEFCTEUgfHwgXG4gICAgICAgICAgICAgICAgICAgICBlcnJvci50eXBlID09PSBTdG9yYWdlRXJyb3JUeXBlLlNUT1JBR0VfUVVPVEFfRVhDRUVERUQ7XG4gICAgXG4gICAgLy8gT25seSBsb2cgY3JpdGljYWwgZXJyb3JzIGlmIHJlcXVlc3RlZFxuICAgIGlmICghb3B0aW9ucz8ubG9nT25seUNyaXRpY2FsIHx8IGlzQ3JpdGljYWwpIHtcbiAgICAgIGxvZ1N0b3JhZ2VFcnJvcihlcnJvciwgb3BlcmF0aW9uTmFtZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIE5vdGlmeSBnbG9iYWwgZXJyb3IgaGFuZGxlciBpZiBhdmFpbGFibGUgYW5kIG5vdGlmaWNhdGlvbiBpcyBub3Qgc3VwcHJlc3NlZFxuICAgIGlmIChnbG9iYWxTZXRTdG9yYWdlRXJyb3IgJiYgIW9wdGlvbnM/LnN1cHByZXNzTm90aWZpY2F0aW9uKSB7XG4gICAgICBnbG9iYWxTZXRTdG9yYWdlRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4geyByZXN1bHQ6IG51bGwsIGVycm9yIH07XG4gIH1cbn0gIl0sIm5hbWVzIjpbIlN0b3JhZ2VFcnJvclR5cGUiLCJTdG9yYWdlRXJyb3IiLCJFcnJvciIsImdldFVzZXJGcmllbmRseU1lc3NhZ2UiLCJ0eXBlIiwibWVzc2FnZSIsImNvbnN0cnVjdG9yIiwiZGV0YWlscyIsIm5hbWUiLCJ0aW1lc3RhbXAiLCJEYXRlIiwiT2JqZWN0Iiwic2V0UHJvdG90eXBlT2YiLCJwcm90b3R5cGUiLCJoYW5kbGVTdG9yYWdlRXJyb3IiLCJlcnJvciIsIm9wZXJhdGlvbiIsImVycm9yVHlwZSIsInN0b3JhZ2VFcnJvciIsImRldGVybWluZUVycm9yVHlwZSIsIm9yaWdpbmFsRXJyb3IiLCJzdGFjayIsIlN0cmluZyIsImxvZ1N0b3JhZ2VFcnJvciIsImVycm9yTXNnIiwidG9Mb3dlckNhc2UiLCJlcnJvclN0YWNrIiwiaW5jbHVkZXMiLCJ3aW5kb3ciLCJsb2NhbFN0b3JhZ2UiLCJjb25zb2xlIiwiZ3JvdXAiLCJ0b0lTT1N0cmluZyIsImdyb3VwRW5kIiwiZ2xvYmFsU2V0U3RvcmFnZUVycm9yIiwicmVnaXN0ZXJTdG9yYWdlRXJyb3JIYW5kbGVyIiwiaGFuZGxlciIsInVucmVnaXN0ZXJTdG9yYWdlRXJyb3JIYW5kbGVyIiwidHJ5Q2F0Y2hTdG9yYWdlIiwib3BlcmF0aW9uTmFtZSIsIm9wdGlvbnMiLCJyZXN1bHQiLCJlcnIiLCJpc0NyaXRpY2FsIiwibG9nT25seUNyaXRpY2FsIiwic3VwcHJlc3NOb3RpZmljYXRpb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/errorHandling.ts\n"));

/***/ })

});