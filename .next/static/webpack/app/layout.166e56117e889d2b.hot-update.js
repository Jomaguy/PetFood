"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/utils/storageUtils.ts":
/*!***********************************!*\
  !*** ./src/utils/storageUtils.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupOldBackups: () => (/* binding */ cleanupOldBackups),\n/* harmony export */   cleanupStorage: () => (/* binding */ cleanupStorage),\n/* harmony export */   createBackup: () => (/* binding */ createBackup),\n/* harmony export */   downloadExportedData: () => (/* binding */ downloadExportedData),\n/* harmony export */   exportData: () => (/* binding */ exportData),\n/* harmony export */   getStorageStats: () => (/* binding */ getStorageStats),\n/* harmony export */   getStorageUsage: () => (/* binding */ getStorageUsage),\n/* harmony export */   importData: () => (/* binding */ importData),\n/* harmony export */   importDataFromFile: () => (/* binding */ importDataFromFile),\n/* harmony export */   importDataWithStrategy: () => (/* binding */ importDataWithStrategy),\n/* harmony export */   isStorageAvailable: () => (/* binding */ isStorageAvailable),\n/* harmony export */   isStorageNearlyFull: () => (/* binding */ isStorageNearlyFull),\n/* harmony export */   loadDogProfiles: () => (/* binding */ loadDogProfiles),\n/* harmony export */   loadFromStorage: () => (/* binding */ loadFromStorage),\n/* harmony export */   loadRecommendations: () => (/* binding */ loadRecommendations),\n/* harmony export */   restoreFromBackup: () => (/* binding */ restoreFromBackup),\n/* harmony export */   saveDogProfiles: () => (/* binding */ saveDogProfiles),\n/* harmony export */   saveRecommendations: () => (/* binding */ saveRecommendations),\n/* harmony export */   saveToStorage: () => (/* binding */ saveToStorage)\n/* harmony export */ });\n/* harmony import */ var _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/storageSchema */ \"(app-pages-browser)/./src/types/storageSchema.ts\");\n/* harmony import */ var _errorHandling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errorHandling */ \"(app-pages-browser)/./src/utils/errorHandling.ts\");\n\n\n// Add this right after the imports\n// Extend StorageErrorType with a new error type for cleanup operations\n// We'll use UNKNOWN_ERROR as a fallback if CLEANUP_ERROR is not available\nconst CLEANUP_ERROR = _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.UNKNOWN_ERROR;\n/**\n * Check if local storage is available\n * @returns true if available, false otherwise\n */ function isStorageAvailable() {\n    try {\n        const testKey = '__storage_test__';\n        localStorage.setItem(testKey, 'test');\n        const result = localStorage.getItem(testKey) === 'test';\n        localStorage.removeItem(testKey);\n        return result;\n    } catch (e) {\n        return false;\n    }\n}\n/**\n * Get the estimated local storage space usage in bytes\n * @returns Object containing used space and available space (if possible to determine)\n */ function getStorageUsage() {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        let totalSize = 0;\n        // Estimate space used by iterating through all keys\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if (key) {\n                const value = localStorage.getItem(key) || '';\n                totalSize += key.length + value.length;\n            }\n        }\n        // Convert to bytes (approximate as 2 bytes per character in UTF-16)\n        const usedBytes = totalSize * 2;\n        // Local storage limit is typically 5MB, but this varies by browser\n        const estimatedLimit = 5 * 1024 * 1024;\n        return {\n            used: usedBytes,\n            available: estimatedLimit - usedBytes,\n            percentUsed: usedBytes / estimatedLimit * 100\n        };\n    }, 'getStorageUsage');\n    if (error) {\n        return {\n            used: 0\n        };\n    }\n    return result || {\n        used: 0\n    };\n}\n/**\n * Check if storage is nearly full (over specified threshold)\n * @param thresholdPercent Percentage threshold (default: 80%)\n * @returns true if storage usage is over threshold\n */ function isStorageNearlyFull() {\n    let thresholdPercent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 80;\n    const usage = getStorageUsage();\n    return !!usage.percentUsed && usage.percentUsed > thresholdPercent;\n}\n/**\n * Save data to local storage with versioning\n * @param key Storage key\n * @param data Data to save\n * @throws StorageError if storage is not available or saving fails\n */ function saveToStorage(key, data) {\n    if (!isStorageAvailable()) {\n        throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Local storage is not available', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.STORAGE_UNAVAILABLE);\n    }\n    // Check if storage is nearly full\n    if (isStorageNearlyFull()) {\n        console.warn('Local storage is nearly full. Consider cleaning up old data.');\n    }\n    try {\n        // Create versioned data container\n        const storageData = {\n            version: _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.SCHEMA_VERSION,\n            updatedAt: Date.now(),\n            data\n        };\n        // Serialize and save\n        localStorage.setItem(key, JSON.stringify(storageData));\n    } catch (error) {\n        // Determine if this is a quota error\n        if (error instanceof Error && error.name === 'QuotaExceededError') {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Storage quota exceeded', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.STORAGE_QUOTA_EXCEEDED, {\n                originalError: error\n            });\n        }\n        throw (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.handleStorageError)(error, \"saveToStorage(\".concat(key, \")\"), _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.WRITE_ERROR);\n    }\n}\n/**\n * Load data from local storage with version checking\n * @param key Storage key\n * @param defaultValue Default value if not found or invalid\n * @returns The stored data or default value\n */ function loadFromStorage(key, defaultValue) {\n    if (!isStorageAvailable()) {\n        console.warn('Local storage is not available');\n        return defaultValue;\n    }\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        // Get serialized data\n        const serialized = localStorage.getItem(key);\n        if (!serialized) {\n            return defaultValue;\n        }\n        // Parse serialized data\n        const parsedData = JSON.parse(serialized);\n        // Version check\n        if (parsedData.version !== _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.SCHEMA_VERSION) {\n            console.warn(\"Storage schema version mismatch for \".concat(key, \". Expected \").concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.SCHEMA_VERSION, \", got \").concat(parsedData.version));\n            // Here we would add migration logic for different versions\n            // For now just return default\n            return defaultValue;\n        }\n        return parsedData;\n    }, \"loadFromStorage(\".concat(key, \")\"));\n    if (error) {\n        // Attempt to recover from backup on error\n        const backupResult = tryRestoreItemFromBackup(key);\n        if (backupResult.success && backupResult.data) {\n            try {\n                const parsedBackup = JSON.parse(backupResult.data);\n                return parsedBackup;\n            } catch (e) {\n                // If backup parsing fails, return default\n                return defaultValue;\n            }\n        }\n        return defaultValue;\n    }\n    return result || defaultValue;\n}\n/**\n * Try to restore a single item from its backup\n * @param key The key of the item to restore\n * @returns Success status and data if successful\n */ function tryRestoreItemFromBackup(key) {\n    try {\n        // Find backups for this specific key\n        const backupKey = \"\".concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX).concat(key);\n        const backupData = localStorage.getItem(backupKey);\n        if (backupData) {\n            // Restore from backup\n            localStorage.setItem(key, backupData);\n            return {\n                success: true,\n                data: backupData\n            };\n        }\n        return {\n            success: false,\n            data: null\n        };\n    } catch (e) {\n        return {\n            success: false,\n            data: null\n        };\n    }\n}\n/**\n * Create a backup of all application data\n * @returns true if backup successful, false otherwise\n */ function createBackup() {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        if (!isStorageAvailable()) {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Local storage is not available, cannot create backup', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.STORAGE_UNAVAILABLE);\n        }\n        const timestamp = Date.now();\n        const backupKey = \"\".concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX).concat(timestamp);\n        // Create a backup object with all app data\n        const backup = {\n            timestamp,\n            version: _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.SCHEMA_VERSION,\n            dogProfiles: localStorage.getItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES),\n            savedRecommendations: localStorage.getItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS),\n            userPreferences: localStorage.getItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES)\n        };\n        localStorage.setItem(backupKey, JSON.stringify(backup));\n        // Also create individual backups of each key\n        if (backup.dogProfiles) {\n            localStorage.setItem(\"\".concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX).concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES), backup.dogProfiles);\n        }\n        if (backup.savedRecommendations) {\n            localStorage.setItem(\"\".concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX).concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS), backup.savedRecommendations);\n        }\n        if (backup.userPreferences) {\n            localStorage.setItem(\"\".concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX).concat(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES), backup.userPreferences);\n        }\n        return true;\n    }, 'createBackup', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.BACKUP_ERROR);\n    return result === true;\n}\n/**\n * Restore data from the most recent backup\n * @returns true if restore successful, false otherwise\n */ function restoreFromBackup() {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        if (!isStorageAvailable()) {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Local storage is not available, cannot restore backup', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.STORAGE_UNAVAILABLE);\n        }\n        // Find the latest backup\n        let latestBackupKey = null;\n        let latestTimestamp = 0;\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if (key && key.startsWith(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES)) {\n                try {\n                    const timestamp = parseInt(key.replace(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX, ''), 10);\n                    if (!isNaN(timestamp) && timestamp > latestTimestamp) {\n                        latestTimestamp = timestamp;\n                        latestBackupKey = key;\n                    }\n                } catch (e) {\n                    continue;\n                }\n            }\n        }\n        if (!latestBackupKey) {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('No backup found', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.RESTORE_ERROR);\n        }\n        // Restore from backup\n        const serializedBackup = localStorage.getItem(latestBackupKey);\n        if (!serializedBackup) {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Backup is empty or corrupted', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.RESTORE_ERROR);\n        }\n        const backup = JSON.parse(serializedBackup);\n        if (backup.dogProfiles) {\n            localStorage.setItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, backup.dogProfiles);\n        }\n        if (backup.savedRecommendations) {\n            localStorage.setItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, backup.savedRecommendations);\n        }\n        if (backup.userPreferences) {\n            localStorage.setItem(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, backup.userPreferences);\n        }\n        return true;\n    }, 'restoreFromBackup', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.RESTORE_ERROR);\n    return result === true;\n}\n/**\n * Remove old backups, keeping only the most recent ones\n * @param keepCount Number of recent backups to keep (default: 3)\n * @returns number of backups removed\n */ function cleanupOldBackups() {\n    let keepCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        if (!isStorageAvailable()) {\n            return 0;\n        }\n        // Find all backups and their timestamps\n        const backups = [];\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if (key && key.startsWith(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES)) {\n                try {\n                    const timestamp = parseInt(key.replace(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX, ''), 10);\n                    if (!isNaN(timestamp)) {\n                        backups.push({\n                            key,\n                            timestamp\n                        });\n                    }\n                } catch (e) {\n                    continue;\n                }\n            }\n        }\n        // Sort by timestamp (newest first)\n        backups.sort((a, b)=>b.timestamp - a.timestamp);\n        // Remove old backups keeping the most recent ones\n        let removedCount = 0;\n        if (backups.length > keepCount) {\n            const toRemove = backups.slice(keepCount);\n            toRemove.forEach((backup)=>{\n                localStorage.removeItem(backup.key);\n                removedCount++;\n            });\n        }\n        return removedCount;\n    }, 'cleanupOldBackups');\n    return result || 0;\n}\n/**\n * Save dog profiles to storage\n * @param profiles Map of dog profiles by ID\n * @param activeProfileId ID of the active profile (optional)\n */ function saveDogProfiles(profiles, activeProfileId) {\n    const data = {\n        profiles,\n        activeProfileId\n    };\n    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, data);\n}\n/**\n * Load dog profiles from storage\n * @returns The stored dog profiles or default empty data\n */ function loadDogProfiles() {\n    return loadFromStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_DOG_PROFILES_STORAGE);\n}\n/**\n * Save saved recommendations to storage\n * @param recommendations Map of saved recommendations by product ID\n */ function saveRecommendations(recommendations) {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        const savedDates = {};\n        // Update timestamps for any new recommendations\n        Object.keys(recommendations).forEach((id)=>{\n            // Use existing timestamp if available, otherwise use current time\n            savedDates[id] = Date.now();\n        });\n        const data = {\n            recommendations,\n            savedDates\n        };\n        saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, data);\n    }, 'saveRecommendations');\n    if (error) {\n        throw error;\n    }\n}\n/**\n * Load saved recommendations from storage\n * @returns The stored recommendations or default empty data\n */ function loadRecommendations() {\n    return loadFromStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SAVED_RECOMMENDATIONS_STORAGE);\n}\n/**\n * Export all user data to a downloadable JSON file\n * @returns JSON string of all user data\n */ function exportData() {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        const dogProfiles = loadDogProfiles();\n        const savedRecommendations = loadRecommendations();\n        const userPreferences = loadFromStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_USER_PREFERENCES_STORAGE);\n        const exportData = {\n            schemaVersion: _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.SCHEMA_VERSION,\n            exportDate: new Date().toISOString(),\n            dogProfiles,\n            savedRecommendations,\n            userPreferences\n        };\n        return JSON.stringify(exportData, null, 2);\n    }, 'exportData', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.EXPORT_ERROR);\n    if (error) {\n        throw error;\n    }\n    return result || '{}';\n}\n/**\n * Import user data from a JSON string\n * @param jsonData JSON string with user data\n * @returns true if import successful, false otherwise\n */ function importData(jsonData) {\n    return importDataWithStrategy(jsonData, 'replace');\n}\n/**\n * Cleanup old or unused data from storage based on age threshold\n * @param olderThanDays Number of days after which data is considered old (default: 90)\n * @returns Object with counts of items cleaned up by category\n */ function cleanupStorage() {\n    let olderThanDays = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 90;\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        var _savedRecommendations_data, _savedRecommendations_data1;\n        if (!isStorageAvailable()) {\n            return {\n                recommendations: 0,\n                oldBackups: 0,\n                total: 0\n            };\n        }\n        const now = Date.now();\n        const ageThreshold = now - olderThanDays * 24 * 60 * 60 * 1000; // Convert days to milliseconds\n        let removedRecommendations = 0;\n        // Clean up old saved recommendations\n        const savedRecommendations = loadRecommendations();\n        if ((savedRecommendations === null || savedRecommendations === void 0 ? void 0 : (_savedRecommendations_data = savedRecommendations.data) === null || _savedRecommendations_data === void 0 ? void 0 : _savedRecommendations_data.recommendations) && (savedRecommendations === null || savedRecommendations === void 0 ? void 0 : (_savedRecommendations_data1 = savedRecommendations.data) === null || _savedRecommendations_data1 === void 0 ? void 0 : _savedRecommendations_data1.savedDates)) {\n            const { recommendations, savedDates } = savedRecommendations.data;\n            const updatedRecommendations = {};\n            const updatedSavedDates = {};\n            Object.entries(recommendations).forEach((param)=>{\n                let [id, recommendation] = param;\n                const savedDate = savedDates[id] || 0;\n                // Keep recommendations newer than the threshold\n                if (savedDate > ageThreshold) {\n                    updatedRecommendations[id] = recommendation;\n                    updatedSavedDates[id] = savedDate;\n                } else {\n                    removedRecommendations++;\n                }\n            });\n            // Only save if we removed any recommendations\n            if (removedRecommendations > 0) {\n                saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, {\n                    recommendations: updatedRecommendations,\n                    savedDates: updatedSavedDates\n                });\n            }\n        }\n        // Clean up old backups\n        const oldBackups = cleanupOldBackups(3); // Keep 3 most recent backups\n        const totalRemoved = removedRecommendations + oldBackups;\n        return {\n            recommendations: removedRecommendations,\n            oldBackups,\n            total: totalRemoved\n        };\n    }, 'cleanupStorage', CLEANUP_ERROR);\n    return result || {\n        recommendations: 0,\n        oldBackups: 0,\n        total: 0\n    };\n}\n/**\n * Download exported data as a JSON file\n * @param filename Custom filename (default: 'petfood-data-export.json')\n * @returns true if download initiated successfully, false otherwise\n */ function downloadExportedData() {\n    let filename = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'petfood-data-export.json';\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        const exportString = exportData();\n        // Create a Blob with the data\n        const blob = new Blob([\n            exportString\n        ], {\n            type: 'application/json'\n        });\n        const url = URL.createObjectURL(blob);\n        // Create a temporary link and trigger download\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = filename;\n        document.body.appendChild(link);\n        link.click();\n        // Clean up\n        setTimeout(()=>{\n            URL.revokeObjectURL(url);\n            document.body.removeChild(link);\n        }, 100);\n        return true;\n    }, 'downloadExportedData', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.EXPORT_ERROR);\n    return result === true;\n}\n/**\n * Import data from an uploaded file\n * @param file The uploaded File object\n * @param mergeStrategy How to handle existing data ('replace', 'merge', 'keep-newer')\n * @returns Promise resolving to true if import successful, false otherwise\n */ async function importDataFromFile(file) {\n    let mergeStrategy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'replace';\n    return new Promise((resolve)=>{\n        const reader = new FileReader();\n        reader.onload = (event)=>{\n            try {\n                var _event_target;\n                const jsonData = (_event_target = event.target) === null || _event_target === void 0 ? void 0 : _event_target.result;\n                const success = importDataWithStrategy(jsonData, mergeStrategy);\n                resolve(success);\n            } catch (error) {\n                console.error('Error importing data from file:', error);\n                resolve(false);\n            }\n        };\n        reader.onerror = ()=>{\n            console.error('Error reading file');\n            resolve(false);\n        };\n        reader.readAsText(file);\n    });\n}\n/**\n * Import data with the specified merge strategy\n * @param jsonData JSON string with user data\n * @param mergeStrategy How to handle existing data ('replace', 'merge', 'keep-newer')\n * @returns true if import successful, false otherwise\n */ function importDataWithStrategy(jsonData) {\n    let mergeStrategy = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'replace';\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        var _importedData_dogProfiles_data, _importedData_dogProfiles, _importedData_savedRecommendations_data, _importedData_savedRecommendations, _importedData_userPreferences;\n        const importedData = JSON.parse(jsonData);\n        // Validate imported data\n        if (!importedData.schemaVersion || !importedData.exportDate) {\n            throw new _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageError('Invalid export data format', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.IMPORT_ERROR);\n        }\n        // Create backup before making any changes\n        createBackup();\n        // Handle dog profiles based on merge strategy\n        if ((_importedData_dogProfiles = importedData.dogProfiles) === null || _importedData_dogProfiles === void 0 ? void 0 : (_importedData_dogProfiles_data = _importedData_dogProfiles.data) === null || _importedData_dogProfiles_data === void 0 ? void 0 : _importedData_dogProfiles_data.profiles) {\n            if (mergeStrategy === 'replace') {\n                // Simply replace existing data\n                saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, importedData.dogProfiles.data);\n            } else {\n                var _existingProfiles_data;\n                // Merge or keep-newer strategies\n                const existingProfiles = loadDogProfiles();\n                if (existingProfiles === null || existingProfiles === void 0 ? void 0 : (_existingProfiles_data = existingProfiles.data) === null || _existingProfiles_data === void 0 ? void 0 : _existingProfiles_data.profiles) {\n                    const mergedProfiles = {\n                        ...existingProfiles.data\n                    };\n                    // Process each imported profile\n                    Object.entries(importedData.dogProfiles.data.profiles).forEach((param)=>{\n                        let [id, profile] = param;\n                        const existingProfile = mergedProfiles.profiles[id];\n                        if (!existingProfile) {\n                            // Profile doesn't exist in current data, add it\n                            mergedProfiles.profiles[id] = profile;\n                        } else if (mergeStrategy === 'keep-newer') {\n                            // Compare update timestamps and keep newer\n                            const importedTimestamp = importedData.dogProfiles.updatedAt || 0;\n                            const existingTimestamp = existingProfiles.updatedAt || 0;\n                            if (importedTimestamp > existingTimestamp) {\n                                mergedProfiles.profiles[id] = profile;\n                            }\n                        } else {\n                            // For 'merge' strategy, always update\n                            mergedProfiles.profiles[id] = profile;\n                        }\n                    });\n                    // Save merged profiles\n                    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, mergedProfiles);\n                } else {\n                    // No existing profiles, just import\n                    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES, importedData.dogProfiles.data);\n                }\n            }\n        }\n        // Handle recommendations with similar merge strategy\n        if ((_importedData_savedRecommendations = importedData.savedRecommendations) === null || _importedData_savedRecommendations === void 0 ? void 0 : (_importedData_savedRecommendations_data = _importedData_savedRecommendations.data) === null || _importedData_savedRecommendations_data === void 0 ? void 0 : _importedData_savedRecommendations_data.recommendations) {\n            if (mergeStrategy === 'replace') {\n                saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, importedData.savedRecommendations.data);\n            } else {\n                var _existingRecommendations_data;\n                const existingRecommendations = loadRecommendations();\n                if (existingRecommendations === null || existingRecommendations === void 0 ? void 0 : (_existingRecommendations_data = existingRecommendations.data) === null || _existingRecommendations_data === void 0 ? void 0 : _existingRecommendations_data.recommendations) {\n                    const mergedRecommendations = {\n                        recommendations: {\n                            ...existingRecommendations.data.recommendations\n                        },\n                        savedDates: {\n                            ...existingRecommendations.data.savedDates\n                        }\n                    };\n                    // Process each imported recommendation\n                    Object.entries(importedData.savedRecommendations.data.recommendations).forEach((param)=>{\n                        let [id, recommendation] = param;\n                        var _importedData_savedRecommendations_data_savedDates;\n                        const existingRecommendation = mergedRecommendations.recommendations[id];\n                        const importedSavedDate = ((_importedData_savedRecommendations_data_savedDates = importedData.savedRecommendations.data.savedDates) === null || _importedData_savedRecommendations_data_savedDates === void 0 ? void 0 : _importedData_savedRecommendations_data_savedDates[id]) || 0;\n                        const existingSavedDate = mergedRecommendations.savedDates[id] || 0;\n                        if (!existingRecommendation) {\n                            // Recommendation doesn't exist, add it\n                            mergedRecommendations.recommendations[id] = recommendation;\n                            mergedRecommendations.savedDates[id] = importedSavedDate;\n                        } else if (mergeStrategy === 'keep-newer' && importedSavedDate > existingSavedDate) {\n                            // 'keep-newer' strategy - update if imported is newer\n                            mergedRecommendations.recommendations[id] = recommendation;\n                            mergedRecommendations.savedDates[id] = importedSavedDate;\n                        } else if (mergeStrategy === 'merge') {\n                            // 'merge' strategy - always update\n                            mergedRecommendations.recommendations[id] = recommendation;\n                            mergedRecommendations.savedDates[id] = importedSavedDate;\n                        }\n                    });\n                    // Save merged recommendations\n                    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, mergedRecommendations);\n                } else {\n                    // No existing recommendations, just import\n                    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS, importedData.savedRecommendations.data);\n                }\n            }\n        }\n        // Handle user preferences\n        if ((_importedData_userPreferences = importedData.userPreferences) === null || _importedData_userPreferences === void 0 ? void 0 : _importedData_userPreferences.data) {\n            if (mergeStrategy === 'replace') {\n                saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, importedData.userPreferences.data);\n            } else {\n                const existingPreferences = loadFromStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, _types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_USER_PREFERENCES_STORAGE);\n                if (existingPreferences === null || existingPreferences === void 0 ? void 0 : existingPreferences.data) {\n                    if (mergeStrategy === 'keep-newer') {\n                        const importedTimestamp = importedData.userPreferences.updatedAt || 0;\n                        const existingTimestamp = existingPreferences.updatedAt || 0;\n                        if (importedTimestamp > existingTimestamp) {\n                            saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, importedData.userPreferences.data);\n                        }\n                    } else {\n                        // For 'merge' strategy, merge objects\n                        const mergedPreferences = {\n                            ...existingPreferences.data,\n                            ...importedData.userPreferences.data\n                        };\n                        saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, mergedPreferences);\n                    }\n                } else {\n                    // No existing preferences, just import\n                    saveToStorage(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES, importedData.userPreferences.data);\n                }\n            }\n        }\n        return true;\n    }, 'importDataWithStrategy', _errorHandling__WEBPACK_IMPORTED_MODULE_1__.StorageErrorType.IMPORT_ERROR);\n    return result === true;\n}\n/**\n * Get statistics about storage usage and item counts\n * @returns Object with storage usage statistics\n */ function getStorageStats() {\n    const { result, error } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        var _dogProfiles_data, _savedRecommendations_data;\n        // Get storage usage\n        const usage = getStorageUsage();\n        // Count items\n        const dogProfiles = loadDogProfiles();\n        const savedRecommendations = loadRecommendations();\n        // Count backups\n        let backupCount = 0;\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if (key && key.startsWith(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES)) {\n                backupCount++;\n            }\n        }\n        // Get profile and recommendation counts\n        const profileCount = (dogProfiles === null || dogProfiles === void 0 ? void 0 : (_dogProfiles_data = dogProfiles.data) === null || _dogProfiles_data === void 0 ? void 0 : _dogProfiles_data.profiles) ? Object.keys(dogProfiles.data.profiles).length : 0;\n        const recommendationCount = (savedRecommendations === null || savedRecommendations === void 0 ? void 0 : (_savedRecommendations_data = savedRecommendations.data) === null || _savedRecommendations_data === void 0 ? void 0 : _savedRecommendations_data.recommendations) ? Object.keys(savedRecommendations.data.recommendations).length : 0;\n        return {\n            usage,\n            counts: {\n                dogProfiles: profileCount,\n                savedRecommendations: recommendationCount,\n                backups: backupCount\n            },\n            lastUpdated: {\n                dogProfiles: dogProfiles === null || dogProfiles === void 0 ? void 0 : dogProfiles.updatedAt,\n                savedRecommendations: savedRecommendations === null || savedRecommendations === void 0 ? void 0 : savedRecommendations.updatedAt,\n                backups: getLatestBackupTimestamp()\n            }\n        };\n    }, 'getStorageStats');\n    return result || {\n        usage: {\n            used: 0\n        },\n        counts: {\n            dogProfiles: 0,\n            savedRecommendations: 0,\n            backups: 0\n        },\n        lastUpdated: {}\n    };\n}\n/**\n * Get the timestamp of the most recent backup\n * @returns Timestamp of the most recent backup, or undefined if none exists\n */ function getLatestBackupTimestamp() {\n    const { result } = (0,_errorHandling__WEBPACK_IMPORTED_MODULE_1__.tryCatchStorage)(()=>{\n        let latestTimestamp;\n        for(let i = 0; i < localStorage.length; i++){\n            const key = localStorage.key(i);\n            if (key && key.startsWith(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.DOG_PROFILES) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.SAVED_RECOMMENDATIONS) && !key.includes(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.USER_PREFERENCES)) {\n                try {\n                    const timestamp = parseInt(key.replace(_types_storageSchema__WEBPACK_IMPORTED_MODULE_0__.StorageKey.BACKUP_PREFIX, ''), 10);\n                    if (!isNaN(timestamp) && (!latestTimestamp || timestamp > latestTimestamp)) {\n                        latestTimestamp = timestamp;\n                    }\n                } catch (e) {\n                    continue;\n                }\n            }\n        }\n        return latestTimestamp;\n    }, 'getLatestBackupTimestamp');\n    return result || undefined;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9zdG9yYWdlVXRpbHMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBVWdDO0FBR3NFO0FBRXRHLG1DQUFtQztBQUNuQyx1RUFBdUU7QUFDdkUsMEVBQTBFO0FBQzFFLE1BQU1TLGdCQUFnQkgsNERBQWdCQSxDQUFDSSxhQUFhO0FBRXBEOzs7Q0FHQyxHQUNNLFNBQVNDO0lBQ2QsSUFBSTtRQUNGLE1BQU1DLFVBQVU7UUFDaEJDLGFBQWFDLE9BQU8sQ0FBQ0YsU0FBUztRQUM5QixNQUFNRyxTQUFTRixhQUFhRyxPQUFPLENBQUNKLGFBQWE7UUFDakRDLGFBQWFJLFVBQVUsQ0FBQ0w7UUFDeEIsT0FBT0c7SUFDVCxFQUFFLE9BQU9HLEdBQUc7UUFDVixPQUFPO0lBQ1Q7QUFDRjtBQUVBOzs7Q0FHQyxHQUNNLFNBQVNDO0lBQ2QsTUFBTSxFQUFFSixNQUFNLEVBQUVLLEtBQUssRUFBRSxHQUFHWiwrREFBZUEsQ0FBQztRQUN4QyxJQUFJYSxZQUFZO1FBRWhCLG9EQUFvRDtRQUNwRCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVQsYUFBYVUsTUFBTSxFQUFFRCxJQUFLO1lBQzVDLE1BQU1FLE1BQU1YLGFBQWFXLEdBQUcsQ0FBQ0Y7WUFDN0IsSUFBSUUsS0FBSztnQkFDUCxNQUFNQyxRQUFRWixhQUFhRyxPQUFPLENBQUNRLFFBQVE7Z0JBQzNDSCxhQUFhRyxJQUFJRCxNQUFNLEdBQUdFLE1BQU1GLE1BQU07WUFDeEM7UUFDRjtRQUVBLG9FQUFvRTtRQUNwRSxNQUFNRyxZQUFZTCxZQUFZO1FBRTlCLG1FQUFtRTtRQUNuRSxNQUFNTSxpQkFBaUIsSUFBSSxPQUFPO1FBRWxDLE9BQU87WUFDTEMsTUFBTUY7WUFDTkcsV0FBV0YsaUJBQWlCRDtZQUM1QkksYUFBYSxZQUFhSCxpQkFBa0I7UUFDOUM7SUFDRixHQUFHO0lBRUgsSUFBSVAsT0FBTztRQUNULE9BQU87WUFBRVEsTUFBTTtR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dXlvdS9EZXNrdG9wL0pvTWFHdXkgUHJvamVjdHMvUGV0Rm9vZC9zcmMvdXRpbHMvc3RvcmFnZVV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFxuICBCYXNlU3RvcmFnZVNjaGVtYSwgXG4gIFNDSEVNQV9WRVJTSU9OLCBcbiAgU3RvcmFnZUtleSxcbiAgREVGQVVMVF9ET0dfUFJPRklMRVNfU1RPUkFHRSxcbiAgREVGQVVMVF9TQVZFRF9SRUNPTU1FTkRBVElPTlNfU1RPUkFHRSxcbiAgREVGQVVMVF9VU0VSX1BSRUZFUkVOQ0VTX1NUT1JBR0UsXG4gIERvZ1Byb2ZpbGVzU3RvcmFnZVNjaGVtYSxcbiAgU2F2ZWRSZWNvbW1lbmRhdGlvbnNTdG9yYWdlU2NoZW1hLFxuICBVc2VyUHJlZmVyZW5jZXNTdG9yYWdlU2NoZW1hXG59IGZyb20gJy4uL3R5cGVzL3N0b3JhZ2VTY2hlbWEnO1xuaW1wb3J0IHsgRG9nUHJvZmlsZSB9IGZyb20gJy4uL3R5cGVzL2RvZ1Byb2ZpbGUnO1xuaW1wb3J0IHsgRm9vZFJlY29tbWVuZGF0aW9uIH0gZnJvbSAnLi9yZWNvbW1lbmRhdGlvbkFsZ29yaXRobSc7XG5pbXBvcnQgeyBTdG9yYWdlRXJyb3IsIFN0b3JhZ2VFcnJvclR5cGUsIGhhbmRsZVN0b3JhZ2VFcnJvciwgdHJ5Q2F0Y2hTdG9yYWdlIH0gZnJvbSAnLi9lcnJvckhhbmRsaW5nJztcblxuLy8gQWRkIHRoaXMgcmlnaHQgYWZ0ZXIgdGhlIGltcG9ydHNcbi8vIEV4dGVuZCBTdG9yYWdlRXJyb3JUeXBlIHdpdGggYSBuZXcgZXJyb3IgdHlwZSBmb3IgY2xlYW51cCBvcGVyYXRpb25zXG4vLyBXZSdsbCB1c2UgVU5LTk9XTl9FUlJPUiBhcyBhIGZhbGxiYWNrIGlmIENMRUFOVVBfRVJST1IgaXMgbm90IGF2YWlsYWJsZVxuY29uc3QgQ0xFQU5VUF9FUlJPUiA9IFN0b3JhZ2VFcnJvclR5cGUuVU5LTk9XTl9FUlJPUjtcblxuLyoqXG4gKiBDaGVjayBpZiBsb2NhbCBzdG9yYWdlIGlzIGF2YWlsYWJsZVxuICogQHJldHVybnMgdHJ1ZSBpZiBhdmFpbGFibGUsIGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdG9yYWdlQXZhaWxhYmxlKCk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIGNvbnN0IHRlc3RLZXkgPSAnX19zdG9yYWdlX3Rlc3RfXyc7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odGVzdEtleSwgJ3Rlc3QnKTtcbiAgICBjb25zdCByZXN1bHQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0ZXN0S2V5KSA9PT0gJ3Rlc3QnO1xuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRlc3RLZXkpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIGVzdGltYXRlZCBsb2NhbCBzdG9yYWdlIHNwYWNlIHVzYWdlIGluIGJ5dGVzXG4gKiBAcmV0dXJucyBPYmplY3QgY29udGFpbmluZyB1c2VkIHNwYWNlIGFuZCBhdmFpbGFibGUgc3BhY2UgKGlmIHBvc3NpYmxlIHRvIGRldGVybWluZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0b3JhZ2VVc2FnZSgpOiB7IHVzZWQ6IG51bWJlcjsgYXZhaWxhYmxlPzogbnVtYmVyOyBwZXJjZW50VXNlZD86IG51bWJlciB9IHtcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB0cnlDYXRjaFN0b3JhZ2UoKCkgPT4ge1xuICAgIGxldCB0b3RhbFNpemUgPSAwO1xuICAgIFxuICAgIC8vIEVzdGltYXRlIHNwYWNlIHVzZWQgYnkgaXRlcmF0aW5nIHRocm91Z2ggYWxsIGtleXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpIHx8ICcnO1xuICAgICAgICB0b3RhbFNpemUgKz0ga2V5Lmxlbmd0aCArIHZhbHVlLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ29udmVydCB0byBieXRlcyAoYXBwcm94aW1hdGUgYXMgMiBieXRlcyBwZXIgY2hhcmFjdGVyIGluIFVURi0xNilcbiAgICBjb25zdCB1c2VkQnl0ZXMgPSB0b3RhbFNpemUgKiAyO1xuICAgIFxuICAgIC8vIExvY2FsIHN0b3JhZ2UgbGltaXQgaXMgdHlwaWNhbGx5IDVNQiwgYnV0IHRoaXMgdmFyaWVzIGJ5IGJyb3dzZXJcbiAgICBjb25zdCBlc3RpbWF0ZWRMaW1pdCA9IDUgKiAxMDI0ICogMTAyNDtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgdXNlZDogdXNlZEJ5dGVzLFxuICAgICAgYXZhaWxhYmxlOiBlc3RpbWF0ZWRMaW1pdCAtIHVzZWRCeXRlcyxcbiAgICAgIHBlcmNlbnRVc2VkOiAodXNlZEJ5dGVzIC8gZXN0aW1hdGVkTGltaXQpICogMTAwXG4gICAgfTtcbiAgfSwgJ2dldFN0b3JhZ2VVc2FnZScpO1xuICBcbiAgaWYgKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgdXNlZDogMCB9O1xuICB9XG4gIFxuICByZXR1cm4gcmVzdWx0IHx8IHsgdXNlZDogMCB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHN0b3JhZ2UgaXMgbmVhcmx5IGZ1bGwgKG92ZXIgc3BlY2lmaWVkIHRocmVzaG9sZClcbiAqIEBwYXJhbSB0aHJlc2hvbGRQZXJjZW50IFBlcmNlbnRhZ2UgdGhyZXNob2xkIChkZWZhdWx0OiA4MCUpXG4gKiBAcmV0dXJucyB0cnVlIGlmIHN0b3JhZ2UgdXNhZ2UgaXMgb3ZlciB0aHJlc2hvbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RvcmFnZU5lYXJseUZ1bGwodGhyZXNob2xkUGVyY2VudDogbnVtYmVyID0gODApOiBib29sZWFuIHtcbiAgY29uc3QgdXNhZ2UgPSBnZXRTdG9yYWdlVXNhZ2UoKTtcbiAgcmV0dXJuICEhdXNhZ2UucGVyY2VudFVzZWQgJiYgdXNhZ2UucGVyY2VudFVzZWQgPiB0aHJlc2hvbGRQZXJjZW50O1xufVxuXG4vKipcbiAqIFNhdmUgZGF0YSB0byBsb2NhbCBzdG9yYWdlIHdpdGggdmVyc2lvbmluZ1xuICogQHBhcmFtIGtleSBTdG9yYWdlIGtleVxuICogQHBhcmFtIGRhdGEgRGF0YSB0byBzYXZlXG4gKiBAdGhyb3dzIFN0b3JhZ2VFcnJvciBpZiBzdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgb3Igc2F2aW5nIGZhaWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYXZlVG9TdG9yYWdlPFQ+KGtleTogc3RyaW5nLCBkYXRhOiBUKTogdm9pZCB7XG4gIGlmICghaXNTdG9yYWdlQXZhaWxhYmxlKCkpIHtcbiAgICB0aHJvdyBuZXcgU3RvcmFnZUVycm9yKFxuICAgICAgJ0xvY2FsIHN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZScsXG4gICAgICBTdG9yYWdlRXJyb3JUeXBlLlNUT1JBR0VfVU5BVkFJTEFCTEVcbiAgICApO1xuICB9XG4gIFxuICAvLyBDaGVjayBpZiBzdG9yYWdlIGlzIG5lYXJseSBmdWxsXG4gIGlmIChpc1N0b3JhZ2VOZWFybHlGdWxsKCkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0xvY2FsIHN0b3JhZ2UgaXMgbmVhcmx5IGZ1bGwuIENvbnNpZGVyIGNsZWFuaW5nIHVwIG9sZCBkYXRhLicpO1xuICB9XG4gIFxuICB0cnkge1xuICAgIC8vIENyZWF0ZSB2ZXJzaW9uZWQgZGF0YSBjb250YWluZXJcbiAgICBjb25zdCBzdG9yYWdlRGF0YTogQmFzZVN0b3JhZ2VTY2hlbWE8VD4gPSB7XG4gICAgICB2ZXJzaW9uOiBTQ0hFTUFfVkVSU0lPTixcbiAgICAgIHVwZGF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIFxuICAgIC8vIFNlcmlhbGl6ZSBhbmQgc2F2ZVxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkoc3RvcmFnZURhdGEpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhpcyBpcyBhIHF1b3RhIGVycm9yXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gJ1F1b3RhRXhjZWVkZWRFcnJvcicpIHtcbiAgICAgIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoXG4gICAgICAgICdTdG9yYWdlIHF1b3RhIGV4Y2VlZGVkJyxcbiAgICAgICAgU3RvcmFnZUVycm9yVHlwZS5TVE9SQUdFX1FVT1RBX0VYQ0VFREVELFxuICAgICAgICB7IG9yaWdpbmFsRXJyb3I6IGVycm9yIH1cbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIHRocm93IGhhbmRsZVN0b3JhZ2VFcnJvcihcbiAgICAgIGVycm9yLCBcbiAgICAgIGBzYXZlVG9TdG9yYWdlKCR7a2V5fSlgLCBcbiAgICAgIFN0b3JhZ2VFcnJvclR5cGUuV1JJVEVfRVJST1JcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogTG9hZCBkYXRhIGZyb20gbG9jYWwgc3RvcmFnZSB3aXRoIHZlcnNpb24gY2hlY2tpbmdcbiAqIEBwYXJhbSBrZXkgU3RvcmFnZSBrZXlcbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgRGVmYXVsdCB2YWx1ZSBpZiBub3QgZm91bmQgb3IgaW52YWxpZFxuICogQHJldHVybnMgVGhlIHN0b3JlZCBkYXRhIG9yIGRlZmF1bHQgdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWRGcm9tU3RvcmFnZTxUPihrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlOiBCYXNlU3RvcmFnZVNjaGVtYTxUPik6IEJhc2VTdG9yYWdlU2NoZW1hPFQ+IHtcbiAgaWYgKCFpc1N0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgIGNvbnNvbGUud2FybignTG9jYWwgc3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxuICBcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB0cnlDYXRjaFN0b3JhZ2UoKCkgPT4ge1xuICAgIC8vIEdldCBzZXJpYWxpemVkIGRhdGFcbiAgICBjb25zdCBzZXJpYWxpemVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICBcbiAgICBpZiAoIXNlcmlhbGl6ZWQpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIFxuICAgIC8vIFBhcnNlIHNlcmlhbGl6ZWQgZGF0YVxuICAgIGNvbnN0IHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKHNlcmlhbGl6ZWQpIGFzIEJhc2VTdG9yYWdlU2NoZW1hPFQ+O1xuICAgIFxuICAgIC8vIFZlcnNpb24gY2hlY2tcbiAgICBpZiAocGFyc2VkRGF0YS52ZXJzaW9uICE9PSBTQ0hFTUFfVkVSU0lPTikge1xuICAgICAgY29uc29sZS53YXJuKGBTdG9yYWdlIHNjaGVtYSB2ZXJzaW9uIG1pc21hdGNoIGZvciAke2tleX0uIEV4cGVjdGVkICR7U0NIRU1BX1ZFUlNJT059LCBnb3QgJHtwYXJzZWREYXRhLnZlcnNpb259YCk7XG4gICAgICAvLyBIZXJlIHdlIHdvdWxkIGFkZCBtaWdyYXRpb24gbG9naWMgZm9yIGRpZmZlcmVudCB2ZXJzaW9uc1xuICAgICAgLy8gRm9yIG5vdyBqdXN0IHJldHVybiBkZWZhdWx0XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcGFyc2VkRGF0YTtcbiAgfSwgYGxvYWRGcm9tU3RvcmFnZSgke2tleX0pYCk7XG4gIFxuICBpZiAoZXJyb3IpIHtcbiAgICAvLyBBdHRlbXB0IHRvIHJlY292ZXIgZnJvbSBiYWNrdXAgb24gZXJyb3JcbiAgICBjb25zdCBiYWNrdXBSZXN1bHQgPSB0cnlSZXN0b3JlSXRlbUZyb21CYWNrdXAoa2V5KTtcbiAgICBpZiAoYmFja3VwUmVzdWx0LnN1Y2Nlc3MgJiYgYmFja3VwUmVzdWx0LmRhdGEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEJhY2t1cCA9IEpTT04ucGFyc2UoYmFja3VwUmVzdWx0LmRhdGEpIGFzIEJhc2VTdG9yYWdlU2NoZW1hPFQ+O1xuICAgICAgICByZXR1cm4gcGFyc2VkQmFja3VwO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZiBiYWNrdXAgcGFyc2luZyBmYWlscywgcmV0dXJuIGRlZmF1bHRcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdCB8fCBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogVHJ5IHRvIHJlc3RvcmUgYSBzaW5nbGUgaXRlbSBmcm9tIGl0cyBiYWNrdXBcbiAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byByZXN0b3JlXG4gKiBAcmV0dXJucyBTdWNjZXNzIHN0YXR1cyBhbmQgZGF0YSBpZiBzdWNjZXNzZnVsXG4gKi9cbmZ1bmN0aW9uIHRyeVJlc3RvcmVJdGVtRnJvbUJhY2t1cChrZXk6IHN0cmluZyk6IHsgc3VjY2VzczogYm9vbGVhbjsgZGF0YTogc3RyaW5nIHwgbnVsbCB9IHtcbiAgdHJ5IHtcbiAgICAvLyBGaW5kIGJhY2t1cHMgZm9yIHRoaXMgc3BlY2lmaWMga2V5XG4gICAgY29uc3QgYmFja3VwS2V5ID0gYCR7U3RvcmFnZUtleS5CQUNLVVBfUFJFRklYfSR7a2V5fWA7XG4gICAgY29uc3QgYmFja3VwRGF0YSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGJhY2t1cEtleSk7XG4gICAgXG4gICAgaWYgKGJhY2t1cERhdGEpIHtcbiAgICAgIC8vIFJlc3RvcmUgZnJvbSBiYWNrdXBcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgYmFja3VwRGF0YSk7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBiYWNrdXBEYXRhIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBkYXRhOiBudWxsIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZGF0YTogbnVsbCB9O1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYmFja3VwIG9mIGFsbCBhcHBsaWNhdGlvbiBkYXRhXG4gKiBAcmV0dXJucyB0cnVlIGlmIGJhY2t1cCBzdWNjZXNzZnVsLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJhY2t1cCgpOiBib29sZWFuIHtcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB0cnlDYXRjaFN0b3JhZ2UoKCkgPT4ge1xuICAgIGlmICghaXNTdG9yYWdlQXZhaWxhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoXG4gICAgICAgICdMb2NhbCBzdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUsIGNhbm5vdCBjcmVhdGUgYmFja3VwJyxcbiAgICAgICAgU3RvcmFnZUVycm9yVHlwZS5TVE9SQUdFX1VOQVZBSUxBQkxFXG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGJhY2t1cEtleSA9IGAke1N0b3JhZ2VLZXkuQkFDS1VQX1BSRUZJWH0ke3RpbWVzdGFtcH1gO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIGJhY2t1cCBvYmplY3Qgd2l0aCBhbGwgYXBwIGRhdGFcbiAgICBjb25zdCBiYWNrdXAgPSB7XG4gICAgICB0aW1lc3RhbXAsXG4gICAgICB2ZXJzaW9uOiBTQ0hFTUFfVkVSU0lPTixcbiAgICAgIGRvZ1Byb2ZpbGVzOiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTdG9yYWdlS2V5LkRPR19QUk9GSUxFUyksXG4gICAgICBzYXZlZFJlY29tbWVuZGF0aW9uczogbG9jYWxTdG9yYWdlLmdldEl0ZW0oU3RvcmFnZUtleS5TQVZFRF9SRUNPTU1FTkRBVElPTlMpLFxuICAgICAgdXNlclByZWZlcmVuY2VzOiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTdG9yYWdlS2V5LlVTRVJfUFJFRkVSRU5DRVMpXG4gICAgfTtcbiAgICBcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShiYWNrdXBLZXksIEpTT04uc3RyaW5naWZ5KGJhY2t1cCkpO1xuICAgIFxuICAgIC8vIEFsc28gY3JlYXRlIGluZGl2aWR1YWwgYmFja3VwcyBvZiBlYWNoIGtleVxuICAgIGlmIChiYWNrdXAuZG9nUHJvZmlsZXMpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGAke1N0b3JhZ2VLZXkuQkFDS1VQX1BSRUZJWH0ke1N0b3JhZ2VLZXkuRE9HX1BST0ZJTEVTfWAsIGJhY2t1cC5kb2dQcm9maWxlcyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChiYWNrdXAuc2F2ZWRSZWNvbW1lbmRhdGlvbnMpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGAke1N0b3JhZ2VLZXkuQkFDS1VQX1BSRUZJWH0ke1N0b3JhZ2VLZXkuU0FWRURfUkVDT01NRU5EQVRJT05TfWAsIGJhY2t1cC5zYXZlZFJlY29tbWVuZGF0aW9ucyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChiYWNrdXAudXNlclByZWZlcmVuY2VzKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShgJHtTdG9yYWdlS2V5LkJBQ0tVUF9QUkVGSVh9JHtTdG9yYWdlS2V5LlVTRVJfUFJFRkVSRU5DRVN9YCwgYmFja3VwLnVzZXJQcmVmZXJlbmNlcyk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9LCAnY3JlYXRlQmFja3VwJywgU3RvcmFnZUVycm9yVHlwZS5CQUNLVVBfRVJST1IpO1xuICBcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXN0b3JlIGRhdGEgZnJvbSB0aGUgbW9zdCByZWNlbnQgYmFja3VwXG4gKiBAcmV0dXJucyB0cnVlIGlmIHJlc3RvcmUgc3VjY2Vzc2Z1bCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXN0b3JlRnJvbUJhY2t1cCgpOiBib29sZWFuIHtcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB0cnlDYXRjaFN0b3JhZ2UoKCkgPT4ge1xuICAgIGlmICghaXNTdG9yYWdlQXZhaWxhYmxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoXG4gICAgICAgICdMb2NhbCBzdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUsIGNhbm5vdCByZXN0b3JlIGJhY2t1cCcsXG4gICAgICAgIFN0b3JhZ2VFcnJvclR5cGUuU1RPUkFHRV9VTkFWQUlMQUJMRVxuICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmluZCB0aGUgbGF0ZXN0IGJhY2t1cFxuICAgIGxldCBsYXRlc3RCYWNrdXBLZXk6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgIGxldCBsYXRlc3RUaW1lc3RhbXAgPSAwO1xuICAgIFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpO1xuICAgICAgaWYgKGtleSAmJiBrZXkuc3RhcnRzV2l0aChTdG9yYWdlS2V5LkJBQ0tVUF9QUkVGSVgpICYmICFrZXkuaW5jbHVkZXMoU3RvcmFnZUtleS5ET0dfUFJPRklMRVMpICYmIFxuICAgICAgICAgICFrZXkuaW5jbHVkZXMoU3RvcmFnZUtleS5TQVZFRF9SRUNPTU1FTkRBVElPTlMpICYmICFrZXkuaW5jbHVkZXMoU3RvcmFnZUtleS5VU0VSX1BSRUZFUkVOQ0VTKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IHBhcnNlSW50KGtleS5yZXBsYWNlKFN0b3JhZ2VLZXkuQkFDS1VQX1BSRUZJWCwgJycpLCAxMCk7XG4gICAgICAgICAgaWYgKCFpc05hTih0aW1lc3RhbXApICYmIHRpbWVzdGFtcCA+IGxhdGVzdFRpbWVzdGFtcCkge1xuICAgICAgICAgICAgbGF0ZXN0VGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgbGF0ZXN0QmFja3VwS2V5ID0ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIFNraXAga2V5cyB0aGF0IGRvbid0IGhhdmUgdmFsaWQgdGltZXN0YW1wc1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmICghbGF0ZXN0QmFja3VwS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgU3RvcmFnZUVycm9yKFxuICAgICAgICAnTm8gYmFja3VwIGZvdW5kJyxcbiAgICAgICAgU3RvcmFnZUVycm9yVHlwZS5SRVNUT1JFX0VSUk9SXG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICAvLyBSZXN0b3JlIGZyb20gYmFja3VwXG4gICAgY29uc3Qgc2VyaWFsaXplZEJhY2t1cCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGxhdGVzdEJhY2t1cEtleSk7XG4gICAgaWYgKCFzZXJpYWxpemVkQmFja3VwKSB7XG4gICAgICB0aHJvdyBuZXcgU3RvcmFnZUVycm9yKFxuICAgICAgICAnQmFja3VwIGlzIGVtcHR5IG9yIGNvcnJ1cHRlZCcsXG4gICAgICAgIFN0b3JhZ2VFcnJvclR5cGUuUkVTVE9SRV9FUlJPUlxuICAgICAgKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgYmFja3VwID0gSlNPTi5wYXJzZShzZXJpYWxpemVkQmFja3VwKTtcbiAgICBcbiAgICBpZiAoYmFja3VwLmRvZ1Byb2ZpbGVzKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTdG9yYWdlS2V5LkRPR19QUk9GSUxFUywgYmFja3VwLmRvZ1Byb2ZpbGVzKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGJhY2t1cC5zYXZlZFJlY29tbWVuZGF0aW9ucykge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU3RvcmFnZUtleS5TQVZFRF9SRUNPTU1FTkRBVElPTlMsIGJhY2t1cC5zYXZlZFJlY29tbWVuZGF0aW9ucyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChiYWNrdXAudXNlclByZWZlcmVuY2VzKSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTdG9yYWdlS2V5LlVTRVJfUFJFRkVSRU5DRVMsIGJhY2t1cC51c2VyUHJlZmVyZW5jZXMpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgJ3Jlc3RvcmVGcm9tQmFja3VwJywgU3RvcmFnZUVycm9yVHlwZS5SRVNUT1JFX0VSUk9SKTtcbiAgXG4gIHJldHVybiByZXN1bHQgPT09IHRydWU7XG59XG5cbi8qKlxuICogUmVtb3ZlIG9sZCBiYWNrdXBzLCBrZWVwaW5nIG9ubHkgdGhlIG1vc3QgcmVjZW50IG9uZXNcbiAqIEBwYXJhbSBrZWVwQ291bnQgTnVtYmVyIG9mIHJlY2VudCBiYWNrdXBzIHRvIGtlZXAgKGRlZmF1bHQ6IDMpXG4gKiBAcmV0dXJucyBudW1iZXIgb2YgYmFja3VwcyByZW1vdmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbnVwT2xkQmFja3VwcyhrZWVwQ291bnQ6IG51bWJlciA9IDMpOiBudW1iZXIge1xuICBjb25zdCB7IHJlc3VsdCwgZXJyb3IgfSA9IHRyeUNhdGNoU3RvcmFnZSgoKSA9PiB7XG4gICAgaWYgKCFpc1N0b3JhZ2VBdmFpbGFibGUoKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIFxuICAgIC8vIEZpbmQgYWxsIGJhY2t1cHMgYW5kIHRoZWlyIHRpbWVzdGFtcHNcbiAgICBjb25zdCBiYWNrdXBzOiB7IGtleTogc3RyaW5nOyB0aW1lc3RhbXA6IG51bWJlciB9W10gPSBbXTtcbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgIGlmIChrZXkgJiYga2V5LnN0YXJ0c1dpdGgoU3RvcmFnZUtleS5CQUNLVVBfUFJFRklYKSAmJiAha2V5LmluY2x1ZGVzKFN0b3JhZ2VLZXkuRE9HX1BST0ZJTEVTKSAmJiBcbiAgICAgICAgICAha2V5LmluY2x1ZGVzKFN0b3JhZ2VLZXkuU0FWRURfUkVDT01NRU5EQVRJT05TKSAmJiAha2V5LmluY2x1ZGVzKFN0b3JhZ2VLZXkuVVNFUl9QUkVGRVJFTkNFUykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBwYXJzZUludChrZXkucmVwbGFjZShTdG9yYWdlS2V5LkJBQ0tVUF9QUkVGSVgsICcnKSwgMTApO1xuICAgICAgICAgIGlmICghaXNOYU4odGltZXN0YW1wKSkge1xuICAgICAgICAgICAgYmFja3Vwcy5wdXNoKHsga2V5LCB0aW1lc3RhbXAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gU2tpcCBrZXlzIHRoYXQgZG9uJ3QgaGF2ZSB2YWxpZCB0aW1lc3RhbXBzXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gU29ydCBieSB0aW1lc3RhbXAgKG5ld2VzdCBmaXJzdClcbiAgICBiYWNrdXBzLnNvcnQoKGEsIGIpID0+IGIudGltZXN0YW1wIC0gYS50aW1lc3RhbXApO1xuICAgIFxuICAgIC8vIFJlbW92ZSBvbGQgYmFja3VwcyBrZWVwaW5nIHRoZSBtb3N0IHJlY2VudCBvbmVzXG4gICAgbGV0IHJlbW92ZWRDb3VudCA9IDA7XG4gICAgaWYgKGJhY2t1cHMubGVuZ3RoID4ga2VlcENvdW50KSB7XG4gICAgICBjb25zdCB0b1JlbW92ZSA9IGJhY2t1cHMuc2xpY2Uoa2VlcENvdW50KTtcbiAgICAgIHRvUmVtb3ZlLmZvckVhY2goYmFja3VwID0+IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oYmFja3VwLmtleSk7XG4gICAgICAgIHJlbW92ZWRDb3VudCsrO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZW1vdmVkQ291bnQ7XG4gIH0sICdjbGVhbnVwT2xkQmFja3VwcycpO1xuICBcbiAgcmV0dXJuIHJlc3VsdCB8fCAwO1xufVxuXG4vKipcbiAqIFNhdmUgZG9nIHByb2ZpbGVzIHRvIHN0b3JhZ2VcbiAqIEBwYXJhbSBwcm9maWxlcyBNYXAgb2YgZG9nIHByb2ZpbGVzIGJ5IElEXG4gKiBAcGFyYW0gYWN0aXZlUHJvZmlsZUlkIElEIG9mIHRoZSBhY3RpdmUgcHJvZmlsZSAob3B0aW9uYWwpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYXZlRG9nUHJvZmlsZXMoXG4gIHByb2ZpbGVzOiBSZWNvcmQ8c3RyaW5nLCBEb2dQcm9maWxlPiwgXG4gIGFjdGl2ZVByb2ZpbGVJZD86IHN0cmluZ1xuKTogdm9pZCB7XG4gIGNvbnN0IGRhdGE6IERvZ1Byb2ZpbGVzU3RvcmFnZVNjaGVtYVsnZGF0YSddID0ge1xuICAgIHByb2ZpbGVzLFxuICAgIGFjdGl2ZVByb2ZpbGVJZFxuICB9O1xuICBcbiAgc2F2ZVRvU3RvcmFnZTxEb2dQcm9maWxlc1N0b3JhZ2VTY2hlbWFbJ2RhdGEnXT4oU3RvcmFnZUtleS5ET0dfUFJPRklMRVMsIGRhdGEpO1xufVxuXG4vKipcbiAqIExvYWQgZG9nIHByb2ZpbGVzIGZyb20gc3RvcmFnZVxuICogQHJldHVybnMgVGhlIHN0b3JlZCBkb2cgcHJvZmlsZXMgb3IgZGVmYXVsdCBlbXB0eSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkRG9nUHJvZmlsZXMoKTogRG9nUHJvZmlsZXNTdG9yYWdlU2NoZW1hIHtcbiAgcmV0dXJuIGxvYWRGcm9tU3RvcmFnZTxEb2dQcm9maWxlc1N0b3JhZ2VTY2hlbWFbJ2RhdGEnXT4oXG4gICAgU3RvcmFnZUtleS5ET0dfUFJPRklMRVMsIFxuICAgIERFRkFVTFRfRE9HX1BST0ZJTEVTX1NUT1JBR0VcbiAgKTtcbn1cblxuLyoqXG4gKiBTYXZlIHNhdmVkIHJlY29tbWVuZGF0aW9ucyB0byBzdG9yYWdlXG4gKiBAcGFyYW0gcmVjb21tZW5kYXRpb25zIE1hcCBvZiBzYXZlZCByZWNvbW1lbmRhdGlvbnMgYnkgcHJvZHVjdCBJRFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2F2ZVJlY29tbWVuZGF0aW9ucyhyZWNvbW1lbmRhdGlvbnM6IFJlY29yZDxzdHJpbmcsIEZvb2RSZWNvbW1lbmRhdGlvbj4pOiB2b2lkIHtcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB0cnlDYXRjaFN0b3JhZ2UoKCkgPT4ge1xuICAgIGNvbnN0IHNhdmVkRGF0ZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICBcbiAgICAvLyBVcGRhdGUgdGltZXN0YW1wcyBmb3IgYW55IG5ldyByZWNvbW1lbmRhdGlvbnNcbiAgICBPYmplY3Qua2V5cyhyZWNvbW1lbmRhdGlvbnMpLmZvckVhY2goaWQgPT4ge1xuICAgICAgLy8gVXNlIGV4aXN0aW5nIHRpbWVzdGFtcCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSB1c2UgY3VycmVudCB0aW1lXG4gICAgICBzYXZlZERhdGVzW2lkXSA9IERhdGUubm93KCk7XG4gICAgfSk7XG4gICAgXG4gICAgY29uc3QgZGF0YTogU2F2ZWRSZWNvbW1lbmRhdGlvbnNTdG9yYWdlU2NoZW1hWydkYXRhJ10gPSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMsXG4gICAgICBzYXZlZERhdGVzXG4gICAgfTtcbiAgICBcbiAgICBzYXZlVG9TdG9yYWdlPFNhdmVkUmVjb21tZW5kYXRpb25zU3RvcmFnZVNjaGVtYVsnZGF0YSddPihTdG9yYWdlS2V5LlNBVkVEX1JFQ09NTUVOREFUSU9OUywgZGF0YSk7XG4gIH0sICdzYXZlUmVjb21tZW5kYXRpb25zJyk7XG4gIFxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIExvYWQgc2F2ZWQgcmVjb21tZW5kYXRpb25zIGZyb20gc3RvcmFnZVxuICogQHJldHVybnMgVGhlIHN0b3JlZCByZWNvbW1lbmRhdGlvbnMgb3IgZGVmYXVsdCBlbXB0eSBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkUmVjb21tZW5kYXRpb25zKCk6IFNhdmVkUmVjb21tZW5kYXRpb25zU3RvcmFnZVNjaGVtYSB7XG4gIHJldHVybiBsb2FkRnJvbVN0b3JhZ2U8U2F2ZWRSZWNvbW1lbmRhdGlvbnNTdG9yYWdlU2NoZW1hWydkYXRhJ10+KFxuICAgIFN0b3JhZ2VLZXkuU0FWRURfUkVDT01NRU5EQVRJT05TLCBcbiAgICBERUZBVUxUX1NBVkVEX1JFQ09NTUVOREFUSU9OU19TVE9SQUdFXG4gICk7XG59XG5cbi8qKlxuICogRXhwb3J0IGFsbCB1c2VyIGRhdGEgdG8gYSBkb3dubG9hZGFibGUgSlNPTiBmaWxlXG4gKiBAcmV0dXJucyBKU09OIHN0cmluZyBvZiBhbGwgdXNlciBkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBvcnREYXRhKCk6IHN0cmluZyB7XG4gIGNvbnN0IHsgcmVzdWx0LCBlcnJvciB9ID0gdHJ5Q2F0Y2hTdG9yYWdlKCgpID0+IHtcbiAgICBjb25zdCBkb2dQcm9maWxlcyA9IGxvYWREb2dQcm9maWxlcygpO1xuICAgIGNvbnN0IHNhdmVkUmVjb21tZW5kYXRpb25zID0gbG9hZFJlY29tbWVuZGF0aW9ucygpO1xuICAgIGNvbnN0IHVzZXJQcmVmZXJlbmNlcyA9IGxvYWRGcm9tU3RvcmFnZTxVc2VyUHJlZmVyZW5jZXNTdG9yYWdlU2NoZW1hWydkYXRhJ10+KFxuICAgICAgU3RvcmFnZUtleS5VU0VSX1BSRUZFUkVOQ0VTLFxuICAgICAgREVGQVVMVF9VU0VSX1BSRUZFUkVOQ0VTX1NUT1JBR0VcbiAgICApO1xuICAgIFxuICAgIGNvbnN0IGV4cG9ydERhdGEgPSB7XG4gICAgICBzY2hlbWFWZXJzaW9uOiBTQ0hFTUFfVkVSU0lPTixcbiAgICAgIGV4cG9ydERhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGRvZ1Byb2ZpbGVzLFxuICAgICAgc2F2ZWRSZWNvbW1lbmRhdGlvbnMsXG4gICAgICB1c2VyUHJlZmVyZW5jZXNcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShleHBvcnREYXRhLCBudWxsLCAyKTtcbiAgfSwgJ2V4cG9ydERhdGEnLCBTdG9yYWdlRXJyb3JUeXBlLkVYUE9SVF9FUlJPUik7XG4gIFxuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBcbiAgcmV0dXJuIHJlc3VsdCB8fCAne30nO1xufVxuXG4vKipcbiAqIEltcG9ydCB1c2VyIGRhdGEgZnJvbSBhIEpTT04gc3RyaW5nXG4gKiBAcGFyYW0ganNvbkRhdGEgSlNPTiBzdHJpbmcgd2l0aCB1c2VyIGRhdGFcbiAqIEByZXR1cm5zIHRydWUgaWYgaW1wb3J0IHN1Y2Nlc3NmdWwsIGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW1wb3J0RGF0YShqc29uRGF0YTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBpbXBvcnREYXRhV2l0aFN0cmF0ZWd5KGpzb25EYXRhLCAncmVwbGFjZScpO1xufVxuXG4vKipcbiAqIENsZWFudXAgb2xkIG9yIHVudXNlZCBkYXRhIGZyb20gc3RvcmFnZSBiYXNlZCBvbiBhZ2UgdGhyZXNob2xkXG4gKiBAcGFyYW0gb2xkZXJUaGFuRGF5cyBOdW1iZXIgb2YgZGF5cyBhZnRlciB3aGljaCBkYXRhIGlzIGNvbnNpZGVyZWQgb2xkIChkZWZhdWx0OiA5MClcbiAqIEByZXR1cm5zIE9iamVjdCB3aXRoIGNvdW50cyBvZiBpdGVtcyBjbGVhbmVkIHVwIGJ5IGNhdGVnb3J5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbnVwU3RvcmFnZShvbGRlclRoYW5EYXlzOiBudW1iZXIgPSA5MCk6IHsgXG4gIHJlY29tbWVuZGF0aW9uczogbnVtYmVyOyBcbiAgb2xkQmFja3VwczogbnVtYmVyO1xuICB0b3RhbDogbnVtYmVyO1xufSB7XG4gIGNvbnN0IHsgcmVzdWx0LCBlcnJvciB9ID0gdHJ5Q2F0Y2hTdG9yYWdlKCgpID0+IHtcbiAgICBpZiAoIWlzU3RvcmFnZUF2YWlsYWJsZSgpKSB7XG4gICAgICByZXR1cm4geyByZWNvbW1lbmRhdGlvbnM6IDAsIG9sZEJhY2t1cHM6IDAsIHRvdGFsOiAwIH07XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgY29uc3QgYWdlVGhyZXNob2xkID0gbm93IC0gKG9sZGVyVGhhbkRheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKTsgLy8gQ29udmVydCBkYXlzIHRvIG1pbGxpc2Vjb25kc1xuICAgIGxldCByZW1vdmVkUmVjb21tZW5kYXRpb25zID0gMDtcbiAgICBcbiAgICAvLyBDbGVhbiB1cCBvbGQgc2F2ZWQgcmVjb21tZW5kYXRpb25zXG4gICAgY29uc3Qgc2F2ZWRSZWNvbW1lbmRhdGlvbnMgPSBsb2FkUmVjb21tZW5kYXRpb25zKCk7XG4gICAgaWYgKHNhdmVkUmVjb21tZW5kYXRpb25zPy5kYXRhPy5yZWNvbW1lbmRhdGlvbnMgJiYgc2F2ZWRSZWNvbW1lbmRhdGlvbnM/LmRhdGE/LnNhdmVkRGF0ZXMpIHtcbiAgICAgIGNvbnN0IHsgcmVjb21tZW5kYXRpb25zLCBzYXZlZERhdGVzIH0gPSBzYXZlZFJlY29tbWVuZGF0aW9ucy5kYXRhO1xuICAgICAgY29uc3QgdXBkYXRlZFJlY29tbWVuZGF0aW9uczogUmVjb3JkPHN0cmluZywgRm9vZFJlY29tbWVuZGF0aW9uPiA9IHt9O1xuICAgICAgY29uc3QgdXBkYXRlZFNhdmVkRGF0ZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICAgIFxuICAgICAgT2JqZWN0LmVudHJpZXMocmVjb21tZW5kYXRpb25zKS5mb3JFYWNoKChbaWQsIHJlY29tbWVuZGF0aW9uXSkgPT4ge1xuICAgICAgICBjb25zdCBzYXZlZERhdGUgPSBzYXZlZERhdGVzW2lkXSB8fCAwO1xuICAgICAgICBcbiAgICAgICAgLy8gS2VlcCByZWNvbW1lbmRhdGlvbnMgbmV3ZXIgdGhhbiB0aGUgdGhyZXNob2xkXG4gICAgICAgIGlmIChzYXZlZERhdGUgPiBhZ2VUaHJlc2hvbGQpIHtcbiAgICAgICAgICB1cGRhdGVkUmVjb21tZW5kYXRpb25zW2lkXSA9IHJlY29tbWVuZGF0aW9uO1xuICAgICAgICAgIHVwZGF0ZWRTYXZlZERhdGVzW2lkXSA9IHNhdmVkRGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkUmVjb21tZW5kYXRpb25zKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBPbmx5IHNhdmUgaWYgd2UgcmVtb3ZlZCBhbnkgcmVjb21tZW5kYXRpb25zXG4gICAgICBpZiAocmVtb3ZlZFJlY29tbWVuZGF0aW9ucyA+IDApIHtcbiAgICAgICAgc2F2ZVRvU3RvcmFnZShTdG9yYWdlS2V5LlNBVkVEX1JFQ09NTUVOREFUSU9OUywge1xuICAgICAgICAgIHJlY29tbWVuZGF0aW9uczogdXBkYXRlZFJlY29tbWVuZGF0aW9ucyxcbiAgICAgICAgICBzYXZlZERhdGVzOiB1cGRhdGVkU2F2ZWREYXRlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW4gdXAgb2xkIGJhY2t1cHNcbiAgICBjb25zdCBvbGRCYWNrdXBzID0gY2xlYW51cE9sZEJhY2t1cHMoMyk7IC8vIEtlZXAgMyBtb3N0IHJlY2VudCBiYWNrdXBzXG4gICAgXG4gICAgY29uc3QgdG90YWxSZW1vdmVkID0gcmVtb3ZlZFJlY29tbWVuZGF0aW9ucyArIG9sZEJhY2t1cHM7XG4gICAgXG4gICAgcmV0dXJuIHsgXG4gICAgICByZWNvbW1lbmRhdGlvbnM6IHJlbW92ZWRSZWNvbW1lbmRhdGlvbnMsIFxuICAgICAgb2xkQmFja3VwcywgXG4gICAgICB0b3RhbDogdG90YWxSZW1vdmVkIFxuICAgIH07XG4gIH0sICdjbGVhbnVwU3RvcmFnZScsIENMRUFOVVBfRVJST1IpO1xuICBcbiAgcmV0dXJuIHJlc3VsdCB8fCB7IHJlY29tbWVuZGF0aW9uczogMCwgb2xkQmFja3VwczogMCwgdG90YWw6IDAgfTtcbn1cblxuLyoqXG4gKiBEb3dubG9hZCBleHBvcnRlZCBkYXRhIGFzIGEgSlNPTiBmaWxlXG4gKiBAcGFyYW0gZmlsZW5hbWUgQ3VzdG9tIGZpbGVuYW1lIChkZWZhdWx0OiAncGV0Zm9vZC1kYXRhLWV4cG9ydC5qc29uJylcbiAqIEByZXR1cm5zIHRydWUgaWYgZG93bmxvYWQgaW5pdGlhdGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3dubG9hZEV4cG9ydGVkRGF0YShmaWxlbmFtZTogc3RyaW5nID0gJ3BldGZvb2QtZGF0YS1leHBvcnQuanNvbicpOiBib29sZWFuIHtcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB0cnlDYXRjaFN0b3JhZ2UoKCkgPT4ge1xuICAgIGNvbnN0IGV4cG9ydFN0cmluZyA9IGV4cG9ydERhdGEoKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBCbG9iIHdpdGggdGhlIGRhdGFcbiAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2V4cG9ydFN0cmluZ10sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nIH0pO1xuICAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGxpbmsgYW5kIHRyaWdnZXIgZG93bmxvYWRcbiAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIGxpbmsuaHJlZiA9IHVybDtcbiAgICBsaW5rLmRvd25sb2FkID0gZmlsZW5hbWU7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICBsaW5rLmNsaWNrKCk7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXBcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgfSwgMTAwKTtcbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgJ2Rvd25sb2FkRXhwb3J0ZWREYXRhJywgU3RvcmFnZUVycm9yVHlwZS5FWFBPUlRfRVJST1IpO1xuICBcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBJbXBvcnQgZGF0YSBmcm9tIGFuIHVwbG9hZGVkIGZpbGVcbiAqIEBwYXJhbSBmaWxlIFRoZSB1cGxvYWRlZCBGaWxlIG9iamVjdFxuICogQHBhcmFtIG1lcmdlU3RyYXRlZ3kgSG93IHRvIGhhbmRsZSBleGlzdGluZyBkYXRhICgncmVwbGFjZScsICdtZXJnZScsICdrZWVwLW5ld2VyJylcbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRydWUgaWYgaW1wb3J0IHN1Y2Nlc3NmdWwsIGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW1wb3J0RGF0YUZyb21GaWxlKFxuICBmaWxlOiBGaWxlLCBcbiAgbWVyZ2VTdHJhdGVneTogJ3JlcGxhY2UnIHwgJ21lcmdlJyB8ICdrZWVwLW5ld2VyJyA9ICdyZXBsYWNlJ1xuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgXG4gICAgcmVhZGVyLm9ubG9hZCA9IChldmVudCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QganNvbkRhdGEgPSBldmVudC50YXJnZXQ/LnJlc3VsdCBhcyBzdHJpbmc7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBpbXBvcnREYXRhV2l0aFN0cmF0ZWd5KGpzb25EYXRhLCBtZXJnZVN0cmF0ZWd5KTtcbiAgICAgICAgcmVzb2x2ZShzdWNjZXNzKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGltcG9ydGluZyBkYXRhIGZyb20gZmlsZTonLCBlcnJvcik7XG4gICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgcmVhZGVyLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWFkaW5nIGZpbGUnKTtcbiAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgIH07XG4gICAgXG4gICAgcmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEltcG9ydCBkYXRhIHdpdGggdGhlIHNwZWNpZmllZCBtZXJnZSBzdHJhdGVneVxuICogQHBhcmFtIGpzb25EYXRhIEpTT04gc3RyaW5nIHdpdGggdXNlciBkYXRhXG4gKiBAcGFyYW0gbWVyZ2VTdHJhdGVneSBIb3cgdG8gaGFuZGxlIGV4aXN0aW5nIGRhdGEgKCdyZXBsYWNlJywgJ21lcmdlJywgJ2tlZXAtbmV3ZXInKVxuICogQHJldHVybnMgdHJ1ZSBpZiBpbXBvcnQgc3VjY2Vzc2Z1bCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbXBvcnREYXRhV2l0aFN0cmF0ZWd5KFxuICBqc29uRGF0YTogc3RyaW5nLCBcbiAgbWVyZ2VTdHJhdGVneTogJ3JlcGxhY2UnIHwgJ21lcmdlJyB8ICdrZWVwLW5ld2VyJyA9ICdyZXBsYWNlJ1xuKTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgcmVzdWx0LCBlcnJvciB9ID0gdHJ5Q2F0Y2hTdG9yYWdlKCgpID0+IHtcbiAgICBjb25zdCBpbXBvcnRlZERhdGEgPSBKU09OLnBhcnNlKGpzb25EYXRhKTtcbiAgICBcbiAgICAvLyBWYWxpZGF0ZSBpbXBvcnRlZCBkYXRhXG4gICAgaWYgKCFpbXBvcnRlZERhdGEuc2NoZW1hVmVyc2lvbiB8fCAhaW1wb3J0ZWREYXRhLmV4cG9ydERhdGUpIHtcbiAgICAgIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIGV4cG9ydCBkYXRhIGZvcm1hdCcsXG4gICAgICAgIFN0b3JhZ2VFcnJvclR5cGUuSU1QT1JUX0VSUk9SXG4gICAgICApO1xuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhdGUgYmFja3VwIGJlZm9yZSBtYWtpbmcgYW55IGNoYW5nZXNcbiAgICBjcmVhdGVCYWNrdXAoKTtcbiAgICBcbiAgICAvLyBIYW5kbGUgZG9nIHByb2ZpbGVzIGJhc2VkIG9uIG1lcmdlIHN0cmF0ZWd5XG4gICAgaWYgKGltcG9ydGVkRGF0YS5kb2dQcm9maWxlcz8uZGF0YT8ucHJvZmlsZXMpIHtcbiAgICAgIGlmIChtZXJnZVN0cmF0ZWd5ID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgLy8gU2ltcGx5IHJlcGxhY2UgZXhpc3RpbmcgZGF0YVxuICAgICAgICBzYXZlVG9TdG9yYWdlKFN0b3JhZ2VLZXkuRE9HX1BST0ZJTEVTLCBpbXBvcnRlZERhdGEuZG9nUHJvZmlsZXMuZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNZXJnZSBvciBrZWVwLW5ld2VyIHN0cmF0ZWdpZXNcbiAgICAgICAgY29uc3QgZXhpc3RpbmdQcm9maWxlcyA9IGxvYWREb2dQcm9maWxlcygpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGV4aXN0aW5nUHJvZmlsZXM/LmRhdGE/LnByb2ZpbGVzKSB7XG4gICAgICAgICAgY29uc3QgbWVyZ2VkUHJvZmlsZXMgPSB7IC4uLmV4aXN0aW5nUHJvZmlsZXMuZGF0YSB9O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFByb2Nlc3MgZWFjaCBpbXBvcnRlZCBwcm9maWxlXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoaW1wb3J0ZWREYXRhLmRvZ1Byb2ZpbGVzLmRhdGEucHJvZmlsZXMpLmZvckVhY2goKFtpZCwgcHJvZmlsZV0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nUHJvZmlsZSA9IG1lcmdlZFByb2ZpbGVzLnByb2ZpbGVzW2lkXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFleGlzdGluZ1Byb2ZpbGUpIHtcbiAgICAgICAgICAgICAgLy8gUHJvZmlsZSBkb2Vzbid0IGV4aXN0IGluIGN1cnJlbnQgZGF0YSwgYWRkIGl0XG4gICAgICAgICAgICAgIG1lcmdlZFByb2ZpbGVzLnByb2ZpbGVzW2lkXSA9IHByb2ZpbGUgYXMgRG9nUHJvZmlsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWVyZ2VTdHJhdGVneSA9PT0gJ2tlZXAtbmV3ZXInKSB7XG4gICAgICAgICAgICAgIC8vIENvbXBhcmUgdXBkYXRlIHRpbWVzdGFtcHMgYW5kIGtlZXAgbmV3ZXJcbiAgICAgICAgICAgICAgY29uc3QgaW1wb3J0ZWRUaW1lc3RhbXAgPSBpbXBvcnRlZERhdGEuZG9nUHJvZmlsZXMudXBkYXRlZEF0IHx8IDA7XG4gICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGltZXN0YW1wID0gZXhpc3RpbmdQcm9maWxlcy51cGRhdGVkQXQgfHwgMDtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChpbXBvcnRlZFRpbWVzdGFtcCA+IGV4aXN0aW5nVGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkUHJvZmlsZXMucHJvZmlsZXNbaWRdID0gcHJvZmlsZSBhcyBEb2dQcm9maWxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBGb3IgJ21lcmdlJyBzdHJhdGVneSwgYWx3YXlzIHVwZGF0ZVxuICAgICAgICAgICAgICBtZXJnZWRQcm9maWxlcy5wcm9maWxlc1tpZF0gPSBwcm9maWxlIGFzIERvZ1Byb2ZpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2F2ZSBtZXJnZWQgcHJvZmlsZXNcbiAgICAgICAgICBzYXZlVG9TdG9yYWdlKFN0b3JhZ2VLZXkuRE9HX1BST0ZJTEVTLCBtZXJnZWRQcm9maWxlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gZXhpc3RpbmcgcHJvZmlsZXMsIGp1c3QgaW1wb3J0XG4gICAgICAgICAgc2F2ZVRvU3RvcmFnZShTdG9yYWdlS2V5LkRPR19QUk9GSUxFUywgaW1wb3J0ZWREYXRhLmRvZ1Byb2ZpbGVzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSByZWNvbW1lbmRhdGlvbnMgd2l0aCBzaW1pbGFyIG1lcmdlIHN0cmF0ZWd5XG4gICAgaWYgKGltcG9ydGVkRGF0YS5zYXZlZFJlY29tbWVuZGF0aW9ucz8uZGF0YT8ucmVjb21tZW5kYXRpb25zKSB7XG4gICAgICBpZiAobWVyZ2VTdHJhdGVneSA9PT0gJ3JlcGxhY2UnKSB7XG4gICAgICAgIHNhdmVUb1N0b3JhZ2UoU3RvcmFnZUtleS5TQVZFRF9SRUNPTU1FTkRBVElPTlMsIGltcG9ydGVkRGF0YS5zYXZlZFJlY29tbWVuZGF0aW9ucy5kYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUmVjb21tZW5kYXRpb25zID0gbG9hZFJlY29tbWVuZGF0aW9ucygpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGV4aXN0aW5nUmVjb21tZW5kYXRpb25zPy5kYXRhPy5yZWNvbW1lbmRhdGlvbnMpIHtcbiAgICAgICAgICBjb25zdCBtZXJnZWRSZWNvbW1lbmRhdGlvbnMgPSB7IFxuICAgICAgICAgICAgcmVjb21tZW5kYXRpb25zOiB7IC4uLmV4aXN0aW5nUmVjb21tZW5kYXRpb25zLmRhdGEucmVjb21tZW5kYXRpb25zIH0sXG4gICAgICAgICAgICBzYXZlZERhdGVzOiB7IC4uLmV4aXN0aW5nUmVjb21tZW5kYXRpb25zLmRhdGEuc2F2ZWREYXRlcyB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBQcm9jZXNzIGVhY2ggaW1wb3J0ZWQgcmVjb21tZW5kYXRpb25cbiAgICAgICAgICBPYmplY3QuZW50cmllcyhpbXBvcnRlZERhdGEuc2F2ZWRSZWNvbW1lbmRhdGlvbnMuZGF0YS5yZWNvbW1lbmRhdGlvbnMpLmZvckVhY2goKFtpZCwgcmVjb21tZW5kYXRpb25dKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1JlY29tbWVuZGF0aW9uID0gbWVyZ2VkUmVjb21tZW5kYXRpb25zLnJlY29tbWVuZGF0aW9uc1tpZF07XG4gICAgICAgICAgICBjb25zdCBpbXBvcnRlZFNhdmVkRGF0ZSA9IGltcG9ydGVkRGF0YS5zYXZlZFJlY29tbWVuZGF0aW9ucy5kYXRhLnNhdmVkRGF0ZXM/LltpZF0gfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU2F2ZWREYXRlID0gbWVyZ2VkUmVjb21tZW5kYXRpb25zLnNhdmVkRGF0ZXNbaWRdIHx8IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdSZWNvbW1lbmRhdGlvbikge1xuICAgICAgICAgICAgICAvLyBSZWNvbW1lbmRhdGlvbiBkb2Vzbid0IGV4aXN0LCBhZGQgaXRcbiAgICAgICAgICAgICAgbWVyZ2VkUmVjb21tZW5kYXRpb25zLnJlY29tbWVuZGF0aW9uc1tpZF0gPSByZWNvbW1lbmRhdGlvbiBhcyBGb29kUmVjb21tZW5kYXRpb247XG4gICAgICAgICAgICAgIG1lcmdlZFJlY29tbWVuZGF0aW9ucy5zYXZlZERhdGVzW2lkXSA9IGltcG9ydGVkU2F2ZWREYXRlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJnZVN0cmF0ZWd5ID09PSAna2VlcC1uZXdlcicgJiYgaW1wb3J0ZWRTYXZlZERhdGUgPiBleGlzdGluZ1NhdmVkRGF0ZSkge1xuICAgICAgICAgICAgICAvLyAna2VlcC1uZXdlcicgc3RyYXRlZ3kgLSB1cGRhdGUgaWYgaW1wb3J0ZWQgaXMgbmV3ZXJcbiAgICAgICAgICAgICAgbWVyZ2VkUmVjb21tZW5kYXRpb25zLnJlY29tbWVuZGF0aW9uc1tpZF0gPSByZWNvbW1lbmRhdGlvbiBhcyBGb29kUmVjb21tZW5kYXRpb247XG4gICAgICAgICAgICAgIG1lcmdlZFJlY29tbWVuZGF0aW9ucy5zYXZlZERhdGVzW2lkXSA9IGltcG9ydGVkU2F2ZWREYXRlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtZXJnZVN0cmF0ZWd5ID09PSAnbWVyZ2UnKSB7XG4gICAgICAgICAgICAgIC8vICdtZXJnZScgc3RyYXRlZ3kgLSBhbHdheXMgdXBkYXRlXG4gICAgICAgICAgICAgIG1lcmdlZFJlY29tbWVuZGF0aW9ucy5yZWNvbW1lbmRhdGlvbnNbaWRdID0gcmVjb21tZW5kYXRpb24gYXMgRm9vZFJlY29tbWVuZGF0aW9uO1xuICAgICAgICAgICAgICBtZXJnZWRSZWNvbW1lbmRhdGlvbnMuc2F2ZWREYXRlc1tpZF0gPSBpbXBvcnRlZFNhdmVkRGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTYXZlIG1lcmdlZCByZWNvbW1lbmRhdGlvbnNcbiAgICAgICAgICBzYXZlVG9TdG9yYWdlKFN0b3JhZ2VLZXkuU0FWRURfUkVDT01NRU5EQVRJT05TLCBtZXJnZWRSZWNvbW1lbmRhdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGV4aXN0aW5nIHJlY29tbWVuZGF0aW9ucywganVzdCBpbXBvcnRcbiAgICAgICAgICBzYXZlVG9TdG9yYWdlKFN0b3JhZ2VLZXkuU0FWRURfUkVDT01NRU5EQVRJT05TLCBpbXBvcnRlZERhdGEuc2F2ZWRSZWNvbW1lbmRhdGlvbnMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSGFuZGxlIHVzZXIgcHJlZmVyZW5jZXNcbiAgICBpZiAoaW1wb3J0ZWREYXRhLnVzZXJQcmVmZXJlbmNlcz8uZGF0YSkge1xuICAgICAgaWYgKG1lcmdlU3RyYXRlZ3kgPT09ICdyZXBsYWNlJykge1xuICAgICAgICBzYXZlVG9TdG9yYWdlKFN0b3JhZ2VLZXkuVVNFUl9QUkVGRVJFTkNFUywgaW1wb3J0ZWREYXRhLnVzZXJQcmVmZXJlbmNlcy5kYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUHJlZmVyZW5jZXMgPSBsb2FkRnJvbVN0b3JhZ2U8VXNlclByZWZlcmVuY2VzU3RvcmFnZVNjaGVtYVsnZGF0YSddPihcbiAgICAgICAgICBTdG9yYWdlS2V5LlVTRVJfUFJFRkVSRU5DRVMsXG4gICAgICAgICAgREVGQVVMVF9VU0VSX1BSRUZFUkVOQ0VTX1NUT1JBR0VcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChleGlzdGluZ1ByZWZlcmVuY2VzPy5kYXRhKSB7XG4gICAgICAgICAgaWYgKG1lcmdlU3RyYXRlZ3kgPT09ICdrZWVwLW5ld2VyJykge1xuICAgICAgICAgICAgY29uc3QgaW1wb3J0ZWRUaW1lc3RhbXAgPSBpbXBvcnRlZERhdGEudXNlclByZWZlcmVuY2VzLnVwZGF0ZWRBdCB8fCAwO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUaW1lc3RhbXAgPSBleGlzdGluZ1ByZWZlcmVuY2VzLnVwZGF0ZWRBdCB8fCAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaW1wb3J0ZWRUaW1lc3RhbXAgPiBleGlzdGluZ1RpbWVzdGFtcCkge1xuICAgICAgICAgICAgICBzYXZlVG9TdG9yYWdlKFN0b3JhZ2VLZXkuVVNFUl9QUkVGRVJFTkNFUywgaW1wb3J0ZWREYXRhLnVzZXJQcmVmZXJlbmNlcy5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yICdtZXJnZScgc3RyYXRlZ3ksIG1lcmdlIG9iamVjdHNcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZFByZWZlcmVuY2VzID0ge1xuICAgICAgICAgICAgICAuLi5leGlzdGluZ1ByZWZlcmVuY2VzLmRhdGEsXG4gICAgICAgICAgICAgIC4uLmltcG9ydGVkRGF0YS51c2VyUHJlZmVyZW5jZXMuZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNhdmVUb1N0b3JhZ2UoU3RvcmFnZUtleS5VU0VSX1BSRUZFUkVOQ0VTLCBtZXJnZWRQcmVmZXJlbmNlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGV4aXN0aW5nIHByZWZlcmVuY2VzLCBqdXN0IGltcG9ydFxuICAgICAgICAgIHNhdmVUb1N0b3JhZ2UoU3RvcmFnZUtleS5VU0VSX1BSRUZFUkVOQ0VTLCBpbXBvcnRlZERhdGEudXNlclByZWZlcmVuY2VzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9LCAnaW1wb3J0RGF0YVdpdGhTdHJhdGVneScsIFN0b3JhZ2VFcnJvclR5cGUuSU1QT1JUX0VSUk9SKTtcbiAgXG4gIHJldHVybiByZXN1bHQgPT09IHRydWU7XG59XG5cbi8qKlxuICogR2V0IHN0YXRpc3RpY3MgYWJvdXQgc3RvcmFnZSB1c2FnZSBhbmQgaXRlbSBjb3VudHNcbiAqIEByZXR1cm5zIE9iamVjdCB3aXRoIHN0b3JhZ2UgdXNhZ2Ugc3RhdGlzdGljc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcmFnZVN0YXRzKCk6IHtcbiAgdXNhZ2U6IHsgdXNlZDogbnVtYmVyOyBhdmFpbGFibGU/OiBudW1iZXI7IHBlcmNlbnRVc2VkPzogbnVtYmVyIH07XG4gIGNvdW50czogeyBkb2dQcm9maWxlczogbnVtYmVyOyBzYXZlZFJlY29tbWVuZGF0aW9uczogbnVtYmVyOyBiYWNrdXBzOiBudW1iZXIgfTtcbiAgbGFzdFVwZGF0ZWQ6IHsgZG9nUHJvZmlsZXM/OiBudW1iZXI7IHNhdmVkUmVjb21tZW5kYXRpb25zPzogbnVtYmVyOyBiYWNrdXBzPzogbnVtYmVyIH07XG59IHtcbiAgY29uc3QgeyByZXN1bHQsIGVycm9yIH0gPSB0cnlDYXRjaFN0b3JhZ2UoKCkgPT4ge1xuICAgIC8vIEdldCBzdG9yYWdlIHVzYWdlXG4gICAgY29uc3QgdXNhZ2UgPSBnZXRTdG9yYWdlVXNhZ2UoKTtcbiAgICBcbiAgICAvLyBDb3VudCBpdGVtc1xuICAgIGNvbnN0IGRvZ1Byb2ZpbGVzID0gbG9hZERvZ1Byb2ZpbGVzKCk7XG4gICAgY29uc3Qgc2F2ZWRSZWNvbW1lbmRhdGlvbnMgPSBsb2FkUmVjb21tZW5kYXRpb25zKCk7XG4gICAgXG4gICAgLy8gQ291bnQgYmFja3Vwc1xuICAgIGxldCBiYWNrdXBDb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG4gICAgICBpZiAoa2V5ICYmIGtleS5zdGFydHNXaXRoKFN0b3JhZ2VLZXkuQkFDS1VQX1BSRUZJWCkgJiYgIWtleS5pbmNsdWRlcyhTdG9yYWdlS2V5LkRPR19QUk9GSUxFUykgJiYgXG4gICAgICAgICAgIWtleS5pbmNsdWRlcyhTdG9yYWdlS2V5LlNBVkVEX1JFQ09NTUVOREFUSU9OUykgJiYgIWtleS5pbmNsdWRlcyhTdG9yYWdlS2V5LlVTRVJfUFJFRkVSRU5DRVMpKSB7XG4gICAgICAgIGJhY2t1cENvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEdldCBwcm9maWxlIGFuZCByZWNvbW1lbmRhdGlvbiBjb3VudHNcbiAgICBjb25zdCBwcm9maWxlQ291bnQgPSBkb2dQcm9maWxlcz8uZGF0YT8ucHJvZmlsZXMgPyBPYmplY3Qua2V5cyhkb2dQcm9maWxlcy5kYXRhLnByb2ZpbGVzKS5sZW5ndGggOiAwO1xuICAgIGNvbnN0IHJlY29tbWVuZGF0aW9uQ291bnQgPSBzYXZlZFJlY29tbWVuZGF0aW9ucz8uZGF0YT8ucmVjb21tZW5kYXRpb25zIFxuICAgICAgPyBPYmplY3Qua2V5cyhzYXZlZFJlY29tbWVuZGF0aW9ucy5kYXRhLnJlY29tbWVuZGF0aW9ucykubGVuZ3RoIFxuICAgICAgOiAwO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB1c2FnZSxcbiAgICAgIGNvdW50czoge1xuICAgICAgICBkb2dQcm9maWxlczogcHJvZmlsZUNvdW50LFxuICAgICAgICBzYXZlZFJlY29tbWVuZGF0aW9uczogcmVjb21tZW5kYXRpb25Db3VudCxcbiAgICAgICAgYmFja3VwczogYmFja3VwQ291bnRcbiAgICAgIH0sXG4gICAgICBsYXN0VXBkYXRlZDoge1xuICAgICAgICBkb2dQcm9maWxlczogZG9nUHJvZmlsZXM/LnVwZGF0ZWRBdCxcbiAgICAgICAgc2F2ZWRSZWNvbW1lbmRhdGlvbnM6IHNhdmVkUmVjb21tZW5kYXRpb25zPy51cGRhdGVkQXQsXG4gICAgICAgIGJhY2t1cHM6IGdldExhdGVzdEJhY2t1cFRpbWVzdGFtcCgpXG4gICAgICB9XG4gICAgfTtcbiAgfSwgJ2dldFN0b3JhZ2VTdGF0cycpO1xuICBcbiAgcmV0dXJuIHJlc3VsdCB8fCB7XG4gICAgdXNhZ2U6IHsgdXNlZDogMCB9LFxuICAgIGNvdW50czogeyBkb2dQcm9maWxlczogMCwgc2F2ZWRSZWNvbW1lbmRhdGlvbnM6IDAsIGJhY2t1cHM6IDAgfSxcbiAgICBsYXN0VXBkYXRlZDoge31cbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbW9zdCByZWNlbnQgYmFja3VwXG4gKiBAcmV0dXJucyBUaW1lc3RhbXAgb2YgdGhlIG1vc3QgcmVjZW50IGJhY2t1cCwgb3IgdW5kZWZpbmVkIGlmIG5vbmUgZXhpc3RzXG4gKi9cbmZ1bmN0aW9uIGdldExhdGVzdEJhY2t1cFRpbWVzdGFtcCgpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBjb25zdCB7IHJlc3VsdCB9ID0gdHJ5Q2F0Y2hTdG9yYWdlKCgpID0+IHtcbiAgICBsZXQgbGF0ZXN0VGltZXN0YW1wOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbFN0b3JhZ2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG4gICAgICBpZiAoa2V5ICYmIGtleS5zdGFydHNXaXRoKFN0b3JhZ2VLZXkuQkFDS1VQX1BSRUZJWCkgJiYgIWtleS5pbmNsdWRlcyhTdG9yYWdlS2V5LkRPR19QUk9GSUxFUykgJiYgXG4gICAgICAgICAgIWtleS5pbmNsdWRlcyhTdG9yYWdlS2V5LlNBVkVEX1JFQ09NTUVOREFUSU9OUykgJiYgIWtleS5pbmNsdWRlcyhTdG9yYWdlS2V5LlVTRVJfUFJFRkVSRU5DRVMpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gcGFyc2VJbnQoa2V5LnJlcGxhY2UoU3RvcmFnZUtleS5CQUNLVVBfUFJFRklYLCAnJyksIDEwKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKHRpbWVzdGFtcCkgJiYgKCFsYXRlc3RUaW1lc3RhbXAgfHwgdGltZXN0YW1wID4gbGF0ZXN0VGltZXN0YW1wKSkge1xuICAgICAgICAgICAgbGF0ZXN0VGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBsYXRlc3RUaW1lc3RhbXA7XG4gIH0sICdnZXRMYXRlc3RCYWNrdXBUaW1lc3RhbXAnKTtcbiAgXG4gIHJldHVybiByZXN1bHQgfHwgdW5kZWZpbmVkO1xufSAiXSwibmFtZXMiOlsiU0NIRU1BX1ZFUlNJT04iLCJTdG9yYWdlS2V5IiwiREVGQVVMVF9ET0dfUFJPRklMRVNfU1RPUkFHRSIsIkRFRkFVTFRfU0FWRURfUkVDT01NRU5EQVRJT05TX1NUT1JBR0UiLCJERUZBVUxUX1VTRVJfUFJFRkVSRU5DRVNfU1RPUkFHRSIsIlN0b3JhZ2VFcnJvciIsIlN0b3JhZ2VFcnJvclR5cGUiLCJoYW5kbGVTdG9yYWdlRXJyb3IiLCJ0cnlDYXRjaFN0b3JhZ2UiLCJDTEVBTlVQX0VSUk9SIiwiVU5LTk9XTl9FUlJPUiIsImlzU3RvcmFnZUF2YWlsYWJsZSIsInRlc3RLZXkiLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwicmVzdWx0IiwiZ2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJlIiwiZ2V0U3RvcmFnZVVzYWdlIiwiZXJyb3IiLCJ0b3RhbFNpemUiLCJpIiwibGVuZ3RoIiwia2V5IiwidmFsdWUiLCJ1c2VkQnl0ZXMiLCJlc3RpbWF0ZWRMaW1pdCIsInVzZWQiLCJhdmFpbGFibGUiLCJwZXJjZW50VXNlZCIsImlzU3RvcmFnZU5lYXJseUZ1bGwiLCJ0aHJlc2hvbGRQZXJjZW50IiwidXNhZ2UiLCJzYXZlVG9TdG9yYWdlIiwiZGF0YSIsIlNUT1JBR0VfVU5BVkFJTEFCTEUiLCJjb25zb2xlIiwid2FybiIsInN0b3JhZ2VEYXRhIiwidmVyc2lvbiIsInVwZGF0ZWRBdCIsIkRhdGUiLCJub3ciLCJKU09OIiwic3RyaW5naWZ5IiwiRXJyb3IiLCJuYW1lIiwiU1RPUkFHRV9RVU9UQV9FWENFRURFRCIsIm9yaWdpbmFsRXJyb3IiLCJXUklURV9FUlJPUiIsImxvYWRGcm9tU3RvcmFnZSIsImRlZmF1bHRWYWx1ZSIsInNlcmlhbGl6ZWQiLCJwYXJzZWREYXRhIiwicGFyc2UiLCJiYWNrdXBSZXN1bHQiLCJ0cnlSZXN0b3JlSXRlbUZyb21CYWNrdXAiLCJzdWNjZXNzIiwicGFyc2VkQmFja3VwIiwiYmFja3VwS2V5IiwiQkFDS1VQX1BSRUZJWCIsImJhY2t1cERhdGEiLCJjcmVhdGVCYWNrdXAiLCJ0aW1lc3RhbXAiLCJiYWNrdXAiLCJkb2dQcm9maWxlcyIsIkRPR19QUk9GSUxFUyIsInNhdmVkUmVjb21tZW5kYXRpb25zIiwiU0FWRURfUkVDT01NRU5EQVRJT05TIiwidXNlclByZWZlcmVuY2VzIiwiVVNFUl9QUkVGRVJFTkNFUyIsIkJBQ0tVUF9FUlJPUiIsInJlc3RvcmVGcm9tQmFja3VwIiwibGF0ZXN0QmFja3VwS2V5IiwibGF0ZXN0VGltZXN0YW1wIiwic3RhcnRzV2l0aCIsImluY2x1ZGVzIiwicGFyc2VJbnQiLCJyZXBsYWNlIiwiaXNOYU4iLCJSRVNUT1JFX0VSUk9SIiwic2VyaWFsaXplZEJhY2t1cCIsImNsZWFudXBPbGRCYWNrdXBzIiwia2VlcENvdW50IiwiYmFja3VwcyIsInB1c2giLCJzb3J0IiwiYSIsImIiLCJyZW1vdmVkQ291bnQiLCJ0b1JlbW92ZSIsInNsaWNlIiwiZm9yRWFjaCIsInNhdmVEb2dQcm9maWxlcyIsInByb2ZpbGVzIiwiYWN0aXZlUHJvZmlsZUlkIiwibG9hZERvZ1Byb2ZpbGVzIiwic2F2ZVJlY29tbWVuZGF0aW9ucyIsInJlY29tbWVuZGF0aW9ucyIsInNhdmVkRGF0ZXMiLCJPYmplY3QiLCJrZXlzIiwiaWQiLCJsb2FkUmVjb21tZW5kYXRpb25zIiwiZXhwb3J0RGF0YSIsInNjaGVtYVZlcnNpb24iLCJleHBvcnREYXRlIiwidG9JU09TdHJpbmciLCJFWFBPUlRfRVJST1IiLCJpbXBvcnREYXRhIiwianNvbkRhdGEiLCJpbXBvcnREYXRhV2l0aFN0cmF0ZWd5IiwiY2xlYW51cFN0b3JhZ2UiLCJvbGRlclRoYW5EYXlzIiwib2xkQmFja3VwcyIsInRvdGFsIiwiYWdlVGhyZXNob2xkIiwicmVtb3ZlZFJlY29tbWVuZGF0aW9ucyIsInVwZGF0ZWRSZWNvbW1lbmRhdGlvbnMiLCJ1cGRhdGVkU2F2ZWREYXRlcyIsImVudHJpZXMiLCJyZWNvbW1lbmRhdGlvbiIsInNhdmVkRGF0ZSIsInRvdGFsUmVtb3ZlZCIsImRvd25sb2FkRXhwb3J0ZWREYXRhIiwiZmlsZW5hbWUiLCJleHBvcnRTdHJpbmciLCJibG9iIiwiQmxvYiIsInR5cGUiLCJ1cmwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJsaW5rIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaHJlZiIsImRvd25sb2FkIiwiYm9keSIsImFwcGVuZENoaWxkIiwiY2xpY2siLCJzZXRUaW1lb3V0IiwicmV2b2tlT2JqZWN0VVJMIiwicmVtb3ZlQ2hpbGQiLCJpbXBvcnREYXRhRnJvbUZpbGUiLCJmaWxlIiwibWVyZ2VTdHJhdGVneSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsImV2ZW50IiwidGFyZ2V0Iiwib25lcnJvciIsInJlYWRBc1RleHQiLCJpbXBvcnRlZERhdGEiLCJJTVBPUlRfRVJST1IiLCJleGlzdGluZ1Byb2ZpbGVzIiwibWVyZ2VkUHJvZmlsZXMiLCJwcm9maWxlIiwiZXhpc3RpbmdQcm9maWxlIiwiaW1wb3J0ZWRUaW1lc3RhbXAiLCJleGlzdGluZ1RpbWVzdGFtcCIsImV4aXN0aW5nUmVjb21tZW5kYXRpb25zIiwibWVyZ2VkUmVjb21tZW5kYXRpb25zIiwiZXhpc3RpbmdSZWNvbW1lbmRhdGlvbiIsImltcG9ydGVkU2F2ZWREYXRlIiwiZXhpc3RpbmdTYXZlZERhdGUiLCJleGlzdGluZ1ByZWZlcmVuY2VzIiwibWVyZ2VkUHJlZmVyZW5jZXMiLCJnZXRTdG9yYWdlU3RhdHMiLCJiYWNrdXBDb3VudCIsInByb2ZpbGVDb3VudCIsInJlY29tbWVuZGF0aW9uQ291bnQiLCJjb3VudHMiLCJsYXN0VXBkYXRlZCIsImdldExhdGVzdEJhY2t1cFRpbWVzdGFtcCIsInVuZGVmaW5lZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/storageUtils.ts\n"));

/***/ })

});